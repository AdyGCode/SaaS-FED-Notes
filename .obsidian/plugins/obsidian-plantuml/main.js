/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
https://github.com/joethei/obsidian-plantuml
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/plantuml-encoder/dist/plantuml-encoder.js
var require_plantuml_encoder = __commonJS({
  "node_modules/plantuml-encoder/dist/plantuml-encoder.js"(exports, module2) {
    (function(f) {
      if (typeof exports === "object" && typeof module2 !== "undefined") {
        module2.exports = f();
      } else if (typeof define === "function" && define.amd) {
        define([], f);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.plantumlEncoder = f();
      }
    })(function() {
      var define2, module3, exports2;
      return function() {
        function r(e, n, t) {
          function o(i2, f) {
            if (!n[i2]) {
              if (!e[i2]) {
                var c = typeof require == "function" && require;
                if (!f && c)
                  return c(i2, true);
                if (u)
                  return u(i2, true);
                var a = new Error("Cannot find module '" + i2 + "'");
                throw a.code = "MODULE_NOT_FOUND", a;
              }
              var p = n[i2] = { exports: {} };
              e[i2][0].call(p.exports, function(r2) {
                var n2 = e[i2][1][r2];
                return o(n2 || r2);
              }, p, p.exports, r, e, n, t);
            }
            return n[i2].exports;
          }
          for (var u = typeof require == "function" && require, i = 0; i < t.length; i++)
            o(t[i]);
          return o;
        }
        return r;
      }()({ 1: [function(require2, module4, exports3) {
        "use strict";
        var pako = require2("pako/lib/deflate.js");
        module4.exports = function(data) {
          return pako.deflateRaw(data, { level: 9, to: "string" });
        };
      }, { "pako/lib/deflate.js": 4 }], 2: [function(require2, module4, exports3) {
        "use strict";
        function encode6bit(b) {
          if (b < 10) {
            return String.fromCharCode(48 + b);
          }
          b -= 10;
          if (b < 26) {
            return String.fromCharCode(65 + b);
          }
          b -= 26;
          if (b < 26) {
            return String.fromCharCode(97 + b);
          }
          b -= 26;
          if (b === 0) {
            return "-";
          }
          if (b === 1) {
            return "_";
          }
          return "?";
        }
        function append3bytes(b1, b2, b3) {
          var c1 = b1 >> 2;
          var c2 = (b1 & 3) << 4 | b2 >> 4;
          var c3 = (b2 & 15) << 2 | b3 >> 6;
          var c4 = b3 & 63;
          var r = "";
          r += encode6bit(c1 & 63);
          r += encode6bit(c2 & 63);
          r += encode6bit(c3 & 63);
          r += encode6bit(c4 & 63);
          return r;
        }
        module4.exports = function(data) {
          var r = "";
          for (var i = 0; i < data.length; i += 3) {
            if (i + 2 === data.length) {
              r += append3bytes(data.charCodeAt(i), data.charCodeAt(i + 1), 0);
            } else if (i + 1 === data.length) {
              r += append3bytes(data.charCodeAt(i), 0, 0);
            } else {
              r += append3bytes(data.charCodeAt(i), data.charCodeAt(i + 1), data.charCodeAt(i + 2));
            }
          }
          return r;
        };
      }, {}], 3: [function(require2, module4, exports3) {
        "use strict";
        var deflate = require2("./deflate");
        var encode64 = require2("./encode64");
        module4.exports.encode = function(puml) {
          var deflated = deflate(puml);
          return encode64(deflated);
        };
      }, { "./deflate": 1, "./encode64": 2 }], 4: [function(require2, module4, exports3) {
        "use strict";
        var zlib_deflate = require2("./zlib/deflate");
        var utils = require2("./utils/common");
        var strings = require2("./utils/strings");
        var msg = require2("./zlib/messages");
        var ZStream = require2("./zlib/zstream");
        var toString = Object.prototype.toString;
        var Z_NO_FLUSH = 0;
        var Z_FINISH = 4;
        var Z_OK = 0;
        var Z_STREAM_END = 1;
        var Z_SYNC_FLUSH = 2;
        var Z_DEFAULT_COMPRESSION = -1;
        var Z_DEFAULT_STRATEGY = 0;
        var Z_DEFLATED = 8;
        function Deflate(options) {
          if (!(this instanceof Deflate))
            return new Deflate(options);
          this.options = utils.assign({
            level: Z_DEFAULT_COMPRESSION,
            method: Z_DEFLATED,
            chunkSize: 16384,
            windowBits: 15,
            memLevel: 8,
            strategy: Z_DEFAULT_STRATEGY,
            to: ""
          }, options || {});
          var opt = this.options;
          if (opt.raw && opt.windowBits > 0) {
            opt.windowBits = -opt.windowBits;
          } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
            opt.windowBits += 16;
          }
          this.err = 0;
          this.msg = "";
          this.ended = false;
          this.chunks = [];
          this.strm = new ZStream();
          this.strm.avail_out = 0;
          var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
          if (status !== Z_OK) {
            throw new Error(msg[status]);
          }
          if (opt.header) {
            zlib_deflate.deflateSetHeader(this.strm, opt.header);
          }
          if (opt.dictionary) {
            var dict;
            if (typeof opt.dictionary === "string") {
              dict = strings.string2buf(opt.dictionary);
            } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
              dict = new Uint8Array(opt.dictionary);
            } else {
              dict = opt.dictionary;
            }
            status = zlib_deflate.deflateSetDictionary(this.strm, dict);
            if (status !== Z_OK) {
              throw new Error(msg[status]);
            }
            this._dict_set = true;
          }
        }
        Deflate.prototype.push = function(data, mode) {
          var strm = this.strm;
          var chunkSize = this.options.chunkSize;
          var status, _mode;
          if (this.ended) {
            return false;
          }
          _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
          if (typeof data === "string") {
            strm.input = strings.string2buf(data);
          } else if (toString.call(data) === "[object ArrayBuffer]") {
            strm.input = new Uint8Array(data);
          } else {
            strm.input = data;
          }
          strm.next_in = 0;
          strm.avail_in = strm.input.length;
          do {
            if (strm.avail_out === 0) {
              strm.output = new utils.Buf8(chunkSize);
              strm.next_out = 0;
              strm.avail_out = chunkSize;
            }
            status = zlib_deflate.deflate(strm, _mode);
            if (status !== Z_STREAM_END && status !== Z_OK) {
              this.onEnd(status);
              this.ended = true;
              return false;
            }
            if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
              if (this.options.to === "string") {
                this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
              } else {
                this.onData(utils.shrinkBuf(strm.output, strm.next_out));
              }
            }
          } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
          if (_mode === Z_FINISH) {
            status = zlib_deflate.deflateEnd(this.strm);
            this.onEnd(status);
            this.ended = true;
            return status === Z_OK;
          }
          if (_mode === Z_SYNC_FLUSH) {
            this.onEnd(Z_OK);
            strm.avail_out = 0;
            return true;
          }
          return true;
        };
        Deflate.prototype.onData = function(chunk) {
          this.chunks.push(chunk);
        };
        Deflate.prototype.onEnd = function(status) {
          if (status === Z_OK) {
            if (this.options.to === "string") {
              this.result = this.chunks.join("");
            } else {
              this.result = utils.flattenChunks(this.chunks);
            }
          }
          this.chunks = [];
          this.err = status;
          this.msg = this.strm.msg;
        };
        function deflate(input, options) {
          var deflator = new Deflate(options);
          deflator.push(input, true);
          if (deflator.err) {
            throw deflator.msg || msg[deflator.err];
          }
          return deflator.result;
        }
        function deflateRaw(input, options) {
          options = options || {};
          options.raw = true;
          return deflate(input, options);
        }
        function gzip(input, options) {
          options = options || {};
          options.gzip = true;
          return deflate(input, options);
        }
        exports3.Deflate = Deflate;
        exports3.deflate = deflate;
        exports3.deflateRaw = deflateRaw;
        exports3.gzip = gzip;
      }, { "./utils/common": 5, "./utils/strings": 6, "./zlib/deflate": 9, "./zlib/messages": 10, "./zlib/zstream": 12 }], 5: [function(require2, module4, exports3) {
        "use strict";
        var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
        function _has(obj, key) {
          return Object.prototype.hasOwnProperty.call(obj, key);
        }
        exports3.assign = function(obj) {
          var sources = Array.prototype.slice.call(arguments, 1);
          while (sources.length) {
            var source = sources.shift();
            if (!source) {
              continue;
            }
            if (typeof source !== "object") {
              throw new TypeError(source + "must be non-object");
            }
            for (var p in source) {
              if (_has(source, p)) {
                obj[p] = source[p];
              }
            }
          }
          return obj;
        };
        exports3.shrinkBuf = function(buf, size) {
          if (buf.length === size) {
            return buf;
          }
          if (buf.subarray) {
            return buf.subarray(0, size);
          }
          buf.length = size;
          return buf;
        };
        var fnTyped = {
          arraySet: function(dest, src, src_offs, len, dest_offs) {
            if (src.subarray && dest.subarray) {
              dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
              return;
            }
            for (var i = 0; i < len; i++) {
              dest[dest_offs + i] = src[src_offs + i];
            }
          },
          flattenChunks: function(chunks) {
            var i, l, len, pos, chunk, result;
            len = 0;
            for (i = 0, l = chunks.length; i < l; i++) {
              len += chunks[i].length;
            }
            result = new Uint8Array(len);
            pos = 0;
            for (i = 0, l = chunks.length; i < l; i++) {
              chunk = chunks[i];
              result.set(chunk, pos);
              pos += chunk.length;
            }
            return result;
          }
        };
        var fnUntyped = {
          arraySet: function(dest, src, src_offs, len, dest_offs) {
            for (var i = 0; i < len; i++) {
              dest[dest_offs + i] = src[src_offs + i];
            }
          },
          flattenChunks: function(chunks) {
            return [].concat.apply([], chunks);
          }
        };
        exports3.setTyped = function(on) {
          if (on) {
            exports3.Buf8 = Uint8Array;
            exports3.Buf16 = Uint16Array;
            exports3.Buf32 = Int32Array;
            exports3.assign(exports3, fnTyped);
          } else {
            exports3.Buf8 = Array;
            exports3.Buf16 = Array;
            exports3.Buf32 = Array;
            exports3.assign(exports3, fnUntyped);
          }
        };
        exports3.setTyped(TYPED_OK);
      }, {}], 6: [function(require2, module4, exports3) {
        "use strict";
        var utils = require2("./common");
        var STR_APPLY_OK = true;
        var STR_APPLY_UIA_OK = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (__) {
          STR_APPLY_OK = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (__) {
          STR_APPLY_UIA_OK = false;
        }
        var _utf8len = new utils.Buf8(256);
        for (var q = 0; q < 256; q++) {
          _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
        }
        _utf8len[254] = _utf8len[254] = 1;
        exports3.string2buf = function(str) {
          var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
          for (m_pos = 0; m_pos < str_len; m_pos++) {
            c = str.charCodeAt(m_pos);
            if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
              c2 = str.charCodeAt(m_pos + 1);
              if ((c2 & 64512) === 56320) {
                c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                m_pos++;
              }
            }
            buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
          }
          buf = new utils.Buf8(buf_len);
          for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
            c = str.charCodeAt(m_pos);
            if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
              c2 = str.charCodeAt(m_pos + 1);
              if ((c2 & 64512) === 56320) {
                c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                m_pos++;
              }
            }
            if (c < 128) {
              buf[i++] = c;
            } else if (c < 2048) {
              buf[i++] = 192 | c >>> 6;
              buf[i++] = 128 | c & 63;
            } else if (c < 65536) {
              buf[i++] = 224 | c >>> 12;
              buf[i++] = 128 | c >>> 6 & 63;
              buf[i++] = 128 | c & 63;
            } else {
              buf[i++] = 240 | c >>> 18;
              buf[i++] = 128 | c >>> 12 & 63;
              buf[i++] = 128 | c >>> 6 & 63;
              buf[i++] = 128 | c & 63;
            }
          }
          return buf;
        };
        function buf2binstring(buf, len) {
          if (len < 65534) {
            if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
              return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
            }
          }
          var result = "";
          for (var i = 0; i < len; i++) {
            result += String.fromCharCode(buf[i]);
          }
          return result;
        }
        exports3.buf2binstring = function(buf) {
          return buf2binstring(buf, buf.length);
        };
        exports3.binstring2buf = function(str) {
          var buf = new utils.Buf8(str.length);
          for (var i = 0, len = buf.length; i < len; i++) {
            buf[i] = str.charCodeAt(i);
          }
          return buf;
        };
        exports3.buf2string = function(buf, max) {
          var i, out, c, c_len;
          var len = max || buf.length;
          var utf16buf = new Array(len * 2);
          for (out = 0, i = 0; i < len; ) {
            c = buf[i++];
            if (c < 128) {
              utf16buf[out++] = c;
              continue;
            }
            c_len = _utf8len[c];
            if (c_len > 4) {
              utf16buf[out++] = 65533;
              i += c_len - 1;
              continue;
            }
            c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
            while (c_len > 1 && i < len) {
              c = c << 6 | buf[i++] & 63;
              c_len--;
            }
            if (c_len > 1) {
              utf16buf[out++] = 65533;
              continue;
            }
            if (c < 65536) {
              utf16buf[out++] = c;
            } else {
              c -= 65536;
              utf16buf[out++] = 55296 | c >> 10 & 1023;
              utf16buf[out++] = 56320 | c & 1023;
            }
          }
          return buf2binstring(utf16buf, out);
        };
        exports3.utf8border = function(buf, max) {
          var pos;
          max = max || buf.length;
          if (max > buf.length) {
            max = buf.length;
          }
          pos = max - 1;
          while (pos >= 0 && (buf[pos] & 192) === 128) {
            pos--;
          }
          if (pos < 0) {
            return max;
          }
          if (pos === 0) {
            return max;
          }
          return pos + _utf8len[buf[pos]] > max ? pos : max;
        };
      }, { "./common": 5 }], 7: [function(require2, module4, exports3) {
        "use strict";
        function adler32(adler, buf, len, pos) {
          var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
          while (len !== 0) {
            n = len > 2e3 ? 2e3 : len;
            len -= n;
            do {
              s1 = s1 + buf[pos++] | 0;
              s2 = s2 + s1 | 0;
            } while (--n);
            s1 %= 65521;
            s2 %= 65521;
          }
          return s1 | s2 << 16 | 0;
        }
        module4.exports = adler32;
      }, {}], 8: [function(require2, module4, exports3) {
        "use strict";
        function makeTable() {
          var c, table = [];
          for (var n = 0; n < 256; n++) {
            c = n;
            for (var k = 0; k < 8; k++) {
              c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
            }
            table[n] = c;
          }
          return table;
        }
        var crcTable = makeTable();
        function crc32(crc, buf, len, pos) {
          var t = crcTable, end = pos + len;
          crc ^= -1;
          for (var i = pos; i < end; i++) {
            crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
          }
          return crc ^ -1;
        }
        module4.exports = crc32;
      }, {}], 9: [function(require2, module4, exports3) {
        "use strict";
        var utils = require2("../utils/common");
        var trees = require2("./trees");
        var adler32 = require2("./adler32");
        var crc32 = require2("./crc32");
        var msg = require2("./messages");
        var Z_NO_FLUSH = 0;
        var Z_PARTIAL_FLUSH = 1;
        var Z_FULL_FLUSH = 3;
        var Z_FINISH = 4;
        var Z_BLOCK = 5;
        var Z_OK = 0;
        var Z_STREAM_END = 1;
        var Z_STREAM_ERROR = -2;
        var Z_DATA_ERROR = -3;
        var Z_BUF_ERROR = -5;
        var Z_DEFAULT_COMPRESSION = -1;
        var Z_FILTERED = 1;
        var Z_HUFFMAN_ONLY = 2;
        var Z_RLE = 3;
        var Z_FIXED = 4;
        var Z_DEFAULT_STRATEGY = 0;
        var Z_UNKNOWN = 2;
        var Z_DEFLATED = 8;
        var MAX_MEM_LEVEL = 9;
        var MAX_WBITS = 15;
        var DEF_MEM_LEVEL = 8;
        var LENGTH_CODES = 29;
        var LITERALS = 256;
        var L_CODES = LITERALS + 1 + LENGTH_CODES;
        var D_CODES = 30;
        var BL_CODES = 19;
        var HEAP_SIZE = 2 * L_CODES + 1;
        var MAX_BITS = 15;
        var MIN_MATCH = 3;
        var MAX_MATCH = 258;
        var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
        var PRESET_DICT = 32;
        var INIT_STATE = 42;
        var EXTRA_STATE = 69;
        var NAME_STATE = 73;
        var COMMENT_STATE = 91;
        var HCRC_STATE = 103;
        var BUSY_STATE = 113;
        var FINISH_STATE = 666;
        var BS_NEED_MORE = 1;
        var BS_BLOCK_DONE = 2;
        var BS_FINISH_STARTED = 3;
        var BS_FINISH_DONE = 4;
        var OS_CODE = 3;
        function err(strm, errorCode) {
          strm.msg = msg[errorCode];
          return errorCode;
        }
        function rank(f) {
          return (f << 1) - (f > 4 ? 9 : 0);
        }
        function zero(buf) {
          var len = buf.length;
          while (--len >= 0) {
            buf[len] = 0;
          }
        }
        function flush_pending(strm) {
          var s = strm.state;
          var len = s.pending;
          if (len > strm.avail_out) {
            len = strm.avail_out;
          }
          if (len === 0) {
            return;
          }
          utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
          strm.next_out += len;
          s.pending_out += len;
          strm.total_out += len;
          strm.avail_out -= len;
          s.pending -= len;
          if (s.pending === 0) {
            s.pending_out = 0;
          }
        }
        function flush_block_only(s, last) {
          trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
          s.block_start = s.strstart;
          flush_pending(s.strm);
        }
        function put_byte(s, b) {
          s.pending_buf[s.pending++] = b;
        }
        function putShortMSB(s, b) {
          s.pending_buf[s.pending++] = b >>> 8 & 255;
          s.pending_buf[s.pending++] = b & 255;
        }
        function read_buf(strm, buf, start, size) {
          var len = strm.avail_in;
          if (len > size) {
            len = size;
          }
          if (len === 0) {
            return 0;
          }
          strm.avail_in -= len;
          utils.arraySet(buf, strm.input, strm.next_in, len, start);
          if (strm.state.wrap === 1) {
            strm.adler = adler32(strm.adler, buf, len, start);
          } else if (strm.state.wrap === 2) {
            strm.adler = crc32(strm.adler, buf, len, start);
          }
          strm.next_in += len;
          strm.total_in += len;
          return len;
        }
        function longest_match(s, cur_match) {
          var chain_length = s.max_chain_length;
          var scan = s.strstart;
          var match;
          var len;
          var best_len = s.prev_length;
          var nice_match = s.nice_match;
          var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
          var _win = s.window;
          var wmask = s.w_mask;
          var prev = s.prev;
          var strend = s.strstart + MAX_MATCH;
          var scan_end1 = _win[scan + best_len - 1];
          var scan_end = _win[scan + best_len];
          if (s.prev_length >= s.good_match) {
            chain_length >>= 2;
          }
          if (nice_match > s.lookahead) {
            nice_match = s.lookahead;
          }
          do {
            match = cur_match;
            if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
              continue;
            }
            scan += 2;
            match++;
            do {
            } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
            len = MAX_MATCH - (strend - scan);
            scan = strend - MAX_MATCH;
            if (len > best_len) {
              s.match_start = cur_match;
              best_len = len;
              if (len >= nice_match) {
                break;
              }
              scan_end1 = _win[scan + best_len - 1];
              scan_end = _win[scan + best_len];
            }
          } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
          if (best_len <= s.lookahead) {
            return best_len;
          }
          return s.lookahead;
        }
        function fill_window(s) {
          var _w_size = s.w_size;
          var p, n, m, more, str;
          do {
            more = s.window_size - s.lookahead - s.strstart;
            if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
              utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
              s.match_start -= _w_size;
              s.strstart -= _w_size;
              s.block_start -= _w_size;
              n = s.hash_size;
              p = n;
              do {
                m = s.head[--p];
                s.head[p] = m >= _w_size ? m - _w_size : 0;
              } while (--n);
              n = _w_size;
              p = n;
              do {
                m = s.prev[--p];
                s.prev[p] = m >= _w_size ? m - _w_size : 0;
              } while (--n);
              more += _w_size;
            }
            if (s.strm.avail_in === 0) {
              break;
            }
            n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
            s.lookahead += n;
            if (s.lookahead + s.insert >= MIN_MATCH) {
              str = s.strstart - s.insert;
              s.ins_h = s.window[str];
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
              while (s.insert) {
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
                s.prev[str & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = str;
                str++;
                s.insert--;
                if (s.lookahead + s.insert < MIN_MATCH) {
                  break;
                }
              }
            }
          } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
        }
        function deflate_stored(s, flush) {
          var max_block_size = 65535;
          if (max_block_size > s.pending_buf_size - 5) {
            max_block_size = s.pending_buf_size - 5;
          }
          for (; ; ) {
            if (s.lookahead <= 1) {
              fill_window(s);
              if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              if (s.lookahead === 0) {
                break;
              }
            }
            s.strstart += s.lookahead;
            s.lookahead = 0;
            var max_start = s.block_start + max_block_size;
            if (s.strstart === 0 || s.strstart >= max_start) {
              s.lookahead = s.strstart - max_start;
              s.strstart = max_start;
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
            if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s.insert = 0;
          if (flush === Z_FINISH) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s.strstart > s.block_start) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_NEED_MORE;
        }
        function deflate_fast(s, flush) {
          var hash_head;
          var bflush;
          for (; ; ) {
            if (s.lookahead < MIN_LOOKAHEAD) {
              fill_window(s);
              if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              if (s.lookahead === 0) {
                break;
              }
            }
            hash_head = 0;
            if (s.lookahead >= MIN_MATCH) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
            if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
              s.match_length = longest_match(s, hash_head);
            }
            if (s.match_length >= MIN_MATCH) {
              bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
              s.lookahead -= s.match_length;
              if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
                s.match_length--;
                do {
                  s.strstart++;
                  s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                  hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                  s.head[s.ins_h] = s.strstart;
                } while (--s.match_length !== 0);
                s.strstart++;
              } else {
                s.strstart += s.match_length;
                s.match_length = 0;
                s.ins_h = s.window[s.strstart];
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
              }
            } else {
              bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
              s.lookahead--;
              s.strstart++;
            }
            if (bflush) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
          if (flush === Z_FINISH) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s.last_lit) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        }
        function deflate_slow(s, flush) {
          var hash_head;
          var bflush;
          var max_insert;
          for (; ; ) {
            if (s.lookahead < MIN_LOOKAHEAD) {
              fill_window(s);
              if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              if (s.lookahead === 0) {
                break;
              }
            }
            hash_head = 0;
            if (s.lookahead >= MIN_MATCH) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
            s.prev_length = s.match_length;
            s.prev_match = s.match_start;
            s.match_length = MIN_MATCH - 1;
            if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
              s.match_length = longest_match(s, hash_head);
              if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
                s.match_length = MIN_MATCH - 1;
              }
            }
            if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
              max_insert = s.strstart + s.lookahead - MIN_MATCH;
              bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
              s.lookahead -= s.prev_length - 1;
              s.prev_length -= 2;
              do {
                if (++s.strstart <= max_insert) {
                  s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                  hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                  s.head[s.ins_h] = s.strstart;
                }
              } while (--s.prev_length !== 0);
              s.match_available = 0;
              s.match_length = MIN_MATCH - 1;
              s.strstart++;
              if (bflush) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                  return BS_NEED_MORE;
                }
              }
            } else if (s.match_available) {
              bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
              if (bflush) {
                flush_block_only(s, false);
              }
              s.strstart++;
              s.lookahead--;
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            } else {
              s.match_available = 1;
              s.strstart++;
              s.lookahead--;
            }
          }
          if (s.match_available) {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
            s.match_available = 0;
          }
          s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
          if (flush === Z_FINISH) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s.last_lit) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        }
        function deflate_rle(s, flush) {
          var bflush;
          var prev;
          var scan, strend;
          var _win = s.window;
          for (; ; ) {
            if (s.lookahead <= MAX_MATCH) {
              fill_window(s);
              if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              if (s.lookahead === 0) {
                break;
              }
            }
            s.match_length = 0;
            if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
              scan = s.strstart - 1;
              prev = _win[scan];
              if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                strend = s.strstart + MAX_MATCH;
                do {
                } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
                s.match_length = MAX_MATCH - (strend - scan);
                if (s.match_length > s.lookahead) {
                  s.match_length = s.lookahead;
                }
              }
            }
            if (s.match_length >= MIN_MATCH) {
              bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
              s.lookahead -= s.match_length;
              s.strstart += s.match_length;
              s.match_length = 0;
            } else {
              bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
              s.lookahead--;
              s.strstart++;
            }
            if (bflush) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s.insert = 0;
          if (flush === Z_FINISH) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s.last_lit) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        }
        function deflate_huff(s, flush) {
          var bflush;
          for (; ; ) {
            if (s.lookahead === 0) {
              fill_window(s);
              if (s.lookahead === 0) {
                if (flush === Z_NO_FLUSH) {
                  return BS_NEED_MORE;
                }
                break;
              }
            }
            s.match_length = 0;
            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
            if (bflush) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s.insert = 0;
          if (flush === Z_FINISH) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s.last_lit) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        }
        function Config(good_length, max_lazy, nice_length, max_chain, func) {
          this.good_length = good_length;
          this.max_lazy = max_lazy;
          this.nice_length = nice_length;
          this.max_chain = max_chain;
          this.func = func;
        }
        var configuration_table;
        configuration_table = [
          new Config(0, 0, 0, 0, deflate_stored),
          new Config(4, 4, 8, 4, deflate_fast),
          new Config(4, 5, 16, 8, deflate_fast),
          new Config(4, 6, 32, 32, deflate_fast),
          new Config(4, 4, 16, 16, deflate_slow),
          new Config(8, 16, 32, 32, deflate_slow),
          new Config(8, 16, 128, 128, deflate_slow),
          new Config(8, 32, 128, 256, deflate_slow),
          new Config(32, 128, 258, 1024, deflate_slow),
          new Config(32, 258, 258, 4096, deflate_slow)
        ];
        function lm_init(s) {
          s.window_size = 2 * s.w_size;
          zero(s.head);
          s.max_lazy_match = configuration_table[s.level].max_lazy;
          s.good_match = configuration_table[s.level].good_length;
          s.nice_match = configuration_table[s.level].nice_length;
          s.max_chain_length = configuration_table[s.level].max_chain;
          s.strstart = 0;
          s.block_start = 0;
          s.lookahead = 0;
          s.insert = 0;
          s.match_length = s.prev_length = MIN_MATCH - 1;
          s.match_available = 0;
          s.ins_h = 0;
        }
        function DeflateState() {
          this.strm = null;
          this.status = 0;
          this.pending_buf = null;
          this.pending_buf_size = 0;
          this.pending_out = 0;
          this.pending = 0;
          this.wrap = 0;
          this.gzhead = null;
          this.gzindex = 0;
          this.method = Z_DEFLATED;
          this.last_flush = -1;
          this.w_size = 0;
          this.w_bits = 0;
          this.w_mask = 0;
          this.window = null;
          this.window_size = 0;
          this.prev = null;
          this.head = null;
          this.ins_h = 0;
          this.hash_size = 0;
          this.hash_bits = 0;
          this.hash_mask = 0;
          this.hash_shift = 0;
          this.block_start = 0;
          this.match_length = 0;
          this.prev_match = 0;
          this.match_available = 0;
          this.strstart = 0;
          this.match_start = 0;
          this.lookahead = 0;
          this.prev_length = 0;
          this.max_chain_length = 0;
          this.max_lazy_match = 0;
          this.level = 0;
          this.strategy = 0;
          this.good_match = 0;
          this.nice_match = 0;
          this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
          this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
          this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
          zero(this.dyn_ltree);
          zero(this.dyn_dtree);
          zero(this.bl_tree);
          this.l_desc = null;
          this.d_desc = null;
          this.bl_desc = null;
          this.bl_count = new utils.Buf16(MAX_BITS + 1);
          this.heap = new utils.Buf16(2 * L_CODES + 1);
          zero(this.heap);
          this.heap_len = 0;
          this.heap_max = 0;
          this.depth = new utils.Buf16(2 * L_CODES + 1);
          zero(this.depth);
          this.l_buf = 0;
          this.lit_bufsize = 0;
          this.last_lit = 0;
          this.d_buf = 0;
          this.opt_len = 0;
          this.static_len = 0;
          this.matches = 0;
          this.insert = 0;
          this.bi_buf = 0;
          this.bi_valid = 0;
        }
        function deflateResetKeep(strm) {
          var s;
          if (!strm || !strm.state) {
            return err(strm, Z_STREAM_ERROR);
          }
          strm.total_in = strm.total_out = 0;
          strm.data_type = Z_UNKNOWN;
          s = strm.state;
          s.pending = 0;
          s.pending_out = 0;
          if (s.wrap < 0) {
            s.wrap = -s.wrap;
          }
          s.status = s.wrap ? INIT_STATE : BUSY_STATE;
          strm.adler = s.wrap === 2 ? 0 : 1;
          s.last_flush = Z_NO_FLUSH;
          trees._tr_init(s);
          return Z_OK;
        }
        function deflateReset(strm) {
          var ret = deflateResetKeep(strm);
          if (ret === Z_OK) {
            lm_init(strm.state);
          }
          return ret;
        }
        function deflateSetHeader(strm, head) {
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          if (strm.state.wrap !== 2) {
            return Z_STREAM_ERROR;
          }
          strm.state.gzhead = head;
          return Z_OK;
        }
        function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
          if (!strm) {
            return Z_STREAM_ERROR;
          }
          var wrap = 1;
          if (level === Z_DEFAULT_COMPRESSION) {
            level = 6;
          }
          if (windowBits < 0) {
            wrap = 0;
            windowBits = -windowBits;
          } else if (windowBits > 15) {
            wrap = 2;
            windowBits -= 16;
          }
          if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
            return err(strm, Z_STREAM_ERROR);
          }
          if (windowBits === 8) {
            windowBits = 9;
          }
          var s = new DeflateState();
          strm.state = s;
          s.strm = strm;
          s.wrap = wrap;
          s.gzhead = null;
          s.w_bits = windowBits;
          s.w_size = 1 << s.w_bits;
          s.w_mask = s.w_size - 1;
          s.hash_bits = memLevel + 7;
          s.hash_size = 1 << s.hash_bits;
          s.hash_mask = s.hash_size - 1;
          s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
          s.window = new utils.Buf8(s.w_size * 2);
          s.head = new utils.Buf16(s.hash_size);
          s.prev = new utils.Buf16(s.w_size);
          s.lit_bufsize = 1 << memLevel + 6;
          s.pending_buf_size = s.lit_bufsize * 4;
          s.pending_buf = new utils.Buf8(s.pending_buf_size);
          s.d_buf = 1 * s.lit_bufsize;
          s.l_buf = (1 + 2) * s.lit_bufsize;
          s.level = level;
          s.strategy = strategy;
          s.method = method;
          return deflateReset(strm);
        }
        function deflateInit(strm, level) {
          return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
        }
        function deflate(strm, flush) {
          var old_flush, s;
          var beg, val;
          if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
            return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
          }
          s = strm.state;
          if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
            return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
          }
          s.strm = strm;
          old_flush = s.last_flush;
          s.last_flush = flush;
          if (s.status === INIT_STATE) {
            if (s.wrap === 2) {
              strm.adler = 0;
              put_byte(s, 31);
              put_byte(s, 139);
              put_byte(s, 8);
              if (!s.gzhead) {
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                put_byte(s, OS_CODE);
                s.status = BUSY_STATE;
              } else {
                put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
                put_byte(s, s.gzhead.time & 255);
                put_byte(s, s.gzhead.time >> 8 & 255);
                put_byte(s, s.gzhead.time >> 16 & 255);
                put_byte(s, s.gzhead.time >> 24 & 255);
                put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                put_byte(s, s.gzhead.os & 255);
                if (s.gzhead.extra && s.gzhead.extra.length) {
                  put_byte(s, s.gzhead.extra.length & 255);
                  put_byte(s, s.gzhead.extra.length >> 8 & 255);
                }
                if (s.gzhead.hcrc) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
                }
                s.gzindex = 0;
                s.status = EXTRA_STATE;
              }
            } else {
              var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
              var level_flags = -1;
              if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
                level_flags = 0;
              } else if (s.level < 6) {
                level_flags = 1;
              } else if (s.level === 6) {
                level_flags = 2;
              } else {
                level_flags = 3;
              }
              header |= level_flags << 6;
              if (s.strstart !== 0) {
                header |= PRESET_DICT;
              }
              header += 31 - header % 31;
              s.status = BUSY_STATE;
              putShortMSB(s, header);
              if (s.strstart !== 0) {
                putShortMSB(s, strm.adler >>> 16);
                putShortMSB(s, strm.adler & 65535);
              }
              strm.adler = 1;
            }
          }
          if (s.status === EXTRA_STATE) {
            if (s.gzhead.extra) {
              beg = s.pending;
              while (s.gzindex < (s.gzhead.extra.length & 65535)) {
                if (s.pending === s.pending_buf_size) {
                  if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                  }
                  flush_pending(strm);
                  beg = s.pending;
                  if (s.pending === s.pending_buf_size) {
                    break;
                  }
                }
                put_byte(s, s.gzhead.extra[s.gzindex] & 255);
                s.gzindex++;
              }
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              if (s.gzindex === s.gzhead.extra.length) {
                s.gzindex = 0;
                s.status = NAME_STATE;
              }
            } else {
              s.status = NAME_STATE;
            }
          }
          if (s.status === NAME_STATE) {
            if (s.gzhead.name) {
              beg = s.pending;
              do {
                if (s.pending === s.pending_buf_size) {
                  if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                  }
                  flush_pending(strm);
                  beg = s.pending;
                  if (s.pending === s.pending_buf_size) {
                    val = 1;
                    break;
                  }
                }
                if (s.gzindex < s.gzhead.name.length) {
                  val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
                } else {
                  val = 0;
                }
                put_byte(s, val);
              } while (val !== 0);
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              if (val === 0) {
                s.gzindex = 0;
                s.status = COMMENT_STATE;
              }
            } else {
              s.status = COMMENT_STATE;
            }
          }
          if (s.status === COMMENT_STATE) {
            if (s.gzhead.comment) {
              beg = s.pending;
              do {
                if (s.pending === s.pending_buf_size) {
                  if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                  }
                  flush_pending(strm);
                  beg = s.pending;
                  if (s.pending === s.pending_buf_size) {
                    val = 1;
                    break;
                  }
                }
                if (s.gzindex < s.gzhead.comment.length) {
                  val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
                } else {
                  val = 0;
                }
                put_byte(s, val);
              } while (val !== 0);
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              if (val === 0) {
                s.status = HCRC_STATE;
              }
            } else {
              s.status = HCRC_STATE;
            }
          }
          if (s.status === HCRC_STATE) {
            if (s.gzhead.hcrc) {
              if (s.pending + 2 > s.pending_buf_size) {
                flush_pending(strm);
              }
              if (s.pending + 2 <= s.pending_buf_size) {
                put_byte(s, strm.adler & 255);
                put_byte(s, strm.adler >> 8 & 255);
                strm.adler = 0;
                s.status = BUSY_STATE;
              }
            } else {
              s.status = BUSY_STATE;
            }
          }
          if (s.pending !== 0) {
            flush_pending(strm);
            if (strm.avail_out === 0) {
              s.last_flush = -1;
              return Z_OK;
            }
          } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
            return err(strm, Z_BUF_ERROR);
          }
          if (s.status === FINISH_STATE && strm.avail_in !== 0) {
            return err(strm, Z_BUF_ERROR);
          }
          if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
            var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
            if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
              s.status = FINISH_STATE;
            }
            if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
              if (strm.avail_out === 0) {
                s.last_flush = -1;
              }
              return Z_OK;
            }
            if (bstate === BS_BLOCK_DONE) {
              if (flush === Z_PARTIAL_FLUSH) {
                trees._tr_align(s);
              } else if (flush !== Z_BLOCK) {
                trees._tr_stored_block(s, 0, 0, false);
                if (flush === Z_FULL_FLUSH) {
                  zero(s.head);
                  if (s.lookahead === 0) {
                    s.strstart = 0;
                    s.block_start = 0;
                    s.insert = 0;
                  }
                }
              }
              flush_pending(strm);
              if (strm.avail_out === 0) {
                s.last_flush = -1;
                return Z_OK;
              }
            }
          }
          if (flush !== Z_FINISH) {
            return Z_OK;
          }
          if (s.wrap <= 0) {
            return Z_STREAM_END;
          }
          if (s.wrap === 2) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            put_byte(s, strm.adler >> 16 & 255);
            put_byte(s, strm.adler >> 24 & 255);
            put_byte(s, strm.total_in & 255);
            put_byte(s, strm.total_in >> 8 & 255);
            put_byte(s, strm.total_in >> 16 & 255);
            put_byte(s, strm.total_in >> 24 & 255);
          } else {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
          }
          flush_pending(strm);
          if (s.wrap > 0) {
            s.wrap = -s.wrap;
          }
          return s.pending !== 0 ? Z_OK : Z_STREAM_END;
        }
        function deflateEnd(strm) {
          var status;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          status = strm.state.status;
          if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
            return err(strm, Z_STREAM_ERROR);
          }
          strm.state = null;
          return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
        }
        function deflateSetDictionary(strm, dictionary) {
          var dictLength = dictionary.length;
          var s;
          var str, n;
          var wrap;
          var avail;
          var next;
          var input;
          var tmpDict;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          s = strm.state;
          wrap = s.wrap;
          if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
            return Z_STREAM_ERROR;
          }
          if (wrap === 1) {
            strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
          }
          s.wrap = 0;
          if (dictLength >= s.w_size) {
            if (wrap === 0) {
              zero(s.head);
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
            tmpDict = new utils.Buf8(s.w_size);
            utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
            dictionary = tmpDict;
            dictLength = s.w_size;
          }
          avail = strm.avail_in;
          next = strm.next_in;
          input = strm.input;
          strm.avail_in = dictLength;
          strm.next_in = 0;
          strm.input = dictionary;
          fill_window(s);
          while (s.lookahead >= MIN_MATCH) {
            str = s.strstart;
            n = s.lookahead - (MIN_MATCH - 1);
            do {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
              s.prev[str & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = str;
              str++;
            } while (--n);
            s.strstart = str;
            s.lookahead = MIN_MATCH - 1;
            fill_window(s);
          }
          s.strstart += s.lookahead;
          s.block_start = s.strstart;
          s.insert = s.lookahead;
          s.lookahead = 0;
          s.match_length = s.prev_length = MIN_MATCH - 1;
          s.match_available = 0;
          strm.next_in = next;
          strm.input = input;
          strm.avail_in = avail;
          s.wrap = wrap;
          return Z_OK;
        }
        exports3.deflateInit = deflateInit;
        exports3.deflateInit2 = deflateInit2;
        exports3.deflateReset = deflateReset;
        exports3.deflateResetKeep = deflateResetKeep;
        exports3.deflateSetHeader = deflateSetHeader;
        exports3.deflate = deflate;
        exports3.deflateEnd = deflateEnd;
        exports3.deflateSetDictionary = deflateSetDictionary;
        exports3.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 5, "./adler32": 7, "./crc32": 8, "./messages": 10, "./trees": 11 }], 10: [function(require2, module4, exports3) {
        "use strict";
        module4.exports = {
          2: "need dictionary",
          1: "stream end",
          0: "",
          "-1": "file error",
          "-2": "stream error",
          "-3": "data error",
          "-4": "insufficient memory",
          "-5": "buffer error",
          "-6": "incompatible version"
        };
      }, {}], 11: [function(require2, module4, exports3) {
        "use strict";
        var utils = require2("../utils/common");
        var Z_FIXED = 4;
        var Z_BINARY = 0;
        var Z_TEXT = 1;
        var Z_UNKNOWN = 2;
        function zero(buf) {
          var len = buf.length;
          while (--len >= 0) {
            buf[len] = 0;
          }
        }
        var STORED_BLOCK = 0;
        var STATIC_TREES = 1;
        var DYN_TREES = 2;
        var MIN_MATCH = 3;
        var MAX_MATCH = 258;
        var LENGTH_CODES = 29;
        var LITERALS = 256;
        var L_CODES = LITERALS + 1 + LENGTH_CODES;
        var D_CODES = 30;
        var BL_CODES = 19;
        var HEAP_SIZE = 2 * L_CODES + 1;
        var MAX_BITS = 15;
        var Buf_size = 16;
        var MAX_BL_BITS = 7;
        var END_BLOCK = 256;
        var REP_3_6 = 16;
        var REPZ_3_10 = 17;
        var REPZ_11_138 = 18;
        var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
        var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
        var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
        var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        var DIST_CODE_LEN = 512;
        var static_ltree = new Array((L_CODES + 2) * 2);
        zero(static_ltree);
        var static_dtree = new Array(D_CODES * 2);
        zero(static_dtree);
        var _dist_code = new Array(DIST_CODE_LEN);
        zero(_dist_code);
        var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
        zero(_length_code);
        var base_length = new Array(LENGTH_CODES);
        zero(base_length);
        var base_dist = new Array(D_CODES);
        zero(base_dist);
        function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
          this.static_tree = static_tree;
          this.extra_bits = extra_bits;
          this.extra_base = extra_base;
          this.elems = elems;
          this.max_length = max_length;
          this.has_stree = static_tree && static_tree.length;
        }
        var static_l_desc;
        var static_d_desc;
        var static_bl_desc;
        function TreeDesc(dyn_tree, stat_desc) {
          this.dyn_tree = dyn_tree;
          this.max_code = 0;
          this.stat_desc = stat_desc;
        }
        function d_code(dist) {
          return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
        }
        function put_short(s, w) {
          s.pending_buf[s.pending++] = w & 255;
          s.pending_buf[s.pending++] = w >>> 8 & 255;
        }
        function send_bits(s, value, length) {
          if (s.bi_valid > Buf_size - length) {
            s.bi_buf |= value << s.bi_valid & 65535;
            put_short(s, s.bi_buf);
            s.bi_buf = value >> Buf_size - s.bi_valid;
            s.bi_valid += length - Buf_size;
          } else {
            s.bi_buf |= value << s.bi_valid & 65535;
            s.bi_valid += length;
          }
        }
        function send_code(s, c, tree) {
          send_bits(s, tree[c * 2], tree[c * 2 + 1]);
        }
        function bi_reverse(code, len) {
          var res = 0;
          do {
            res |= code & 1;
            code >>>= 1;
            res <<= 1;
          } while (--len > 0);
          return res >>> 1;
        }
        function bi_flush(s) {
          if (s.bi_valid === 16) {
            put_short(s, s.bi_buf);
            s.bi_buf = 0;
            s.bi_valid = 0;
          } else if (s.bi_valid >= 8) {
            s.pending_buf[s.pending++] = s.bi_buf & 255;
            s.bi_buf >>= 8;
            s.bi_valid -= 8;
          }
        }
        function gen_bitlen(s, desc) {
          var tree = desc.dyn_tree;
          var max_code = desc.max_code;
          var stree = desc.stat_desc.static_tree;
          var has_stree = desc.stat_desc.has_stree;
          var extra = desc.stat_desc.extra_bits;
          var base = desc.stat_desc.extra_base;
          var max_length = desc.stat_desc.max_length;
          var h;
          var n, m;
          var bits;
          var xbits;
          var f;
          var overflow = 0;
          for (bits = 0; bits <= MAX_BITS; bits++) {
            s.bl_count[bits] = 0;
          }
          tree[s.heap[s.heap_max] * 2 + 1] = 0;
          for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
            n = s.heap[h];
            bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
            if (bits > max_length) {
              bits = max_length;
              overflow++;
            }
            tree[n * 2 + 1] = bits;
            if (n > max_code) {
              continue;
            }
            s.bl_count[bits]++;
            xbits = 0;
            if (n >= base) {
              xbits = extra[n - base];
            }
            f = tree[n * 2];
            s.opt_len += f * (bits + xbits);
            if (has_stree) {
              s.static_len += f * (stree[n * 2 + 1] + xbits);
            }
          }
          if (overflow === 0) {
            return;
          }
          do {
            bits = max_length - 1;
            while (s.bl_count[bits] === 0) {
              bits--;
            }
            s.bl_count[bits]--;
            s.bl_count[bits + 1] += 2;
            s.bl_count[max_length]--;
            overflow -= 2;
          } while (overflow > 0);
          for (bits = max_length; bits !== 0; bits--) {
            n = s.bl_count[bits];
            while (n !== 0) {
              m = s.heap[--h];
              if (m > max_code) {
                continue;
              }
              if (tree[m * 2 + 1] !== bits) {
                s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
                tree[m * 2 + 1] = bits;
              }
              n--;
            }
          }
        }
        function gen_codes(tree, max_code, bl_count) {
          var next_code = new Array(MAX_BITS + 1);
          var code = 0;
          var bits;
          var n;
          for (bits = 1; bits <= MAX_BITS; bits++) {
            next_code[bits] = code = code + bl_count[bits - 1] << 1;
          }
          for (n = 0; n <= max_code; n++) {
            var len = tree[n * 2 + 1];
            if (len === 0) {
              continue;
            }
            tree[n * 2] = bi_reverse(next_code[len]++, len);
          }
        }
        function tr_static_init() {
          var n;
          var bits;
          var length;
          var code;
          var dist;
          var bl_count = new Array(MAX_BITS + 1);
          length = 0;
          for (code = 0; code < LENGTH_CODES - 1; code++) {
            base_length[code] = length;
            for (n = 0; n < 1 << extra_lbits[code]; n++) {
              _length_code[length++] = code;
            }
          }
          _length_code[length - 1] = code;
          dist = 0;
          for (code = 0; code < 16; code++) {
            base_dist[code] = dist;
            for (n = 0; n < 1 << extra_dbits[code]; n++) {
              _dist_code[dist++] = code;
            }
          }
          dist >>= 7;
          for (; code < D_CODES; code++) {
            base_dist[code] = dist << 7;
            for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
              _dist_code[256 + dist++] = code;
            }
          }
          for (bits = 0; bits <= MAX_BITS; bits++) {
            bl_count[bits] = 0;
          }
          n = 0;
          while (n <= 143) {
            static_ltree[n * 2 + 1] = 8;
            n++;
            bl_count[8]++;
          }
          while (n <= 255) {
            static_ltree[n * 2 + 1] = 9;
            n++;
            bl_count[9]++;
          }
          while (n <= 279) {
            static_ltree[n * 2 + 1] = 7;
            n++;
            bl_count[7]++;
          }
          while (n <= 287) {
            static_ltree[n * 2 + 1] = 8;
            n++;
            bl_count[8]++;
          }
          gen_codes(static_ltree, L_CODES + 1, bl_count);
          for (n = 0; n < D_CODES; n++) {
            static_dtree[n * 2 + 1] = 5;
            static_dtree[n * 2] = bi_reverse(n, 5);
          }
          static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
          static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
          static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
        }
        function init_block(s) {
          var n;
          for (n = 0; n < L_CODES; n++) {
            s.dyn_ltree[n * 2] = 0;
          }
          for (n = 0; n < D_CODES; n++) {
            s.dyn_dtree[n * 2] = 0;
          }
          for (n = 0; n < BL_CODES; n++) {
            s.bl_tree[n * 2] = 0;
          }
          s.dyn_ltree[END_BLOCK * 2] = 1;
          s.opt_len = s.static_len = 0;
          s.last_lit = s.matches = 0;
        }
        function bi_windup(s) {
          if (s.bi_valid > 8) {
            put_short(s, s.bi_buf);
          } else if (s.bi_valid > 0) {
            s.pending_buf[s.pending++] = s.bi_buf;
          }
          s.bi_buf = 0;
          s.bi_valid = 0;
        }
        function copy_block(s, buf, len, header) {
          bi_windup(s);
          if (header) {
            put_short(s, len);
            put_short(s, ~len);
          }
          utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
          s.pending += len;
        }
        function smaller(tree, n, m, depth) {
          var _n2 = n * 2;
          var _m2 = m * 2;
          return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
        }
        function pqdownheap(s, tree, k) {
          var v = s.heap[k];
          var j = k << 1;
          while (j <= s.heap_len) {
            if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
              j++;
            }
            if (smaller(tree, v, s.heap[j], s.depth)) {
              break;
            }
            s.heap[k] = s.heap[j];
            k = j;
            j <<= 1;
          }
          s.heap[k] = v;
        }
        function compress_block(s, ltree, dtree) {
          var dist;
          var lc;
          var lx = 0;
          var code;
          var extra;
          if (s.last_lit !== 0) {
            do {
              dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
              lc = s.pending_buf[s.l_buf + lx];
              lx++;
              if (dist === 0) {
                send_code(s, lc, ltree);
              } else {
                code = _length_code[lc];
                send_code(s, code + LITERALS + 1, ltree);
                extra = extra_lbits[code];
                if (extra !== 0) {
                  lc -= base_length[code];
                  send_bits(s, lc, extra);
                }
                dist--;
                code = d_code(dist);
                send_code(s, code, dtree);
                extra = extra_dbits[code];
                if (extra !== 0) {
                  dist -= base_dist[code];
                  send_bits(s, dist, extra);
                }
              }
            } while (lx < s.last_lit);
          }
          send_code(s, END_BLOCK, ltree);
        }
        function build_tree(s, desc) {
          var tree = desc.dyn_tree;
          var stree = desc.stat_desc.static_tree;
          var has_stree = desc.stat_desc.has_stree;
          var elems = desc.stat_desc.elems;
          var n, m;
          var max_code = -1;
          var node;
          s.heap_len = 0;
          s.heap_max = HEAP_SIZE;
          for (n = 0; n < elems; n++) {
            if (tree[n * 2] !== 0) {
              s.heap[++s.heap_len] = max_code = n;
              s.depth[n] = 0;
            } else {
              tree[n * 2 + 1] = 0;
            }
          }
          while (s.heap_len < 2) {
            node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
            tree[node * 2] = 1;
            s.depth[node] = 0;
            s.opt_len--;
            if (has_stree) {
              s.static_len -= stree[node * 2 + 1];
            }
          }
          desc.max_code = max_code;
          for (n = s.heap_len >> 1; n >= 1; n--) {
            pqdownheap(s, tree, n);
          }
          node = elems;
          do {
            n = s.heap[1];
            s.heap[1] = s.heap[s.heap_len--];
            pqdownheap(s, tree, 1);
            m = s.heap[1];
            s.heap[--s.heap_max] = n;
            s.heap[--s.heap_max] = m;
            tree[node * 2] = tree[n * 2] + tree[m * 2];
            s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
            tree[n * 2 + 1] = tree[m * 2 + 1] = node;
            s.heap[1] = node++;
            pqdownheap(s, tree, 1);
          } while (s.heap_len >= 2);
          s.heap[--s.heap_max] = s.heap[1];
          gen_bitlen(s, desc);
          gen_codes(tree, max_code, s.bl_count);
        }
        function scan_tree(s, tree, max_code) {
          var n;
          var prevlen = -1;
          var curlen;
          var nextlen = tree[0 * 2 + 1];
          var count = 0;
          var max_count = 7;
          var min_count = 4;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          }
          tree[(max_code + 1) * 2 + 1] = 65535;
          for (n = 0; n <= max_code; n++) {
            curlen = nextlen;
            nextlen = tree[(n + 1) * 2 + 1];
            if (++count < max_count && curlen === nextlen) {
              continue;
            } else if (count < min_count) {
              s.bl_tree[curlen * 2] += count;
            } else if (curlen !== 0) {
              if (curlen !== prevlen) {
                s.bl_tree[curlen * 2]++;
              }
              s.bl_tree[REP_3_6 * 2]++;
            } else if (count <= 10) {
              s.bl_tree[REPZ_3_10 * 2]++;
            } else {
              s.bl_tree[REPZ_11_138 * 2]++;
            }
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
              max_count = 138;
              min_count = 3;
            } else if (curlen === nextlen) {
              max_count = 6;
              min_count = 3;
            } else {
              max_count = 7;
              min_count = 4;
            }
          }
        }
        function send_tree(s, tree, max_code) {
          var n;
          var prevlen = -1;
          var curlen;
          var nextlen = tree[0 * 2 + 1];
          var count = 0;
          var max_count = 7;
          var min_count = 4;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          }
          for (n = 0; n <= max_code; n++) {
            curlen = nextlen;
            nextlen = tree[(n + 1) * 2 + 1];
            if (++count < max_count && curlen === nextlen) {
              continue;
            } else if (count < min_count) {
              do {
                send_code(s, curlen, s.bl_tree);
              } while (--count !== 0);
            } else if (curlen !== 0) {
              if (curlen !== prevlen) {
                send_code(s, curlen, s.bl_tree);
                count--;
              }
              send_code(s, REP_3_6, s.bl_tree);
              send_bits(s, count - 3, 2);
            } else if (count <= 10) {
              send_code(s, REPZ_3_10, s.bl_tree);
              send_bits(s, count - 3, 3);
            } else {
              send_code(s, REPZ_11_138, s.bl_tree);
              send_bits(s, count - 11, 7);
            }
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
              max_count = 138;
              min_count = 3;
            } else if (curlen === nextlen) {
              max_count = 6;
              min_count = 3;
            } else {
              max_count = 7;
              min_count = 4;
            }
          }
        }
        function build_bl_tree(s) {
          var max_blindex;
          scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
          scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
          build_tree(s, s.bl_desc);
          for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
            if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
              break;
            }
          }
          s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
          return max_blindex;
        }
        function send_all_trees(s, lcodes, dcodes, blcodes) {
          var rank;
          send_bits(s, lcodes - 257, 5);
          send_bits(s, dcodes - 1, 5);
          send_bits(s, blcodes - 4, 4);
          for (rank = 0; rank < blcodes; rank++) {
            send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
          }
          send_tree(s, s.dyn_ltree, lcodes - 1);
          send_tree(s, s.dyn_dtree, dcodes - 1);
        }
        function detect_data_type(s) {
          var black_mask = 4093624447;
          var n;
          for (n = 0; n <= 31; n++, black_mask >>>= 1) {
            if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
              return Z_BINARY;
            }
          }
          if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
            return Z_TEXT;
          }
          for (n = 32; n < LITERALS; n++) {
            if (s.dyn_ltree[n * 2] !== 0) {
              return Z_TEXT;
            }
          }
          return Z_BINARY;
        }
        var static_init_done = false;
        function _tr_init(s) {
          if (!static_init_done) {
            tr_static_init();
            static_init_done = true;
          }
          s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
          s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
          s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
          s.bi_buf = 0;
          s.bi_valid = 0;
          init_block(s);
        }
        function _tr_stored_block(s, buf, stored_len, last) {
          send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
          copy_block(s, buf, stored_len, true);
        }
        function _tr_align(s) {
          send_bits(s, STATIC_TREES << 1, 3);
          send_code(s, END_BLOCK, static_ltree);
          bi_flush(s);
        }
        function _tr_flush_block(s, buf, stored_len, last) {
          var opt_lenb, static_lenb;
          var max_blindex = 0;
          if (s.level > 0) {
            if (s.strm.data_type === Z_UNKNOWN) {
              s.strm.data_type = detect_data_type(s);
            }
            build_tree(s, s.l_desc);
            build_tree(s, s.d_desc);
            max_blindex = build_bl_tree(s);
            opt_lenb = s.opt_len + 3 + 7 >>> 3;
            static_lenb = s.static_len + 3 + 7 >>> 3;
            if (static_lenb <= opt_lenb) {
              opt_lenb = static_lenb;
            }
          } else {
            opt_lenb = static_lenb = stored_len + 5;
          }
          if (stored_len + 4 <= opt_lenb && buf !== -1) {
            _tr_stored_block(s, buf, stored_len, last);
          } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
            send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
            compress_block(s, static_ltree, static_dtree);
          } else {
            send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
            send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
            compress_block(s, s.dyn_ltree, s.dyn_dtree);
          }
          init_block(s);
          if (last) {
            bi_windup(s);
          }
        }
        function _tr_tally(s, dist, lc) {
          s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
          s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
          s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
          s.last_lit++;
          if (dist === 0) {
            s.dyn_ltree[lc * 2]++;
          } else {
            s.matches++;
            dist--;
            s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
            s.dyn_dtree[d_code(dist) * 2]++;
          }
          return s.last_lit === s.lit_bufsize - 1;
        }
        exports3._tr_init = _tr_init;
        exports3._tr_stored_block = _tr_stored_block;
        exports3._tr_flush_block = _tr_flush_block;
        exports3._tr_tally = _tr_tally;
        exports3._tr_align = _tr_align;
      }, { "../utils/common": 5 }], 12: [function(require2, module4, exports3) {
        "use strict";
        function ZStream() {
          this.input = null;
          this.next_in = 0;
          this.avail_in = 0;
          this.total_in = 0;
          this.output = null;
          this.next_out = 0;
          this.avail_out = 0;
          this.total_out = 0;
          this.msg = "";
          this.state = null;
          this.data_type = 2;
          this.adler = 0;
        }
        module4.exports = ZStream;
      }, {}] }, {}, [3])(3);
    });
  }
});

// node_modules/plantuml-encoder/dist/plantuml-decoder.js
var require_plantuml_decoder = __commonJS({
  "node_modules/plantuml-encoder/dist/plantuml-decoder.js"(exports, module2) {
    (function(f) {
      if (typeof exports === "object" && typeof module2 !== "undefined") {
        module2.exports = f();
      } else if (typeof define === "function" && define.amd) {
        define([], f);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.plantumlEncoder = f();
      }
    })(function() {
      var define2, module3, exports2;
      return function() {
        function r(e, n, t) {
          function o(i2, f) {
            if (!n[i2]) {
              if (!e[i2]) {
                var c = typeof require == "function" && require;
                if (!f && c)
                  return c(i2, true);
                if (u)
                  return u(i2, true);
                var a = new Error("Cannot find module '" + i2 + "'");
                throw a.code = "MODULE_NOT_FOUND", a;
              }
              var p = n[i2] = { exports: {} };
              e[i2][0].call(p.exports, function(r2) {
                var n2 = e[i2][1][r2];
                return o(n2 || r2);
              }, p, p.exports, r, e, n, t);
            }
            return n[i2].exports;
          }
          for (var u = typeof require == "function" && require, i = 0; i < t.length; i++)
            o(t[i]);
          return o;
        }
        return r;
      }()({ 1: [function(require2, module4, exports3) {
        "use strict";
        var pako = require2("pako/lib/inflate.js");
        module4.exports = function(data) {
          return pako.inflateRaw(data, { to: "string" });
        };
      }, { "pako/lib/inflate.js": 4 }], 2: [function(require2, module4, exports3) {
        "use strict";
        function decode6bit(cc) {
          var c = cc.charCodeAt(0);
          if (cc === "_")
            return 63;
          if (cc === "-")
            return 62;
          if (c >= 97)
            return c - 61;
          if (c >= 65)
            return c - 55;
          if (c >= 48)
            return c - 48;
          return "?";
        }
        function extract3bytes(data) {
          var c1 = decode6bit(data[0]);
          var c2 = decode6bit(data[1]);
          var c3 = decode6bit(data[2]);
          var c4 = decode6bit(data[3]);
          var b1 = c1 << 2 | c2 >> 4 & 63;
          var b2 = c2 << 4 & 240 | c3 >> 2 & 15;
          var b3 = c3 << 6 & 192 | c4 & 63;
          return [b1, b2, b3];
        }
        module4.exports = function(data) {
          var r = "";
          var i = 0;
          for (i = 0; i < data.length; i += 4) {
            var t = extract3bytes(data.substring(i, i + 4));
            r = r + String.fromCharCode(t[0]);
            r = r + String.fromCharCode(t[1]);
            r = r + String.fromCharCode(t[2]);
          }
          return r;
        };
      }, {}], 3: [function(require2, module4, exports3) {
        "use strict";
        var inflate = require2("./inflate");
        var decode64 = require2("./decode64");
        module4.exports.decode = function(encoded) {
          var deflated = decode64(encoded);
          return inflate(deflated);
        };
      }, { "./decode64": 2, "./inflate": 1 }], 4: [function(require2, module4, exports3) {
        "use strict";
        var zlib_inflate = require2("./zlib/inflate");
        var utils = require2("./utils/common");
        var strings = require2("./utils/strings");
        var c = require2("./zlib/constants");
        var msg = require2("./zlib/messages");
        var ZStream = require2("./zlib/zstream");
        var GZheader = require2("./zlib/gzheader");
        var toString = Object.prototype.toString;
        function Inflate(options) {
          if (!(this instanceof Inflate))
            return new Inflate(options);
          this.options = utils.assign({
            chunkSize: 16384,
            windowBits: 0,
            to: ""
          }, options || {});
          var opt = this.options;
          if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
            opt.windowBits = -opt.windowBits;
            if (opt.windowBits === 0) {
              opt.windowBits = -15;
            }
          }
          if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
            opt.windowBits += 32;
          }
          if (opt.windowBits > 15 && opt.windowBits < 48) {
            if ((opt.windowBits & 15) === 0) {
              opt.windowBits |= 15;
            }
          }
          this.err = 0;
          this.msg = "";
          this.ended = false;
          this.chunks = [];
          this.strm = new ZStream();
          this.strm.avail_out = 0;
          var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
          if (status !== c.Z_OK) {
            throw new Error(msg[status]);
          }
          this.header = new GZheader();
          zlib_inflate.inflateGetHeader(this.strm, this.header);
          if (opt.dictionary) {
            if (typeof opt.dictionary === "string") {
              opt.dictionary = strings.string2buf(opt.dictionary);
            } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
              opt.dictionary = new Uint8Array(opt.dictionary);
            }
            if (opt.raw) {
              status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
              if (status !== c.Z_OK) {
                throw new Error(msg[status]);
              }
            }
          }
        }
        Inflate.prototype.push = function(data, mode) {
          var strm = this.strm;
          var chunkSize = this.options.chunkSize;
          var dictionary = this.options.dictionary;
          var status, _mode;
          var next_out_utf8, tail, utf8str;
          var allowBufError = false;
          if (this.ended) {
            return false;
          }
          _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
          if (typeof data === "string") {
            strm.input = strings.binstring2buf(data);
          } else if (toString.call(data) === "[object ArrayBuffer]") {
            strm.input = new Uint8Array(data);
          } else {
            strm.input = data;
          }
          strm.next_in = 0;
          strm.avail_in = strm.input.length;
          do {
            if (strm.avail_out === 0) {
              strm.output = new utils.Buf8(chunkSize);
              strm.next_out = 0;
              strm.avail_out = chunkSize;
            }
            status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
            if (status === c.Z_NEED_DICT && dictionary) {
              status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
            }
            if (status === c.Z_BUF_ERROR && allowBufError === true) {
              status = c.Z_OK;
              allowBufError = false;
            }
            if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
              this.onEnd(status);
              this.ended = true;
              return false;
            }
            if (strm.next_out) {
              if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
                if (this.options.to === "string") {
                  next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                  tail = strm.next_out - next_out_utf8;
                  utf8str = strings.buf2string(strm.output, next_out_utf8);
                  strm.next_out = tail;
                  strm.avail_out = chunkSize - tail;
                  if (tail) {
                    utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
                  }
                  this.onData(utf8str);
                } else {
                  this.onData(utils.shrinkBuf(strm.output, strm.next_out));
                }
              }
            }
            if (strm.avail_in === 0 && strm.avail_out === 0) {
              allowBufError = true;
            }
          } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
          if (status === c.Z_STREAM_END) {
            _mode = c.Z_FINISH;
          }
          if (_mode === c.Z_FINISH) {
            status = zlib_inflate.inflateEnd(this.strm);
            this.onEnd(status);
            this.ended = true;
            return status === c.Z_OK;
          }
          if (_mode === c.Z_SYNC_FLUSH) {
            this.onEnd(c.Z_OK);
            strm.avail_out = 0;
            return true;
          }
          return true;
        };
        Inflate.prototype.onData = function(chunk) {
          this.chunks.push(chunk);
        };
        Inflate.prototype.onEnd = function(status) {
          if (status === c.Z_OK) {
            if (this.options.to === "string") {
              this.result = this.chunks.join("");
            } else {
              this.result = utils.flattenChunks(this.chunks);
            }
          }
          this.chunks = [];
          this.err = status;
          this.msg = this.strm.msg;
        };
        function inflate(input, options) {
          var inflator = new Inflate(options);
          inflator.push(input, true);
          if (inflator.err) {
            throw inflator.msg || msg[inflator.err];
          }
          return inflator.result;
        }
        function inflateRaw(input, options) {
          options = options || {};
          options.raw = true;
          return inflate(input, options);
        }
        exports3.Inflate = Inflate;
        exports3.inflate = inflate;
        exports3.inflateRaw = inflateRaw;
        exports3.ungzip = inflate;
      }, { "./utils/common": 5, "./utils/strings": 6, "./zlib/constants": 8, "./zlib/gzheader": 10, "./zlib/inflate": 12, "./zlib/messages": 14, "./zlib/zstream": 15 }], 5: [function(require2, module4, exports3) {
        "use strict";
        var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
        function _has(obj, key) {
          return Object.prototype.hasOwnProperty.call(obj, key);
        }
        exports3.assign = function(obj) {
          var sources = Array.prototype.slice.call(arguments, 1);
          while (sources.length) {
            var source = sources.shift();
            if (!source) {
              continue;
            }
            if (typeof source !== "object") {
              throw new TypeError(source + "must be non-object");
            }
            for (var p in source) {
              if (_has(source, p)) {
                obj[p] = source[p];
              }
            }
          }
          return obj;
        };
        exports3.shrinkBuf = function(buf, size) {
          if (buf.length === size) {
            return buf;
          }
          if (buf.subarray) {
            return buf.subarray(0, size);
          }
          buf.length = size;
          return buf;
        };
        var fnTyped = {
          arraySet: function(dest, src, src_offs, len, dest_offs) {
            if (src.subarray && dest.subarray) {
              dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
              return;
            }
            for (var i = 0; i < len; i++) {
              dest[dest_offs + i] = src[src_offs + i];
            }
          },
          flattenChunks: function(chunks) {
            var i, l, len, pos, chunk, result;
            len = 0;
            for (i = 0, l = chunks.length; i < l; i++) {
              len += chunks[i].length;
            }
            result = new Uint8Array(len);
            pos = 0;
            for (i = 0, l = chunks.length; i < l; i++) {
              chunk = chunks[i];
              result.set(chunk, pos);
              pos += chunk.length;
            }
            return result;
          }
        };
        var fnUntyped = {
          arraySet: function(dest, src, src_offs, len, dest_offs) {
            for (var i = 0; i < len; i++) {
              dest[dest_offs + i] = src[src_offs + i];
            }
          },
          flattenChunks: function(chunks) {
            return [].concat.apply([], chunks);
          }
        };
        exports3.setTyped = function(on) {
          if (on) {
            exports3.Buf8 = Uint8Array;
            exports3.Buf16 = Uint16Array;
            exports3.Buf32 = Int32Array;
            exports3.assign(exports3, fnTyped);
          } else {
            exports3.Buf8 = Array;
            exports3.Buf16 = Array;
            exports3.Buf32 = Array;
            exports3.assign(exports3, fnUntyped);
          }
        };
        exports3.setTyped(TYPED_OK);
      }, {}], 6: [function(require2, module4, exports3) {
        "use strict";
        var utils = require2("./common");
        var STR_APPLY_OK = true;
        var STR_APPLY_UIA_OK = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (__) {
          STR_APPLY_OK = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (__) {
          STR_APPLY_UIA_OK = false;
        }
        var _utf8len = new utils.Buf8(256);
        for (var q = 0; q < 256; q++) {
          _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
        }
        _utf8len[254] = _utf8len[254] = 1;
        exports3.string2buf = function(str) {
          var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
          for (m_pos = 0; m_pos < str_len; m_pos++) {
            c = str.charCodeAt(m_pos);
            if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
              c2 = str.charCodeAt(m_pos + 1);
              if ((c2 & 64512) === 56320) {
                c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                m_pos++;
              }
            }
            buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
          }
          buf = new utils.Buf8(buf_len);
          for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
            c = str.charCodeAt(m_pos);
            if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
              c2 = str.charCodeAt(m_pos + 1);
              if ((c2 & 64512) === 56320) {
                c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                m_pos++;
              }
            }
            if (c < 128) {
              buf[i++] = c;
            } else if (c < 2048) {
              buf[i++] = 192 | c >>> 6;
              buf[i++] = 128 | c & 63;
            } else if (c < 65536) {
              buf[i++] = 224 | c >>> 12;
              buf[i++] = 128 | c >>> 6 & 63;
              buf[i++] = 128 | c & 63;
            } else {
              buf[i++] = 240 | c >>> 18;
              buf[i++] = 128 | c >>> 12 & 63;
              buf[i++] = 128 | c >>> 6 & 63;
              buf[i++] = 128 | c & 63;
            }
          }
          return buf;
        };
        function buf2binstring(buf, len) {
          if (len < 65534) {
            if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
              return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
            }
          }
          var result = "";
          for (var i = 0; i < len; i++) {
            result += String.fromCharCode(buf[i]);
          }
          return result;
        }
        exports3.buf2binstring = function(buf) {
          return buf2binstring(buf, buf.length);
        };
        exports3.binstring2buf = function(str) {
          var buf = new utils.Buf8(str.length);
          for (var i = 0, len = buf.length; i < len; i++) {
            buf[i] = str.charCodeAt(i);
          }
          return buf;
        };
        exports3.buf2string = function(buf, max) {
          var i, out, c, c_len;
          var len = max || buf.length;
          var utf16buf = new Array(len * 2);
          for (out = 0, i = 0; i < len; ) {
            c = buf[i++];
            if (c < 128) {
              utf16buf[out++] = c;
              continue;
            }
            c_len = _utf8len[c];
            if (c_len > 4) {
              utf16buf[out++] = 65533;
              i += c_len - 1;
              continue;
            }
            c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
            while (c_len > 1 && i < len) {
              c = c << 6 | buf[i++] & 63;
              c_len--;
            }
            if (c_len > 1) {
              utf16buf[out++] = 65533;
              continue;
            }
            if (c < 65536) {
              utf16buf[out++] = c;
            } else {
              c -= 65536;
              utf16buf[out++] = 55296 | c >> 10 & 1023;
              utf16buf[out++] = 56320 | c & 1023;
            }
          }
          return buf2binstring(utf16buf, out);
        };
        exports3.utf8border = function(buf, max) {
          var pos;
          max = max || buf.length;
          if (max > buf.length) {
            max = buf.length;
          }
          pos = max - 1;
          while (pos >= 0 && (buf[pos] & 192) === 128) {
            pos--;
          }
          if (pos < 0) {
            return max;
          }
          if (pos === 0) {
            return max;
          }
          return pos + _utf8len[buf[pos]] > max ? pos : max;
        };
      }, { "./common": 5 }], 7: [function(require2, module4, exports3) {
        "use strict";
        function adler32(adler, buf, len, pos) {
          var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
          while (len !== 0) {
            n = len > 2e3 ? 2e3 : len;
            len -= n;
            do {
              s1 = s1 + buf[pos++] | 0;
              s2 = s2 + s1 | 0;
            } while (--n);
            s1 %= 65521;
            s2 %= 65521;
          }
          return s1 | s2 << 16 | 0;
        }
        module4.exports = adler32;
      }, {}], 8: [function(require2, module4, exports3) {
        "use strict";
        module4.exports = {
          Z_NO_FLUSH: 0,
          Z_PARTIAL_FLUSH: 1,
          Z_SYNC_FLUSH: 2,
          Z_FULL_FLUSH: 3,
          Z_FINISH: 4,
          Z_BLOCK: 5,
          Z_TREES: 6,
          Z_OK: 0,
          Z_STREAM_END: 1,
          Z_NEED_DICT: 2,
          Z_ERRNO: -1,
          Z_STREAM_ERROR: -2,
          Z_DATA_ERROR: -3,
          Z_BUF_ERROR: -5,
          Z_NO_COMPRESSION: 0,
          Z_BEST_SPEED: 1,
          Z_BEST_COMPRESSION: 9,
          Z_DEFAULT_COMPRESSION: -1,
          Z_FILTERED: 1,
          Z_HUFFMAN_ONLY: 2,
          Z_RLE: 3,
          Z_FIXED: 4,
          Z_DEFAULT_STRATEGY: 0,
          Z_BINARY: 0,
          Z_TEXT: 1,
          Z_UNKNOWN: 2,
          Z_DEFLATED: 8
        };
      }, {}], 9: [function(require2, module4, exports3) {
        "use strict";
        function makeTable() {
          var c, table = [];
          for (var n = 0; n < 256; n++) {
            c = n;
            for (var k = 0; k < 8; k++) {
              c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
            }
            table[n] = c;
          }
          return table;
        }
        var crcTable = makeTable();
        function crc32(crc, buf, len, pos) {
          var t = crcTable, end = pos + len;
          crc ^= -1;
          for (var i = pos; i < end; i++) {
            crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
          }
          return crc ^ -1;
        }
        module4.exports = crc32;
      }, {}], 10: [function(require2, module4, exports3) {
        "use strict";
        function GZheader() {
          this.text = 0;
          this.time = 0;
          this.xflags = 0;
          this.os = 0;
          this.extra = null;
          this.extra_len = 0;
          this.name = "";
          this.comment = "";
          this.hcrc = 0;
          this.done = false;
        }
        module4.exports = GZheader;
      }, {}], 11: [function(require2, module4, exports3) {
        "use strict";
        var BAD = 30;
        var TYPE = 12;
        module4.exports = function inflate_fast(strm, start) {
          var state;
          var _in;
          var last;
          var _out;
          var beg;
          var end;
          var dmax;
          var wsize;
          var whave;
          var wnext;
          var s_window;
          var hold;
          var bits;
          var lcode;
          var dcode;
          var lmask;
          var dmask;
          var here;
          var op;
          var len;
          var dist;
          var from;
          var from_source;
          var input, output;
          state = strm.state;
          _in = strm.next_in;
          input = strm.input;
          last = _in + (strm.avail_in - 5);
          _out = strm.next_out;
          output = strm.output;
          beg = _out - (start - strm.avail_out);
          end = _out + (strm.avail_out - 257);
          dmax = state.dmax;
          wsize = state.wsize;
          whave = state.whave;
          wnext = state.wnext;
          s_window = state.window;
          hold = state.hold;
          bits = state.bits;
          lcode = state.lencode;
          dcode = state.distcode;
          lmask = (1 << state.lenbits) - 1;
          dmask = (1 << state.distbits) - 1;
          top:
            do {
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = lcode[hold & lmask];
              dolen:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op === 0) {
                    output[_out++] = here & 65535;
                  } else if (op & 16) {
                    len = here & 65535;
                    op &= 15;
                    if (op) {
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                      len += hold & (1 << op) - 1;
                      hold >>>= op;
                      bits -= op;
                    }
                    if (bits < 15) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                    here = dcode[hold & dmask];
                    dodist:
                      for (; ; ) {
                        op = here >>> 24;
                        hold >>>= op;
                        bits -= op;
                        op = here >>> 16 & 255;
                        if (op & 16) {
                          dist = here & 65535;
                          op &= 15;
                          if (bits < op) {
                            hold += input[_in++] << bits;
                            bits += 8;
                            if (bits < op) {
                              hold += input[_in++] << bits;
                              bits += 8;
                            }
                          }
                          dist += hold & (1 << op) - 1;
                          if (dist > dmax) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                          hold >>>= op;
                          bits -= op;
                          op = _out - beg;
                          if (dist > op) {
                            op = dist - op;
                            if (op > whave) {
                              if (state.sane) {
                                strm.msg = "invalid distance too far back";
                                state.mode = BAD;
                                break top;
                              }
                            }
                            from = 0;
                            from_source = s_window;
                            if (wnext === 0) {
                              from += wsize - op;
                              if (op < len) {
                                len -= op;
                                do {
                                  output[_out++] = s_window[from++];
                                } while (--op);
                                from = _out - dist;
                                from_source = output;
                              }
                            } else if (wnext < op) {
                              from += wsize + wnext - op;
                              op -= wnext;
                              if (op < len) {
                                len -= op;
                                do {
                                  output[_out++] = s_window[from++];
                                } while (--op);
                                from = 0;
                                if (wnext < len) {
                                  op = wnext;
                                  len -= op;
                                  do {
                                    output[_out++] = s_window[from++];
                                  } while (--op);
                                  from = _out - dist;
                                  from_source = output;
                                }
                              }
                            } else {
                              from += wnext - op;
                              if (op < len) {
                                len -= op;
                                do {
                                  output[_out++] = s_window[from++];
                                } while (--op);
                                from = _out - dist;
                                from_source = output;
                              }
                            }
                            while (len > 2) {
                              output[_out++] = from_source[from++];
                              output[_out++] = from_source[from++];
                              output[_out++] = from_source[from++];
                              len -= 3;
                            }
                            if (len) {
                              output[_out++] = from_source[from++];
                              if (len > 1) {
                                output[_out++] = from_source[from++];
                              }
                            }
                          } else {
                            from = _out - dist;
                            do {
                              output[_out++] = output[from++];
                              output[_out++] = output[from++];
                              output[_out++] = output[from++];
                              len -= 3;
                            } while (len > 2);
                            if (len) {
                              output[_out++] = output[from++];
                              if (len > 1) {
                                output[_out++] = output[from++];
                              }
                            }
                          }
                        } else if ((op & 64) === 0) {
                          here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                          continue dodist;
                        } else {
                          strm.msg = "invalid distance code";
                          state.mode = BAD;
                          break top;
                        }
                        break;
                      }
                  } else if ((op & 64) === 0) {
                    here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dolen;
                  } else if (op & 32) {
                    state.mode = TYPE;
                    break top;
                  } else {
                    strm.msg = "invalid literal/length code";
                    state.mode = BAD;
                    break top;
                  }
                  break;
                }
            } while (_in < last && _out < end);
          len = bits >> 3;
          _in -= len;
          bits -= len << 3;
          hold &= (1 << bits) - 1;
          strm.next_in = _in;
          strm.next_out = _out;
          strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
          strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
          state.hold = hold;
          state.bits = bits;
          return;
        };
      }, {}], 12: [function(require2, module4, exports3) {
        "use strict";
        var utils = require2("../utils/common");
        var adler32 = require2("./adler32");
        var crc32 = require2("./crc32");
        var inflate_fast = require2("./inffast");
        var inflate_table = require2("./inftrees");
        var CODES = 0;
        var LENS = 1;
        var DISTS = 2;
        var Z_FINISH = 4;
        var Z_BLOCK = 5;
        var Z_TREES = 6;
        var Z_OK = 0;
        var Z_STREAM_END = 1;
        var Z_NEED_DICT = 2;
        var Z_STREAM_ERROR = -2;
        var Z_DATA_ERROR = -3;
        var Z_MEM_ERROR = -4;
        var Z_BUF_ERROR = -5;
        var Z_DEFLATED = 8;
        var HEAD = 1;
        var FLAGS = 2;
        var TIME = 3;
        var OS = 4;
        var EXLEN = 5;
        var EXTRA = 6;
        var NAME = 7;
        var COMMENT = 8;
        var HCRC = 9;
        var DICTID = 10;
        var DICT = 11;
        var TYPE = 12;
        var TYPEDO = 13;
        var STORED = 14;
        var COPY_ = 15;
        var COPY = 16;
        var TABLE = 17;
        var LENLENS = 18;
        var CODELENS = 19;
        var LEN_ = 20;
        var LEN = 21;
        var LENEXT = 22;
        var DIST = 23;
        var DISTEXT = 24;
        var MATCH = 25;
        var LIT = 26;
        var CHECK = 27;
        var LENGTH = 28;
        var DONE = 29;
        var BAD = 30;
        var MEM = 31;
        var SYNC = 32;
        var ENOUGH_LENS = 852;
        var ENOUGH_DISTS = 592;
        var MAX_WBITS = 15;
        var DEF_WBITS = MAX_WBITS;
        function zswap32(q) {
          return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
        }
        function InflateState() {
          this.mode = 0;
          this.last = false;
          this.wrap = 0;
          this.havedict = false;
          this.flags = 0;
          this.dmax = 0;
          this.check = 0;
          this.total = 0;
          this.head = null;
          this.wbits = 0;
          this.wsize = 0;
          this.whave = 0;
          this.wnext = 0;
          this.window = null;
          this.hold = 0;
          this.bits = 0;
          this.length = 0;
          this.offset = 0;
          this.extra = 0;
          this.lencode = null;
          this.distcode = null;
          this.lenbits = 0;
          this.distbits = 0;
          this.ncode = 0;
          this.nlen = 0;
          this.ndist = 0;
          this.have = 0;
          this.next = null;
          this.lens = new utils.Buf16(320);
          this.work = new utils.Buf16(288);
          this.lendyn = null;
          this.distdyn = null;
          this.sane = 0;
          this.back = 0;
          this.was = 0;
        }
        function inflateResetKeep(strm) {
          var state;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          state = strm.state;
          strm.total_in = strm.total_out = state.total = 0;
          strm.msg = "";
          if (state.wrap) {
            strm.adler = state.wrap & 1;
          }
          state.mode = HEAD;
          state.last = 0;
          state.havedict = 0;
          state.dmax = 32768;
          state.head = null;
          state.hold = 0;
          state.bits = 0;
          state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
          state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
          state.sane = 1;
          state.back = -1;
          return Z_OK;
        }
        function inflateReset(strm) {
          var state;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          state = strm.state;
          state.wsize = 0;
          state.whave = 0;
          state.wnext = 0;
          return inflateResetKeep(strm);
        }
        function inflateReset2(strm, windowBits) {
          var wrap;
          var state;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          state = strm.state;
          if (windowBits < 0) {
            wrap = 0;
            windowBits = -windowBits;
          } else {
            wrap = (windowBits >> 4) + 1;
            if (windowBits < 48) {
              windowBits &= 15;
            }
          }
          if (windowBits && (windowBits < 8 || windowBits > 15)) {
            return Z_STREAM_ERROR;
          }
          if (state.window !== null && state.wbits !== windowBits) {
            state.window = null;
          }
          state.wrap = wrap;
          state.wbits = windowBits;
          return inflateReset(strm);
        }
        function inflateInit2(strm, windowBits) {
          var ret;
          var state;
          if (!strm) {
            return Z_STREAM_ERROR;
          }
          state = new InflateState();
          strm.state = state;
          state.window = null;
          ret = inflateReset2(strm, windowBits);
          if (ret !== Z_OK) {
            strm.state = null;
          }
          return ret;
        }
        function inflateInit(strm) {
          return inflateInit2(strm, DEF_WBITS);
        }
        var virgin = true;
        var lenfix, distfix;
        function fixedtables(state) {
          if (virgin) {
            var sym;
            lenfix = new utils.Buf32(512);
            distfix = new utils.Buf32(32);
            sym = 0;
            while (sym < 144) {
              state.lens[sym++] = 8;
            }
            while (sym < 256) {
              state.lens[sym++] = 9;
            }
            while (sym < 280) {
              state.lens[sym++] = 7;
            }
            while (sym < 288) {
              state.lens[sym++] = 8;
            }
            inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
            sym = 0;
            while (sym < 32) {
              state.lens[sym++] = 5;
            }
            inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
            virgin = false;
          }
          state.lencode = lenfix;
          state.lenbits = 9;
          state.distcode = distfix;
          state.distbits = 5;
        }
        function updatewindow(strm, src, end, copy) {
          var dist;
          var state = strm.state;
          if (state.window === null) {
            state.wsize = 1 << state.wbits;
            state.wnext = 0;
            state.whave = 0;
            state.window = new utils.Buf8(state.wsize);
          }
          if (copy >= state.wsize) {
            utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
            state.wnext = 0;
            state.whave = state.wsize;
          } else {
            dist = state.wsize - state.wnext;
            if (dist > copy) {
              dist = copy;
            }
            utils.arraySet(state.window, src, end - copy, dist, state.wnext);
            copy -= dist;
            if (copy) {
              utils.arraySet(state.window, src, end - copy, copy, 0);
              state.wnext = copy;
              state.whave = state.wsize;
            } else {
              state.wnext += dist;
              if (state.wnext === state.wsize) {
                state.wnext = 0;
              }
              if (state.whave < state.wsize) {
                state.whave += dist;
              }
            }
          }
          return 0;
        }
        function inflate(strm, flush) {
          var state;
          var input, output;
          var next;
          var put;
          var have, left;
          var hold;
          var bits;
          var _in, _out;
          var copy;
          var from;
          var from_source;
          var here = 0;
          var here_bits, here_op, here_val;
          var last_bits, last_op, last_val;
          var len;
          var ret;
          var hbuf = new utils.Buf8(4);
          var opts;
          var n;
          var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
            return Z_STREAM_ERROR;
          }
          state = strm.state;
          if (state.mode === TYPE) {
            state.mode = TYPEDO;
          }
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          _in = have;
          _out = left;
          ret = Z_OK;
          inf_leave:
            for (; ; ) {
              switch (state.mode) {
                case HEAD:
                  if (state.wrap === 0) {
                    state.mode = TYPEDO;
                    break;
                  }
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (state.wrap & 2 && hold === 35615) {
                    state.check = 0;
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                    hold = 0;
                    bits = 0;
                    state.mode = FLAGS;
                    break;
                  }
                  state.flags = 0;
                  if (state.head) {
                    state.head.done = false;
                  }
                  if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                    strm.msg = "incorrect header check";
                    state.mode = BAD;
                    break;
                  }
                  if ((hold & 15) !== Z_DEFLATED) {
                    strm.msg = "unknown compression method";
                    state.mode = BAD;
                    break;
                  }
                  hold >>>= 4;
                  bits -= 4;
                  len = (hold & 15) + 8;
                  if (state.wbits === 0) {
                    state.wbits = len;
                  } else if (len > state.wbits) {
                    strm.msg = "invalid window size";
                    state.mode = BAD;
                    break;
                  }
                  state.dmax = 1 << len;
                  strm.adler = state.check = 1;
                  state.mode = hold & 512 ? DICTID : TYPE;
                  hold = 0;
                  bits = 0;
                  break;
                case FLAGS:
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.flags = hold;
                  if ((state.flags & 255) !== Z_DEFLATED) {
                    strm.msg = "unknown compression method";
                    state.mode = BAD;
                    break;
                  }
                  if (state.flags & 57344) {
                    strm.msg = "unknown header flags set";
                    state.mode = BAD;
                    break;
                  }
                  if (state.head) {
                    state.head.text = hold >> 8 & 1;
                  }
                  if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                  }
                  hold = 0;
                  bits = 0;
                  state.mode = TIME;
                case TIME:
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (state.head) {
                    state.head.time = hold;
                  }
                  if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    hbuf[2] = hold >>> 16 & 255;
                    hbuf[3] = hold >>> 24 & 255;
                    state.check = crc32(state.check, hbuf, 4, 0);
                  }
                  hold = 0;
                  bits = 0;
                  state.mode = OS;
                case OS:
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (state.head) {
                    state.head.xflags = hold & 255;
                    state.head.os = hold >> 8;
                  }
                  if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                  }
                  hold = 0;
                  bits = 0;
                  state.mode = EXLEN;
                case EXLEN:
                  if (state.flags & 1024) {
                    while (bits < 16) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    state.length = hold;
                    if (state.head) {
                      state.head.extra_len = hold;
                    }
                    if (state.flags & 512) {
                      hbuf[0] = hold & 255;
                      hbuf[1] = hold >>> 8 & 255;
                      state.check = crc32(state.check, hbuf, 2, 0);
                    }
                    hold = 0;
                    bits = 0;
                  } else if (state.head) {
                    state.head.extra = null;
                  }
                  state.mode = EXTRA;
                case EXTRA:
                  if (state.flags & 1024) {
                    copy = state.length;
                    if (copy > have) {
                      copy = have;
                    }
                    if (copy) {
                      if (state.head) {
                        len = state.head.extra_len - state.length;
                        if (!state.head.extra) {
                          state.head.extra = new Array(state.head.extra_len);
                        }
                        utils.arraySet(state.head.extra, input, next, copy, len);
                      }
                      if (state.flags & 512) {
                        state.check = crc32(state.check, input, copy, next);
                      }
                      have -= copy;
                      next += copy;
                      state.length -= copy;
                    }
                    if (state.length) {
                      break inf_leave;
                    }
                  }
                  state.length = 0;
                  state.mode = NAME;
                case NAME:
                  if (state.flags & 2048) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    copy = 0;
                    do {
                      len = input[next + copy++];
                      if (state.head && len && state.length < 65536) {
                        state.head.name += String.fromCharCode(len);
                      }
                    } while (len && copy < have);
                    if (state.flags & 512) {
                      state.check = crc32(state.check, input, copy, next);
                    }
                    have -= copy;
                    next += copy;
                    if (len) {
                      break inf_leave;
                    }
                  } else if (state.head) {
                    state.head.name = null;
                  }
                  state.length = 0;
                  state.mode = COMMENT;
                case COMMENT:
                  if (state.flags & 4096) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    copy = 0;
                    do {
                      len = input[next + copy++];
                      if (state.head && len && state.length < 65536) {
                        state.head.comment += String.fromCharCode(len);
                      }
                    } while (len && copy < have);
                    if (state.flags & 512) {
                      state.check = crc32(state.check, input, copy, next);
                    }
                    have -= copy;
                    next += copy;
                    if (len) {
                      break inf_leave;
                    }
                  } else if (state.head) {
                    state.head.comment = null;
                  }
                  state.mode = HCRC;
                case HCRC:
                  if (state.flags & 512) {
                    while (bits < 16) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    if (hold !== (state.check & 65535)) {
                      strm.msg = "header crc mismatch";
                      state.mode = BAD;
                      break;
                    }
                    hold = 0;
                    bits = 0;
                  }
                  if (state.head) {
                    state.head.hcrc = state.flags >> 9 & 1;
                    state.head.done = true;
                  }
                  strm.adler = state.check = 0;
                  state.mode = TYPE;
                  break;
                case DICTID:
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  strm.adler = state.check = zswap32(hold);
                  hold = 0;
                  bits = 0;
                  state.mode = DICT;
                case DICT:
                  if (state.havedict === 0) {
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits;
                    return Z_NEED_DICT;
                  }
                  strm.adler = state.check = 1;
                  state.mode = TYPE;
                case TYPE:
                  if (flush === Z_BLOCK || flush === Z_TREES) {
                    break inf_leave;
                  }
                case TYPEDO:
                  if (state.last) {
                    hold >>>= bits & 7;
                    bits -= bits & 7;
                    state.mode = CHECK;
                    break;
                  }
                  while (bits < 3) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.last = hold & 1;
                  hold >>>= 1;
                  bits -= 1;
                  switch (hold & 3) {
                    case 0:
                      state.mode = STORED;
                      break;
                    case 1:
                      fixedtables(state);
                      state.mode = LEN_;
                      if (flush === Z_TREES) {
                        hold >>>= 2;
                        bits -= 2;
                        break inf_leave;
                      }
                      break;
                    case 2:
                      state.mode = TABLE;
                      break;
                    case 3:
                      strm.msg = "invalid block type";
                      state.mode = BAD;
                  }
                  hold >>>= 2;
                  bits -= 2;
                  break;
                case STORED:
                  hold >>>= bits & 7;
                  bits -= bits & 7;
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                    strm.msg = "invalid stored block lengths";
                    state.mode = BAD;
                    break;
                  }
                  state.length = hold & 65535;
                  hold = 0;
                  bits = 0;
                  state.mode = COPY_;
                  if (flush === Z_TREES) {
                    break inf_leave;
                  }
                case COPY_:
                  state.mode = COPY;
                case COPY:
                  copy = state.length;
                  if (copy) {
                    if (copy > have) {
                      copy = have;
                    }
                    if (copy > left) {
                      copy = left;
                    }
                    if (copy === 0) {
                      break inf_leave;
                    }
                    utils.arraySet(output, input, next, copy, put);
                    have -= copy;
                    next += copy;
                    left -= copy;
                    put += copy;
                    state.length -= copy;
                    break;
                  }
                  state.mode = TYPE;
                  break;
                case TABLE:
                  while (bits < 14) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.nlen = (hold & 31) + 257;
                  hold >>>= 5;
                  bits -= 5;
                  state.ndist = (hold & 31) + 1;
                  hold >>>= 5;
                  bits -= 5;
                  state.ncode = (hold & 15) + 4;
                  hold >>>= 4;
                  bits -= 4;
                  if (state.nlen > 286 || state.ndist > 30) {
                    strm.msg = "too many length or distance symbols";
                    state.mode = BAD;
                    break;
                  }
                  state.have = 0;
                  state.mode = LENLENS;
                case LENLENS:
                  while (state.have < state.ncode) {
                    while (bits < 3) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    state.lens[order[state.have++]] = hold & 7;
                    hold >>>= 3;
                    bits -= 3;
                  }
                  while (state.have < 19) {
                    state.lens[order[state.have++]] = 0;
                  }
                  state.lencode = state.lendyn;
                  state.lenbits = 7;
                  opts = { bits: state.lenbits };
                  ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                  state.lenbits = opts.bits;
                  if (ret) {
                    strm.msg = "invalid code lengths set";
                    state.mode = BAD;
                    break;
                  }
                  state.have = 0;
                  state.mode = CODELENS;
                case CODELENS:
                  while (state.have < state.nlen + state.ndist) {
                    for (; ; ) {
                      here = state.lencode[hold & (1 << state.lenbits) - 1];
                      here_bits = here >>> 24;
                      here_op = here >>> 16 & 255;
                      here_val = here & 65535;
                      if (here_bits <= bits) {
                        break;
                      }
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    if (here_val < 16) {
                      hold >>>= here_bits;
                      bits -= here_bits;
                      state.lens[state.have++] = here_val;
                    } else {
                      if (here_val === 16) {
                        n = here_bits + 2;
                        while (bits < n) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        if (state.have === 0) {
                          strm.msg = "invalid bit length repeat";
                          state.mode = BAD;
                          break;
                        }
                        len = state.lens[state.have - 1];
                        copy = 3 + (hold & 3);
                        hold >>>= 2;
                        bits -= 2;
                      } else if (here_val === 17) {
                        n = here_bits + 3;
                        while (bits < n) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        len = 0;
                        copy = 3 + (hold & 7);
                        hold >>>= 3;
                        bits -= 3;
                      } else {
                        n = here_bits + 7;
                        while (bits < n) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        len = 0;
                        copy = 11 + (hold & 127);
                        hold >>>= 7;
                        bits -= 7;
                      }
                      if (state.have + copy > state.nlen + state.ndist) {
                        strm.msg = "invalid bit length repeat";
                        state.mode = BAD;
                        break;
                      }
                      while (copy--) {
                        state.lens[state.have++] = len;
                      }
                    }
                  }
                  if (state.mode === BAD) {
                    break;
                  }
                  if (state.lens[256] === 0) {
                    strm.msg = "invalid code -- missing end-of-block";
                    state.mode = BAD;
                    break;
                  }
                  state.lenbits = 9;
                  opts = { bits: state.lenbits };
                  ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                  state.lenbits = opts.bits;
                  if (ret) {
                    strm.msg = "invalid literal/lengths set";
                    state.mode = BAD;
                    break;
                  }
                  state.distbits = 6;
                  state.distcode = state.distdyn;
                  opts = { bits: state.distbits };
                  ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                  state.distbits = opts.bits;
                  if (ret) {
                    strm.msg = "invalid distances set";
                    state.mode = BAD;
                    break;
                  }
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    break inf_leave;
                  }
                case LEN_:
                  state.mode = LEN;
                case LEN:
                  if (have >= 6 && left >= 258) {
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits;
                    inflate_fast(strm, _out);
                    put = strm.next_out;
                    output = strm.output;
                    left = strm.avail_out;
                    next = strm.next_in;
                    input = strm.input;
                    have = strm.avail_in;
                    hold = state.hold;
                    bits = state.bits;
                    if (state.mode === TYPE) {
                      state.back = -1;
                    }
                    break;
                  }
                  state.back = 0;
                  for (; ; ) {
                    here = state.lencode[hold & (1 << state.lenbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (here_op && (here_op & 240) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;
                    for (; ; ) {
                      here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                      here_bits = here >>> 24;
                      here_op = here >>> 16 & 255;
                      here_val = here & 65535;
                      if (last_bits + here_bits <= bits) {
                        break;
                      }
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= last_bits;
                    bits -= last_bits;
                    state.back += last_bits;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.back += here_bits;
                  state.length = here_val;
                  if (here_op === 0) {
                    state.mode = LIT;
                    break;
                  }
                  if (here_op & 32) {
                    state.back = -1;
                    state.mode = TYPE;
                    break;
                  }
                  if (here_op & 64) {
                    strm.msg = "invalid literal/length code";
                    state.mode = BAD;
                    break;
                  }
                  state.extra = here_op & 15;
                  state.mode = LENEXT;
                case LENEXT:
                  if (state.extra) {
                    n = state.extra;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    state.length += hold & (1 << state.extra) - 1;
                    hold >>>= state.extra;
                    bits -= state.extra;
                    state.back += state.extra;
                  }
                  state.was = state.length;
                  state.mode = DIST;
                case DIST:
                  for (; ; ) {
                    here = state.distcode[hold & (1 << state.distbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if ((here_op & 240) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;
                    for (; ; ) {
                      here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                      here_bits = here >>> 24;
                      here_op = here >>> 16 & 255;
                      here_val = here & 65535;
                      if (last_bits + here_bits <= bits) {
                        break;
                      }
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= last_bits;
                    bits -= last_bits;
                    state.back += last_bits;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.back += here_bits;
                  if (here_op & 64) {
                    strm.msg = "invalid distance code";
                    state.mode = BAD;
                    break;
                  }
                  state.offset = here_val;
                  state.extra = here_op & 15;
                  state.mode = DISTEXT;
                case DISTEXT:
                  if (state.extra) {
                    n = state.extra;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    state.offset += hold & (1 << state.extra) - 1;
                    hold >>>= state.extra;
                    bits -= state.extra;
                    state.back += state.extra;
                  }
                  if (state.offset > state.dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                  state.mode = MATCH;
                case MATCH:
                  if (left === 0) {
                    break inf_leave;
                  }
                  copy = _out - left;
                  if (state.offset > copy) {
                    copy = state.offset - copy;
                    if (copy > state.whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break;
                      }
                    }
                    if (copy > state.wnext) {
                      copy -= state.wnext;
                      from = state.wsize - copy;
                    } else {
                      from = state.wnext - copy;
                    }
                    if (copy > state.length) {
                      copy = state.length;
                    }
                    from_source = state.window;
                  } else {
                    from_source = output;
                    from = put - state.offset;
                    copy = state.length;
                  }
                  if (copy > left) {
                    copy = left;
                  }
                  left -= copy;
                  state.length -= copy;
                  do {
                    output[put++] = from_source[from++];
                  } while (--copy);
                  if (state.length === 0) {
                    state.mode = LEN;
                  }
                  break;
                case LIT:
                  if (left === 0) {
                    break inf_leave;
                  }
                  output[put++] = state.length;
                  left--;
                  state.mode = LEN;
                  break;
                case CHECK:
                  if (state.wrap) {
                    while (bits < 32) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold |= input[next++] << bits;
                      bits += 8;
                    }
                    _out -= left;
                    strm.total_out += _out;
                    state.total += _out;
                    if (_out) {
                      strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                    }
                    _out = left;
                    if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                      strm.msg = "incorrect data check";
                      state.mode = BAD;
                      break;
                    }
                    hold = 0;
                    bits = 0;
                  }
                  state.mode = LENGTH;
                case LENGTH:
                  if (state.wrap && state.flags) {
                    while (bits < 32) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    if (hold !== (state.total & 4294967295)) {
                      strm.msg = "incorrect length check";
                      state.mode = BAD;
                      break;
                    }
                    hold = 0;
                    bits = 0;
                  }
                  state.mode = DONE;
                case DONE:
                  ret = Z_STREAM_END;
                  break inf_leave;
                case BAD:
                  ret = Z_DATA_ERROR;
                  break inf_leave;
                case MEM:
                  return Z_MEM_ERROR;
                case SYNC:
                default:
                  return Z_STREAM_ERROR;
              }
            }
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
            if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
              state.mode = MEM;
              return Z_MEM_ERROR;
            }
          }
          _in -= strm.avail_in;
          _out -= strm.avail_out;
          strm.total_in += _in;
          strm.total_out += _out;
          state.total += _out;
          if (state.wrap && _out) {
            strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
          }
          strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
          if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
            ret = Z_BUF_ERROR;
          }
          return ret;
        }
        function inflateEnd(strm) {
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          var state = strm.state;
          if (state.window) {
            state.window = null;
          }
          strm.state = null;
          return Z_OK;
        }
        function inflateGetHeader(strm, head) {
          var state;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          state = strm.state;
          if ((state.wrap & 2) === 0) {
            return Z_STREAM_ERROR;
          }
          state.head = head;
          head.done = false;
          return Z_OK;
        }
        function inflateSetDictionary(strm, dictionary) {
          var dictLength = dictionary.length;
          var state;
          var dictid;
          var ret;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          state = strm.state;
          if (state.wrap !== 0 && state.mode !== DICT) {
            return Z_STREAM_ERROR;
          }
          if (state.mode === DICT) {
            dictid = 1;
            dictid = adler32(dictid, dictionary, dictLength, 0);
            if (dictid !== state.check) {
              return Z_DATA_ERROR;
            }
          }
          ret = updatewindow(strm, dictionary, dictLength, dictLength);
          if (ret) {
            state.mode = MEM;
            return Z_MEM_ERROR;
          }
          state.havedict = 1;
          return Z_OK;
        }
        exports3.inflateReset = inflateReset;
        exports3.inflateReset2 = inflateReset2;
        exports3.inflateResetKeep = inflateResetKeep;
        exports3.inflateInit = inflateInit;
        exports3.inflateInit2 = inflateInit2;
        exports3.inflate = inflate;
        exports3.inflateEnd = inflateEnd;
        exports3.inflateGetHeader = inflateGetHeader;
        exports3.inflateSetDictionary = inflateSetDictionary;
        exports3.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 5, "./adler32": 7, "./crc32": 9, "./inffast": 11, "./inftrees": 13 }], 13: [function(require2, module4, exports3) {
        "use strict";
        var utils = require2("../utils/common");
        var MAXBITS = 15;
        var ENOUGH_LENS = 852;
        var ENOUGH_DISTS = 592;
        var CODES = 0;
        var LENS = 1;
        var DISTS = 2;
        var lbase = [
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          13,
          15,
          17,
          19,
          23,
          27,
          31,
          35,
          43,
          51,
          59,
          67,
          83,
          99,
          115,
          131,
          163,
          195,
          227,
          258,
          0,
          0
        ];
        var lext = [
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          17,
          17,
          17,
          17,
          18,
          18,
          18,
          18,
          19,
          19,
          19,
          19,
          20,
          20,
          20,
          20,
          21,
          21,
          21,
          21,
          16,
          72,
          78
        ];
        var dbase = [
          1,
          2,
          3,
          4,
          5,
          7,
          9,
          13,
          17,
          25,
          33,
          49,
          65,
          97,
          129,
          193,
          257,
          385,
          513,
          769,
          1025,
          1537,
          2049,
          3073,
          4097,
          6145,
          8193,
          12289,
          16385,
          24577,
          0,
          0
        ];
        var dext = [
          16,
          16,
          16,
          16,
          17,
          17,
          18,
          18,
          19,
          19,
          20,
          20,
          21,
          21,
          22,
          22,
          23,
          23,
          24,
          24,
          25,
          25,
          26,
          26,
          27,
          27,
          28,
          28,
          29,
          29,
          64,
          64
        ];
        module4.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
          var bits = opts.bits;
          var len = 0;
          var sym = 0;
          var min = 0, max = 0;
          var root = 0;
          var curr = 0;
          var drop = 0;
          var left = 0;
          var used = 0;
          var huff = 0;
          var incr;
          var fill;
          var low;
          var mask;
          var next;
          var base = null;
          var base_index = 0;
          var end;
          var count = new utils.Buf16(MAXBITS + 1);
          var offs = new utils.Buf16(MAXBITS + 1);
          var extra = null;
          var extra_index = 0;
          var here_bits, here_op, here_val;
          for (len = 0; len <= MAXBITS; len++) {
            count[len] = 0;
          }
          for (sym = 0; sym < codes; sym++) {
            count[lens[lens_index + sym]]++;
          }
          root = bits;
          for (max = MAXBITS; max >= 1; max--) {
            if (count[max] !== 0) {
              break;
            }
          }
          if (root > max) {
            root = max;
          }
          if (max === 0) {
            table[table_index++] = 1 << 24 | 64 << 16 | 0;
            table[table_index++] = 1 << 24 | 64 << 16 | 0;
            opts.bits = 1;
            return 0;
          }
          for (min = 1; min < max; min++) {
            if (count[min] !== 0) {
              break;
            }
          }
          if (root < min) {
            root = min;
          }
          left = 1;
          for (len = 1; len <= MAXBITS; len++) {
            left <<= 1;
            left -= count[len];
            if (left < 0) {
              return -1;
            }
          }
          if (left > 0 && (type === CODES || max !== 1)) {
            return -1;
          }
          offs[1] = 0;
          for (len = 1; len < MAXBITS; len++) {
            offs[len + 1] = offs[len] + count[len];
          }
          for (sym = 0; sym < codes; sym++) {
            if (lens[lens_index + sym] !== 0) {
              work[offs[lens[lens_index + sym]]++] = sym;
            }
          }
          if (type === CODES) {
            base = extra = work;
            end = 19;
          } else if (type === LENS) {
            base = lbase;
            base_index -= 257;
            extra = lext;
            extra_index -= 257;
            end = 256;
          } else {
            base = dbase;
            extra = dext;
            end = -1;
          }
          huff = 0;
          sym = 0;
          len = min;
          next = table_index;
          curr = root;
          drop = 0;
          low = -1;
          used = 1 << root;
          mask = used - 1;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          for (; ; ) {
            here_bits = len - drop;
            if (work[sym] < end) {
              here_op = 0;
              here_val = work[sym];
            } else if (work[sym] > end) {
              here_op = extra[extra_index + work[sym]];
              here_val = base[base_index + work[sym]];
            } else {
              here_op = 32 + 64;
              here_val = 0;
            }
            incr = 1 << len - drop;
            fill = 1 << curr;
            min = fill;
            do {
              fill -= incr;
              table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
            } while (fill !== 0);
            incr = 1 << len - 1;
            while (huff & incr) {
              incr >>= 1;
            }
            if (incr !== 0) {
              huff &= incr - 1;
              huff += incr;
            } else {
              huff = 0;
            }
            sym++;
            if (--count[len] === 0) {
              if (len === max) {
                break;
              }
              len = lens[lens_index + work[sym]];
            }
            if (len > root && (huff & mask) !== low) {
              if (drop === 0) {
                drop = root;
              }
              next += min;
              curr = len - drop;
              left = 1 << curr;
              while (curr + drop < max) {
                left -= count[curr + drop];
                if (left <= 0) {
                  break;
                }
                curr++;
                left <<= 1;
              }
              used += 1 << curr;
              if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
                return 1;
              }
              low = huff & mask;
              table[low] = root << 24 | curr << 16 | next - table_index | 0;
            }
          }
          if (huff !== 0) {
            table[next + huff] = len - drop << 24 | 64 << 16 | 0;
          }
          opts.bits = root;
          return 0;
        };
      }, { "../utils/common": 5 }], 14: [function(require2, module4, exports3) {
        "use strict";
        module4.exports = {
          2: "need dictionary",
          1: "stream end",
          0: "",
          "-1": "file error",
          "-2": "stream error",
          "-3": "data error",
          "-4": "insufficient memory",
          "-5": "buffer error",
          "-6": "incompatible version"
        };
      }, {}], 15: [function(require2, module4, exports3) {
        "use strict";
        function ZStream() {
          this.input = null;
          this.next_in = 0;
          this.avail_in = 0;
          this.total_in = 0;
          this.output = null;
          this.next_out = 0;
          this.avail_out = 0;
          this.total_out = 0;
          this.msg = "";
          this.state = null;
          this.data_type = 2;
          this.adler = 0;
        }
        module4.exports = ZStream;
      }, {}] }, {}, [3])(3);
    });
  }
});

// node_modules/plantuml-encoder/browser-index.js
var require_browser_index = __commonJS({
  "node_modules/plantuml-encoder/browser-index.js"(exports, module2) {
    module2.exports = {
      encode: require_plantuml_encoder().encode,
      decode: require_plantuml_decoder().decode
    };
  }
});

// node_modules/localforage/dist/localforage.js
var require_localforage = __commonJS({
  "node_modules/localforage/dist/localforage.js"(exports, module2) {
    (function(f) {
      if (typeof exports === "object" && typeof module2 !== "undefined") {
        module2.exports = f();
      } else if (typeof define === "function" && define.amd) {
        define([], f);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.localforage = f();
      }
    })(function() {
      var define2, module3, exports2;
      return function e(t, n, r) {
        function s(o2, u) {
          if (!n[o2]) {
            if (!t[o2]) {
              var a = typeof require == "function" && require;
              if (!u && a)
                return a(o2, true);
              if (i)
                return i(o2, true);
              var f = new Error("Cannot find module '" + o2 + "'");
              throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o2] = { exports: {} };
            t[o2][0].call(l.exports, function(e2) {
              var n2 = t[o2][1][e2];
              return s(n2 ? n2 : e2);
            }, l, l.exports, e, t, n, r);
          }
          return n[o2].exports;
        }
        var i = typeof require == "function" && require;
        for (var o = 0; o < r.length; o++)
          s(r[o]);
        return s;
      }({ 1: [function(_dereq_, module4, exports3) {
        (function(global2) {
          "use strict";
          var Mutation = global2.MutationObserver || global2.WebKitMutationObserver;
          var scheduleDrain;
          {
            if (Mutation) {
              var called = 0;
              var observer = new Mutation(nextTick);
              var element = global2.document.createTextNode("");
              observer.observe(element, {
                characterData: true
              });
              scheduleDrain = function() {
                element.data = called = ++called % 2;
              };
            } else if (!global2.setImmediate && typeof global2.MessageChannel !== "undefined") {
              var channel = new global2.MessageChannel();
              channel.port1.onmessage = nextTick;
              scheduleDrain = function() {
                channel.port2.postMessage(0);
              };
            } else if ("document" in global2 && "onreadystatechange" in global2.document.createElement("script")) {
              scheduleDrain = function() {
                var scriptEl = global2.document.createElement("script");
                scriptEl.onreadystatechange = function() {
                  nextTick();
                  scriptEl.onreadystatechange = null;
                  scriptEl.parentNode.removeChild(scriptEl);
                  scriptEl = null;
                };
                global2.document.documentElement.appendChild(scriptEl);
              };
            } else {
              scheduleDrain = function() {
                setTimeout(nextTick, 0);
              };
            }
          }
          var draining;
          var queue = [];
          function nextTick() {
            draining = true;
            var i, oldQueue;
            var len = queue.length;
            while (len) {
              oldQueue = queue;
              queue = [];
              i = -1;
              while (++i < len) {
                oldQueue[i]();
              }
              len = queue.length;
            }
            draining = false;
          }
          module4.exports = immediate;
          function immediate(task) {
            if (queue.push(task) === 1 && !draining) {
              scheduleDrain();
            }
          }
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 2: [function(_dereq_, module4, exports3) {
        "use strict";
        var immediate = _dereq_(1);
        function INTERNAL() {
        }
        var handlers = {};
        var REJECTED = ["REJECTED"];
        var FULFILLED = ["FULFILLED"];
        var PENDING = ["PENDING"];
        module4.exports = Promise2;
        function Promise2(resolver) {
          if (typeof resolver !== "function") {
            throw new TypeError("resolver must be a function");
          }
          this.state = PENDING;
          this.queue = [];
          this.outcome = void 0;
          if (resolver !== INTERNAL) {
            safelyResolveThenable(this, resolver);
          }
        }
        Promise2.prototype["catch"] = function(onRejected) {
          return this.then(null, onRejected);
        };
        Promise2.prototype.then = function(onFulfilled, onRejected) {
          if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
            return this;
          }
          var promise = new this.constructor(INTERNAL);
          if (this.state !== PENDING) {
            var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
            unwrap(promise, resolver, this.outcome);
          } else {
            this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
          }
          return promise;
        };
        function QueueItem(promise, onFulfilled, onRejected) {
          this.promise = promise;
          if (typeof onFulfilled === "function") {
            this.onFulfilled = onFulfilled;
            this.callFulfilled = this.otherCallFulfilled;
          }
          if (typeof onRejected === "function") {
            this.onRejected = onRejected;
            this.callRejected = this.otherCallRejected;
          }
        }
        QueueItem.prototype.callFulfilled = function(value) {
          handlers.resolve(this.promise, value);
        };
        QueueItem.prototype.otherCallFulfilled = function(value) {
          unwrap(this.promise, this.onFulfilled, value);
        };
        QueueItem.prototype.callRejected = function(value) {
          handlers.reject(this.promise, value);
        };
        QueueItem.prototype.otherCallRejected = function(value) {
          unwrap(this.promise, this.onRejected, value);
        };
        function unwrap(promise, func, value) {
          immediate(function() {
            var returnValue;
            try {
              returnValue = func(value);
            } catch (e) {
              return handlers.reject(promise, e);
            }
            if (returnValue === promise) {
              handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
            } else {
              handlers.resolve(promise, returnValue);
            }
          });
        }
        handlers.resolve = function(self2, value) {
          var result = tryCatch(getThen, value);
          if (result.status === "error") {
            return handlers.reject(self2, result.value);
          }
          var thenable = result.value;
          if (thenable) {
            safelyResolveThenable(self2, thenable);
          } else {
            self2.state = FULFILLED;
            self2.outcome = value;
            var i = -1;
            var len = self2.queue.length;
            while (++i < len) {
              self2.queue[i].callFulfilled(value);
            }
          }
          return self2;
        };
        handlers.reject = function(self2, error) {
          self2.state = REJECTED;
          self2.outcome = error;
          var i = -1;
          var len = self2.queue.length;
          while (++i < len) {
            self2.queue[i].callRejected(error);
          }
          return self2;
        };
        function getThen(obj) {
          var then = obj && obj.then;
          if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
            return function appyThen() {
              then.apply(obj, arguments);
            };
          }
        }
        function safelyResolveThenable(self2, thenable) {
          var called = false;
          function onError(value) {
            if (called) {
              return;
            }
            called = true;
            handlers.reject(self2, value);
          }
          function onSuccess(value) {
            if (called) {
              return;
            }
            called = true;
            handlers.resolve(self2, value);
          }
          function tryToUnwrap() {
            thenable(onSuccess, onError);
          }
          var result = tryCatch(tryToUnwrap);
          if (result.status === "error") {
            onError(result.value);
          }
        }
        function tryCatch(func, value) {
          var out = {};
          try {
            out.value = func(value);
            out.status = "success";
          } catch (e) {
            out.status = "error";
            out.value = e;
          }
          return out;
        }
        Promise2.resolve = resolve;
        function resolve(value) {
          if (value instanceof this) {
            return value;
          }
          return handlers.resolve(new this(INTERNAL), value);
        }
        Promise2.reject = reject;
        function reject(reason) {
          var promise = new this(INTERNAL);
          return handlers.reject(promise, reason);
        }
        Promise2.all = all;
        function all(iterable) {
          var self2 = this;
          if (Object.prototype.toString.call(iterable) !== "[object Array]") {
            return this.reject(new TypeError("must be an array"));
          }
          var len = iterable.length;
          var called = false;
          if (!len) {
            return this.resolve([]);
          }
          var values = new Array(len);
          var resolved = 0;
          var i = -1;
          var promise = new this(INTERNAL);
          while (++i < len) {
            allResolver(iterable[i], i);
          }
          return promise;
          function allResolver(value, i2) {
            self2.resolve(value).then(resolveFromAll, function(error) {
              if (!called) {
                called = true;
                handlers.reject(promise, error);
              }
            });
            function resolveFromAll(outValue) {
              values[i2] = outValue;
              if (++resolved === len && !called) {
                called = true;
                handlers.resolve(promise, values);
              }
            }
          }
        }
        Promise2.race = race;
        function race(iterable) {
          var self2 = this;
          if (Object.prototype.toString.call(iterable) !== "[object Array]") {
            return this.reject(new TypeError("must be an array"));
          }
          var len = iterable.length;
          var called = false;
          if (!len) {
            return this.resolve([]);
          }
          var i = -1;
          var promise = new this(INTERNAL);
          while (++i < len) {
            resolver(iterable[i]);
          }
          return promise;
          function resolver(value) {
            self2.resolve(value).then(function(response) {
              if (!called) {
                called = true;
                handlers.resolve(promise, response);
              }
            }, function(error) {
              if (!called) {
                called = true;
                handlers.reject(promise, error);
              }
            });
          }
        }
      }, { "1": 1 }], 3: [function(_dereq_, module4, exports3) {
        (function(global2) {
          "use strict";
          if (typeof global2.Promise !== "function") {
            global2.Promise = _dereq_(2);
          }
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "2": 2 }], 4: [function(_dereq_, module4, exports3) {
        "use strict";
        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
          return typeof obj;
        } : function(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function getIDB() {
          try {
            if (typeof indexedDB !== "undefined") {
              return indexedDB;
            }
            if (typeof webkitIndexedDB !== "undefined") {
              return webkitIndexedDB;
            }
            if (typeof mozIndexedDB !== "undefined") {
              return mozIndexedDB;
            }
            if (typeof OIndexedDB !== "undefined") {
              return OIndexedDB;
            }
            if (typeof msIndexedDB !== "undefined") {
              return msIndexedDB;
            }
          } catch (e) {
            return;
          }
        }
        var idb = getIDB();
        function isIndexedDBValid() {
          try {
            if (!idb || !idb.open) {
              return false;
            }
            var isSafari = typeof openDatabase !== "undefined" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);
            var hasFetch = typeof fetch === "function" && fetch.toString().indexOf("[native code") !== -1;
            return (!isSafari || hasFetch) && typeof indexedDB !== "undefined" && typeof IDBKeyRange !== "undefined";
          } catch (e) {
            return false;
          }
        }
        function createBlob(parts, properties) {
          parts = parts || [];
          properties = properties || {};
          try {
            return new Blob(parts, properties);
          } catch (e) {
            if (e.name !== "TypeError") {
              throw e;
            }
            var Builder = typeof BlobBuilder !== "undefined" ? BlobBuilder : typeof MSBlobBuilder !== "undefined" ? MSBlobBuilder : typeof MozBlobBuilder !== "undefined" ? MozBlobBuilder : WebKitBlobBuilder;
            var builder = new Builder();
            for (var i = 0; i < parts.length; i += 1) {
              builder.append(parts[i]);
            }
            return builder.getBlob(properties.type);
          }
        }
        if (typeof Promise === "undefined") {
          _dereq_(3);
        }
        var Promise$1 = Promise;
        function executeCallback(promise, callback) {
          if (callback) {
            promise.then(function(result) {
              callback(null, result);
            }, function(error) {
              callback(error);
            });
          }
        }
        function executeTwoCallbacks(promise, callback, errorCallback) {
          if (typeof callback === "function") {
            promise.then(callback);
          }
          if (typeof errorCallback === "function") {
            promise["catch"](errorCallback);
          }
        }
        function normalizeKey(key2) {
          if (typeof key2 !== "string") {
            console.warn(key2 + " used as a key, but it is not a string.");
            key2 = String(key2);
          }
          return key2;
        }
        function getCallback() {
          if (arguments.length && typeof arguments[arguments.length - 1] === "function") {
            return arguments[arguments.length - 1];
          }
        }
        var DETECT_BLOB_SUPPORT_STORE = "local-forage-detect-blob-support";
        var supportsBlobs = void 0;
        var dbContexts = {};
        var toString = Object.prototype.toString;
        var READ_ONLY = "readonly";
        var READ_WRITE = "readwrite";
        function _binStringToArrayBuffer(bin) {
          var length2 = bin.length;
          var buf = new ArrayBuffer(length2);
          var arr = new Uint8Array(buf);
          for (var i = 0; i < length2; i++) {
            arr[i] = bin.charCodeAt(i);
          }
          return buf;
        }
        function _checkBlobSupportWithoutCaching(idb2) {
          return new Promise$1(function(resolve) {
            var txn = idb2.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
            var blob = createBlob([""]);
            txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, "key");
            txn.onabort = function(e) {
              e.preventDefault();
              e.stopPropagation();
              resolve(false);
            };
            txn.oncomplete = function() {
              var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
              var matchedEdge = navigator.userAgent.match(/Edge\//);
              resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
            };
          })["catch"](function() {
            return false;
          });
        }
        function _checkBlobSupport(idb2) {
          if (typeof supportsBlobs === "boolean") {
            return Promise$1.resolve(supportsBlobs);
          }
          return _checkBlobSupportWithoutCaching(idb2).then(function(value) {
            supportsBlobs = value;
            return supportsBlobs;
          });
        }
        function _deferReadiness(dbInfo) {
          var dbContext = dbContexts[dbInfo.name];
          var deferredOperation = {};
          deferredOperation.promise = new Promise$1(function(resolve, reject) {
            deferredOperation.resolve = resolve;
            deferredOperation.reject = reject;
          });
          dbContext.deferredOperations.push(deferredOperation);
          if (!dbContext.dbReady) {
            dbContext.dbReady = deferredOperation.promise;
          } else {
            dbContext.dbReady = dbContext.dbReady.then(function() {
              return deferredOperation.promise;
            });
          }
        }
        function _advanceReadiness(dbInfo) {
          var dbContext = dbContexts[dbInfo.name];
          var deferredOperation = dbContext.deferredOperations.pop();
          if (deferredOperation) {
            deferredOperation.resolve();
            return deferredOperation.promise;
          }
        }
        function _rejectReadiness(dbInfo, err) {
          var dbContext = dbContexts[dbInfo.name];
          var deferredOperation = dbContext.deferredOperations.pop();
          if (deferredOperation) {
            deferredOperation.reject(err);
            return deferredOperation.promise;
          }
        }
        function _getConnection(dbInfo, upgradeNeeded) {
          return new Promise$1(function(resolve, reject) {
            dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();
            if (dbInfo.db) {
              if (upgradeNeeded) {
                _deferReadiness(dbInfo);
                dbInfo.db.close();
              } else {
                return resolve(dbInfo.db);
              }
            }
            var dbArgs = [dbInfo.name];
            if (upgradeNeeded) {
              dbArgs.push(dbInfo.version);
            }
            var openreq = idb.open.apply(idb, dbArgs);
            if (upgradeNeeded) {
              openreq.onupgradeneeded = function(e) {
                var db = openreq.result;
                try {
                  db.createObjectStore(dbInfo.storeName);
                  if (e.oldVersion <= 1) {
                    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                  }
                } catch (ex) {
                  if (ex.name === "ConstraintError") {
                    console.warn('The database "' + dbInfo.name + '" has been upgraded from version ' + e.oldVersion + " to version " + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                  } else {
                    throw ex;
                  }
                }
              };
            }
            openreq.onerror = function(e) {
              e.preventDefault();
              reject(openreq.error);
            };
            openreq.onsuccess = function() {
              var db = openreq.result;
              db.onversionchange = function(e) {
                e.target.close();
              };
              resolve(db);
              _advanceReadiness(dbInfo);
            };
          });
        }
        function _getOriginalConnection(dbInfo) {
          return _getConnection(dbInfo, false);
        }
        function _getUpgradedConnection(dbInfo) {
          return _getConnection(dbInfo, true);
        }
        function _isUpgradeNeeded(dbInfo, defaultVersion) {
          if (!dbInfo.db) {
            return true;
          }
          var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
          var isDowngrade = dbInfo.version < dbInfo.db.version;
          var isUpgrade = dbInfo.version > dbInfo.db.version;
          if (isDowngrade) {
            if (dbInfo.version !== defaultVersion) {
              console.warn('The database "' + dbInfo.name + `" can't be downgraded from version ` + dbInfo.db.version + " to version " + dbInfo.version + ".");
            }
            dbInfo.version = dbInfo.db.version;
          }
          if (isUpgrade || isNewStore) {
            if (isNewStore) {
              var incVersion = dbInfo.db.version + 1;
              if (incVersion > dbInfo.version) {
                dbInfo.version = incVersion;
              }
            }
            return true;
          }
          return false;
        }
        function _encodeBlob(blob) {
          return new Promise$1(function(resolve, reject) {
            var reader = new FileReader();
            reader.onerror = reject;
            reader.onloadend = function(e) {
              var base64 = btoa(e.target.result || "");
              resolve({
                __local_forage_encoded_blob: true,
                data: base64,
                type: blob.type
              });
            };
            reader.readAsBinaryString(blob);
          });
        }
        function _decodeBlob(encodedBlob) {
          var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
          return createBlob([arrayBuff], { type: encodedBlob.type });
        }
        function _isEncodedBlob(value) {
          return value && value.__local_forage_encoded_blob;
        }
        function _fullyReady(callback) {
          var self2 = this;
          var promise = self2._initReady().then(function() {
            var dbContext = dbContexts[self2._dbInfo.name];
            if (dbContext && dbContext.dbReady) {
              return dbContext.dbReady;
            }
          });
          executeTwoCallbacks(promise, callback, callback);
          return promise;
        }
        function _tryReconnect(dbInfo) {
          _deferReadiness(dbInfo);
          var dbContext = dbContexts[dbInfo.name];
          var forages = dbContext.forages;
          for (var i = 0; i < forages.length; i++) {
            var forage = forages[i];
            if (forage._dbInfo.db) {
              forage._dbInfo.db.close();
              forage._dbInfo.db = null;
            }
          }
          dbInfo.db = null;
          return _getOriginalConnection(dbInfo).then(function(db) {
            dbInfo.db = db;
            if (_isUpgradeNeeded(dbInfo)) {
              return _getUpgradedConnection(dbInfo);
            }
            return db;
          }).then(function(db) {
            dbInfo.db = dbContext.db = db;
            for (var i2 = 0; i2 < forages.length; i2++) {
              forages[i2]._dbInfo.db = db;
            }
          })["catch"](function(err) {
            _rejectReadiness(dbInfo, err);
            throw err;
          });
        }
        function createTransaction(dbInfo, mode, callback, retries) {
          if (retries === void 0) {
            retries = 1;
          }
          try {
            var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
            callback(null, tx);
          } catch (err) {
            if (retries > 0 && (!dbInfo.db || err.name === "InvalidStateError" || err.name === "NotFoundError")) {
              return Promise$1.resolve().then(function() {
                if (!dbInfo.db || err.name === "NotFoundError" && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                  if (dbInfo.db) {
                    dbInfo.version = dbInfo.db.version + 1;
                  }
                  return _getUpgradedConnection(dbInfo);
                }
              }).then(function() {
                return _tryReconnect(dbInfo).then(function() {
                  createTransaction(dbInfo, mode, callback, retries - 1);
                });
              })["catch"](callback);
            }
            callback(err);
          }
        }
        function createDbContext() {
          return {
            forages: [],
            db: null,
            dbReady: null,
            deferredOperations: []
          };
        }
        function _initStorage(options) {
          var self2 = this;
          var dbInfo = {
            db: null
          };
          if (options) {
            for (var i in options) {
              dbInfo[i] = options[i];
            }
          }
          var dbContext = dbContexts[dbInfo.name];
          if (!dbContext) {
            dbContext = createDbContext();
            dbContexts[dbInfo.name] = dbContext;
          }
          dbContext.forages.push(self2);
          if (!self2._initReady) {
            self2._initReady = self2.ready;
            self2.ready = _fullyReady;
          }
          var initPromises = [];
          function ignoreErrors() {
            return Promise$1.resolve();
          }
          for (var j = 0; j < dbContext.forages.length; j++) {
            var forage = dbContext.forages[j];
            if (forage !== self2) {
              initPromises.push(forage._initReady()["catch"](ignoreErrors));
            }
          }
          var forages = dbContext.forages.slice(0);
          return Promise$1.all(initPromises).then(function() {
            dbInfo.db = dbContext.db;
            return _getOriginalConnection(dbInfo);
          }).then(function(db) {
            dbInfo.db = db;
            if (_isUpgradeNeeded(dbInfo, self2._defaultConfig.version)) {
              return _getUpgradedConnection(dbInfo);
            }
            return db;
          }).then(function(db) {
            dbInfo.db = dbContext.db = db;
            self2._dbInfo = dbInfo;
            for (var k = 0; k < forages.length; k++) {
              var forage2 = forages[k];
              if (forage2 !== self2) {
                forage2._dbInfo.db = dbInfo.db;
                forage2._dbInfo.version = dbInfo.version;
              }
            }
          });
        }
        function getItem2(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.get(key2);
                  req.onsuccess = function() {
                    var value = req.result;
                    if (value === void 0) {
                      value = null;
                    }
                    if (_isEncodedBlob(value)) {
                      value = _decodeBlob(value);
                    }
                    resolve(value);
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function iterate(iterator, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.openCursor();
                  var iterationNumber = 1;
                  req.onsuccess = function() {
                    var cursor = req.result;
                    if (cursor) {
                      var value = cursor.value;
                      if (_isEncodedBlob(value)) {
                        value = _decodeBlob(value);
                      }
                      var result = iterator(value, cursor.key, iterationNumber++);
                      if (result !== void 0) {
                        resolve(result);
                      } else {
                        cursor["continue"]();
                      }
                    } else {
                      resolve();
                    }
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function setItem2(key2, value, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            var dbInfo;
            self2.ready().then(function() {
              dbInfo = self2._dbInfo;
              if (toString.call(value) === "[object Blob]") {
                return _checkBlobSupport(dbInfo.db).then(function(blobSupport) {
                  if (blobSupport) {
                    return value;
                  }
                  return _encodeBlob(value);
                });
              }
              return value;
            }).then(function(value2) {
              createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  if (value2 === null) {
                    value2 = void 0;
                  }
                  var req = store.put(value2, key2);
                  transaction.oncomplete = function() {
                    if (value2 === void 0) {
                      value2 = null;
                    }
                    resolve(value2);
                  };
                  transaction.onabort = transaction.onerror = function() {
                    var err2 = req.error ? req.error : req.transaction.error;
                    reject(err2);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function removeItem(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store["delete"](key2);
                  transaction.oncomplete = function() {
                    resolve();
                  };
                  transaction.onerror = function() {
                    reject(req.error);
                  };
                  transaction.onabort = function() {
                    var err2 = req.error ? req.error : req.transaction.error;
                    reject(err2);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function clear(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.clear();
                  transaction.oncomplete = function() {
                    resolve();
                  };
                  transaction.onabort = transaction.onerror = function() {
                    var err2 = req.error ? req.error : req.transaction.error;
                    reject(err2);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function length(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.count();
                  req.onsuccess = function() {
                    resolve(req.result);
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function key(n, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            if (n < 0) {
              resolve(null);
              return;
            }
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var advanced = false;
                  var req = store.openKeyCursor();
                  req.onsuccess = function() {
                    var cursor = req.result;
                    if (!cursor) {
                      resolve(null);
                      return;
                    }
                    if (n === 0) {
                      resolve(cursor.key);
                    } else {
                      if (!advanced) {
                        advanced = true;
                        cursor.advance(n);
                      } else {
                        resolve(cursor.key);
                      }
                    }
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function keys(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.openKeyCursor();
                  var keys2 = [];
                  req.onsuccess = function() {
                    var cursor = req.result;
                    if (!cursor) {
                      resolve(keys2);
                      return;
                    }
                    keys2.push(cursor.key);
                    cursor["continue"]();
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function dropInstance(options, callback) {
          callback = getCallback.apply(this, arguments);
          var currentConfig = this.config();
          options = typeof options !== "function" && options || {};
          if (!options.name) {
            options.name = options.name || currentConfig.name;
            options.storeName = options.storeName || currentConfig.storeName;
          }
          var self2 = this;
          var promise;
          if (!options.name) {
            promise = Promise$1.reject("Invalid arguments");
          } else {
            var isCurrentDb = options.name === currentConfig.name && self2._dbInfo.db;
            var dbPromise = isCurrentDb ? Promise$1.resolve(self2._dbInfo.db) : _getOriginalConnection(options).then(function(db) {
              var dbContext = dbContexts[options.name];
              var forages = dbContext.forages;
              dbContext.db = db;
              for (var i = 0; i < forages.length; i++) {
                forages[i]._dbInfo.db = db;
              }
              return db;
            });
            if (!options.storeName) {
              promise = dbPromise.then(function(db) {
                _deferReadiness(options);
                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;
                db.close();
                for (var i = 0; i < forages.length; i++) {
                  var forage = forages[i];
                  forage._dbInfo.db = null;
                }
                var dropDBPromise = new Promise$1(function(resolve, reject) {
                  var req = idb.deleteDatabase(options.name);
                  req.onerror = function() {
                    var db2 = req.result;
                    if (db2) {
                      db2.close();
                    }
                    reject(req.error);
                  };
                  req.onblocked = function() {
                    console.warn('dropInstance blocked for database "' + options.name + '" until all open connections are closed');
                  };
                  req.onsuccess = function() {
                    var db2 = req.result;
                    if (db2) {
                      db2.close();
                    }
                    resolve(db2);
                  };
                });
                return dropDBPromise.then(function(db2) {
                  dbContext.db = db2;
                  for (var i2 = 0; i2 < forages.length; i2++) {
                    var _forage = forages[i2];
                    _advanceReadiness(_forage._dbInfo);
                  }
                })["catch"](function(err) {
                  (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                  });
                  throw err;
                });
              });
            } else {
              promise = dbPromise.then(function(db) {
                if (!db.objectStoreNames.contains(options.storeName)) {
                  return;
                }
                var newVersion = db.version + 1;
                _deferReadiness(options);
                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;
                db.close();
                for (var i = 0; i < forages.length; i++) {
                  var forage = forages[i];
                  forage._dbInfo.db = null;
                  forage._dbInfo.version = newVersion;
                }
                var dropObjectPromise = new Promise$1(function(resolve, reject) {
                  var req = idb.open(options.name, newVersion);
                  req.onerror = function(err) {
                    var db2 = req.result;
                    db2.close();
                    reject(err);
                  };
                  req.onupgradeneeded = function() {
                    var db2 = req.result;
                    db2.deleteObjectStore(options.storeName);
                  };
                  req.onsuccess = function() {
                    var db2 = req.result;
                    db2.close();
                    resolve(db2);
                  };
                });
                return dropObjectPromise.then(function(db2) {
                  dbContext.db = db2;
                  for (var j = 0; j < forages.length; j++) {
                    var _forage2 = forages[j];
                    _forage2._dbInfo.db = db2;
                    _advanceReadiness(_forage2._dbInfo);
                  }
                })["catch"](function(err) {
                  (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                  });
                  throw err;
                });
              });
            }
          }
          executeCallback(promise, callback);
          return promise;
        }
        var asyncStorage = {
          _driver: "asyncStorage",
          _initStorage,
          _support: isIndexedDBValid(),
          iterate,
          getItem: getItem2,
          setItem: setItem2,
          removeItem,
          clear,
          length,
          key,
          keys,
          dropInstance
        };
        function isWebSQLValid() {
          return typeof openDatabase === "function";
        }
        var BASE_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var BLOB_TYPE_PREFIX = "~~local_forage_type~";
        var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;
        var SERIALIZED_MARKER = "__lfsc__:";
        var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;
        var TYPE_ARRAYBUFFER = "arbf";
        var TYPE_BLOB = "blob";
        var TYPE_INT8ARRAY = "si08";
        var TYPE_UINT8ARRAY = "ui08";
        var TYPE_UINT8CLAMPEDARRAY = "uic8";
        var TYPE_INT16ARRAY = "si16";
        var TYPE_INT32ARRAY = "si32";
        var TYPE_UINT16ARRAY = "ur16";
        var TYPE_UINT32ARRAY = "ui32";
        var TYPE_FLOAT32ARRAY = "fl32";
        var TYPE_FLOAT64ARRAY = "fl64";
        var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
        var toString$1 = Object.prototype.toString;
        function stringToBuffer(serializedString) {
          var bufferLength = serializedString.length * 0.75;
          var len = serializedString.length;
          var i;
          var p = 0;
          var encoded1, encoded2, encoded3, encoded4;
          if (serializedString[serializedString.length - 1] === "=") {
            bufferLength--;
            if (serializedString[serializedString.length - 2] === "=") {
              bufferLength--;
            }
          }
          var buffer = new ArrayBuffer(bufferLength);
          var bytes = new Uint8Array(buffer);
          for (i = 0; i < len; i += 4) {
            encoded1 = BASE_CHARS.indexOf(serializedString[i]);
            encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
            encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
            encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);
            bytes[p++] = encoded1 << 2 | encoded2 >> 4;
            bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
            bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
          }
          return buffer;
        }
        function bufferToString(buffer) {
          var bytes = new Uint8Array(buffer);
          var base64String = "";
          var i;
          for (i = 0; i < bytes.length; i += 3) {
            base64String += BASE_CHARS[bytes[i] >> 2];
            base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
            base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
            base64String += BASE_CHARS[bytes[i + 2] & 63];
          }
          if (bytes.length % 3 === 2) {
            base64String = base64String.substring(0, base64String.length - 1) + "=";
          } else if (bytes.length % 3 === 1) {
            base64String = base64String.substring(0, base64String.length - 2) + "==";
          }
          return base64String;
        }
        function serialize(value, callback) {
          var valueType = "";
          if (value) {
            valueType = toString$1.call(value);
          }
          if (value && (valueType === "[object ArrayBuffer]" || value.buffer && toString$1.call(value.buffer) === "[object ArrayBuffer]")) {
            var buffer;
            var marker = SERIALIZED_MARKER;
            if (value instanceof ArrayBuffer) {
              buffer = value;
              marker += TYPE_ARRAYBUFFER;
            } else {
              buffer = value.buffer;
              if (valueType === "[object Int8Array]") {
                marker += TYPE_INT8ARRAY;
              } else if (valueType === "[object Uint8Array]") {
                marker += TYPE_UINT8ARRAY;
              } else if (valueType === "[object Uint8ClampedArray]") {
                marker += TYPE_UINT8CLAMPEDARRAY;
              } else if (valueType === "[object Int16Array]") {
                marker += TYPE_INT16ARRAY;
              } else if (valueType === "[object Uint16Array]") {
                marker += TYPE_UINT16ARRAY;
              } else if (valueType === "[object Int32Array]") {
                marker += TYPE_INT32ARRAY;
              } else if (valueType === "[object Uint32Array]") {
                marker += TYPE_UINT32ARRAY;
              } else if (valueType === "[object Float32Array]") {
                marker += TYPE_FLOAT32ARRAY;
              } else if (valueType === "[object Float64Array]") {
                marker += TYPE_FLOAT64ARRAY;
              } else {
                callback(new Error("Failed to get type for BinaryArray"));
              }
            }
            callback(marker + bufferToString(buffer));
          } else if (valueType === "[object Blob]") {
            var fileReader = new FileReader();
            fileReader.onload = function() {
              var str = BLOB_TYPE_PREFIX + value.type + "~" + bufferToString(this.result);
              callback(SERIALIZED_MARKER + TYPE_BLOB + str);
            };
            fileReader.readAsArrayBuffer(value);
          } else {
            try {
              callback(JSON.stringify(value));
            } catch (e) {
              console.error("Couldn't convert value into a JSON string: ", value);
              callback(null, e);
            }
          }
        }
        function deserialize(value) {
          if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
            return JSON.parse(value);
          }
          var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
          var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
          var blobType;
          if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
            var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
            blobType = matcher[1];
            serializedString = serializedString.substring(matcher[0].length);
          }
          var buffer = stringToBuffer(serializedString);
          switch (type) {
            case TYPE_ARRAYBUFFER:
              return buffer;
            case TYPE_BLOB:
              return createBlob([buffer], { type: blobType });
            case TYPE_INT8ARRAY:
              return new Int8Array(buffer);
            case TYPE_UINT8ARRAY:
              return new Uint8Array(buffer);
            case TYPE_UINT8CLAMPEDARRAY:
              return new Uint8ClampedArray(buffer);
            case TYPE_INT16ARRAY:
              return new Int16Array(buffer);
            case TYPE_UINT16ARRAY:
              return new Uint16Array(buffer);
            case TYPE_INT32ARRAY:
              return new Int32Array(buffer);
            case TYPE_UINT32ARRAY:
              return new Uint32Array(buffer);
            case TYPE_FLOAT32ARRAY:
              return new Float32Array(buffer);
            case TYPE_FLOAT64ARRAY:
              return new Float64Array(buffer);
            default:
              throw new Error("Unkown type: " + type);
          }
        }
        var localforageSerializer = {
          serialize,
          deserialize,
          stringToBuffer,
          bufferToString
        };
        function createDbTable(t, dbInfo, callback, errorCallback) {
          t.executeSql("CREATE TABLE IF NOT EXISTS " + dbInfo.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], callback, errorCallback);
        }
        function _initStorage$1(options) {
          var self2 = this;
          var dbInfo = {
            db: null
          };
          if (options) {
            for (var i in options) {
              dbInfo[i] = typeof options[i] !== "string" ? options[i].toString() : options[i];
            }
          }
          var dbInfoPromise = new Promise$1(function(resolve, reject) {
            try {
              dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
            } catch (e) {
              return reject(e);
            }
            dbInfo.db.transaction(function(t) {
              createDbTable(t, dbInfo, function() {
                self2._dbInfo = dbInfo;
                resolve();
              }, function(t2, error) {
                reject(error);
              });
            }, reject);
          });
          dbInfo.serializer = localforageSerializer;
          return dbInfoPromise;
        }
        function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {
          t.executeSql(sqlStatement, args, callback, function(t2, error) {
            if (error.code === error.SYNTAX_ERR) {
              t2.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [dbInfo.storeName], function(t3, results) {
                if (!results.rows.length) {
                  createDbTable(t3, dbInfo, function() {
                    t3.executeSql(sqlStatement, args, callback, errorCallback);
                  }, errorCallback);
                } else {
                  errorCallback(t3, error);
                }
              }, errorCallback);
            } else {
              errorCallback(t2, error);
            }
          }, errorCallback);
        }
        function getItem$1(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "SELECT * FROM " + dbInfo.storeName + " WHERE key = ? LIMIT 1", [key2], function(t2, results) {
                  var result = results.rows.length ? results.rows.item(0).value : null;
                  if (result) {
                    result = dbInfo.serializer.deserialize(result);
                  }
                  resolve(result);
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function iterate$1(iterator, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "SELECT * FROM " + dbInfo.storeName, [], function(t2, results) {
                  var rows = results.rows;
                  var length2 = rows.length;
                  for (var i = 0; i < length2; i++) {
                    var item = rows.item(i);
                    var result = item.value;
                    if (result) {
                      result = dbInfo.serializer.deserialize(result);
                    }
                    result = iterator(result, item.key, i + 1);
                    if (result !== void 0) {
                      resolve(result);
                      return;
                    }
                  }
                  resolve();
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function _setItem(key2, value, callback, retriesLeft) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              if (value === void 0) {
                value = null;
              }
              var originalValue = value;
              var dbInfo = self2._dbInfo;
              dbInfo.serializer.serialize(value, function(value2, error) {
                if (error) {
                  reject(error);
                } else {
                  dbInfo.db.transaction(function(t) {
                    tryExecuteSql(t, dbInfo, "INSERT OR REPLACE INTO " + dbInfo.storeName + " (key, value) VALUES (?, ?)", [key2, value2], function() {
                      resolve(originalValue);
                    }, function(t2, error2) {
                      reject(error2);
                    });
                  }, function(sqlError) {
                    if (sqlError.code === sqlError.QUOTA_ERR) {
                      if (retriesLeft > 0) {
                        resolve(_setItem.apply(self2, [key2, originalValue, callback, retriesLeft - 1]));
                        return;
                      }
                      reject(sqlError);
                    }
                  });
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function setItem$1(key2, value, callback) {
          return _setItem.apply(this, [key2, value, callback, 1]);
        }
        function removeItem$1(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "DELETE FROM " + dbInfo.storeName + " WHERE key = ?", [key2], function() {
                  resolve();
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function clear$1(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "DELETE FROM " + dbInfo.storeName, [], function() {
                  resolve();
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function length$1(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "SELECT COUNT(key) as c FROM " + dbInfo.storeName, [], function(t2, results) {
                  var result = results.rows.item(0).c;
                  resolve(result);
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function key$1(n, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "SELECT key FROM " + dbInfo.storeName + " WHERE id = ? LIMIT 1", [n + 1], function(t2, results) {
                  var result = results.rows.length ? results.rows.item(0).key : null;
                  resolve(result);
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function keys$1(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "SELECT key FROM " + dbInfo.storeName, [], function(t2, results) {
                  var keys2 = [];
                  for (var i = 0; i < results.rows.length; i++) {
                    keys2.push(results.rows.item(i).key);
                  }
                  resolve(keys2);
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function getAllStoreNames(db) {
          return new Promise$1(function(resolve, reject) {
            db.transaction(function(t) {
              t.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(t2, results) {
                var storeNames = [];
                for (var i = 0; i < results.rows.length; i++) {
                  storeNames.push(results.rows.item(i).name);
                }
                resolve({
                  db,
                  storeNames
                });
              }, function(t2, error) {
                reject(error);
              });
            }, function(sqlError) {
              reject(sqlError);
            });
          });
        }
        function dropInstance$1(options, callback) {
          callback = getCallback.apply(this, arguments);
          var currentConfig = this.config();
          options = typeof options !== "function" && options || {};
          if (!options.name) {
            options.name = options.name || currentConfig.name;
            options.storeName = options.storeName || currentConfig.storeName;
          }
          var self2 = this;
          var promise;
          if (!options.name) {
            promise = Promise$1.reject("Invalid arguments");
          } else {
            promise = new Promise$1(function(resolve) {
              var db;
              if (options.name === currentConfig.name) {
                db = self2._dbInfo.db;
              } else {
                db = openDatabase(options.name, "", "", 0);
              }
              if (!options.storeName) {
                resolve(getAllStoreNames(db));
              } else {
                resolve({
                  db,
                  storeNames: [options.storeName]
                });
              }
            }).then(function(operationInfo) {
              return new Promise$1(function(resolve, reject) {
                operationInfo.db.transaction(function(t) {
                  function dropTable(storeName) {
                    return new Promise$1(function(resolve2, reject2) {
                      t.executeSql("DROP TABLE IF EXISTS " + storeName, [], function() {
                        resolve2();
                      }, function(t2, error) {
                        reject2(error);
                      });
                    });
                  }
                  var operations = [];
                  for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {
                    operations.push(dropTable(operationInfo.storeNames[i]));
                  }
                  Promise$1.all(operations).then(function() {
                    resolve();
                  })["catch"](function(e) {
                    reject(e);
                  });
                }, function(sqlError) {
                  reject(sqlError);
                });
              });
            });
          }
          executeCallback(promise, callback);
          return promise;
        }
        var webSQLStorage = {
          _driver: "webSQLStorage",
          _initStorage: _initStorage$1,
          _support: isWebSQLValid(),
          iterate: iterate$1,
          getItem: getItem$1,
          setItem: setItem$1,
          removeItem: removeItem$1,
          clear: clear$1,
          length: length$1,
          key: key$1,
          keys: keys$1,
          dropInstance: dropInstance$1
        };
        function isLocalStorageValid() {
          try {
            return typeof localStorage !== "undefined" && "setItem" in localStorage && !!localStorage.setItem;
          } catch (e) {
            return false;
          }
        }
        function _getKeyPrefix(options, defaultConfig) {
          var keyPrefix = options.name + "/";
          if (options.storeName !== defaultConfig.storeName) {
            keyPrefix += options.storeName + "/";
          }
          return keyPrefix;
        }
        function checkIfLocalStorageThrows() {
          var localStorageTestKey = "_localforage_support_test";
          try {
            localStorage.setItem(localStorageTestKey, true);
            localStorage.removeItem(localStorageTestKey);
            return false;
          } catch (e) {
            return true;
          }
        }
        function _isLocalStorageUsable() {
          return !checkIfLocalStorageThrows() || localStorage.length > 0;
        }
        function _initStorage$2(options) {
          var self2 = this;
          var dbInfo = {};
          if (options) {
            for (var i in options) {
              dbInfo[i] = options[i];
            }
          }
          dbInfo.keyPrefix = _getKeyPrefix(options, self2._defaultConfig);
          if (!_isLocalStorageUsable()) {
            return Promise$1.reject();
          }
          self2._dbInfo = dbInfo;
          dbInfo.serializer = localforageSerializer;
          return Promise$1.resolve();
        }
        function clear$2(callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var keyPrefix = self2._dbInfo.keyPrefix;
            for (var i = localStorage.length - 1; i >= 0; i--) {
              var key2 = localStorage.key(i);
              if (key2.indexOf(keyPrefix) === 0) {
                localStorage.removeItem(key2);
              }
            }
          });
          executeCallback(promise, callback);
          return promise;
        }
        function getItem$2(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var result = localStorage.getItem(dbInfo.keyPrefix + key2);
            if (result) {
              result = dbInfo.serializer.deserialize(result);
            }
            return result;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function iterate$2(iterator, callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var keyPrefix = dbInfo.keyPrefix;
            var keyPrefixLength = keyPrefix.length;
            var length2 = localStorage.length;
            var iterationNumber = 1;
            for (var i = 0; i < length2; i++) {
              var key2 = localStorage.key(i);
              if (key2.indexOf(keyPrefix) !== 0) {
                continue;
              }
              var value = localStorage.getItem(key2);
              if (value) {
                value = dbInfo.serializer.deserialize(value);
              }
              value = iterator(value, key2.substring(keyPrefixLength), iterationNumber++);
              if (value !== void 0) {
                return value;
              }
            }
          });
          executeCallback(promise, callback);
          return promise;
        }
        function key$2(n, callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var result;
            try {
              result = localStorage.key(n);
            } catch (error) {
              result = null;
            }
            if (result) {
              result = result.substring(dbInfo.keyPrefix.length);
            }
            return result;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function keys$2(callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var length2 = localStorage.length;
            var keys2 = [];
            for (var i = 0; i < length2; i++) {
              var itemKey = localStorage.key(i);
              if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
                keys2.push(itemKey.substring(dbInfo.keyPrefix.length));
              }
            }
            return keys2;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function length$2(callback) {
          var self2 = this;
          var promise = self2.keys().then(function(keys2) {
            return keys2.length;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function removeItem$2(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            localStorage.removeItem(dbInfo.keyPrefix + key2);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function setItem$2(key2, value, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = self2.ready().then(function() {
            if (value === void 0) {
              value = null;
            }
            var originalValue = value;
            return new Promise$1(function(resolve, reject) {
              var dbInfo = self2._dbInfo;
              dbInfo.serializer.serialize(value, function(value2, error) {
                if (error) {
                  reject(error);
                } else {
                  try {
                    localStorage.setItem(dbInfo.keyPrefix + key2, value2);
                    resolve(originalValue);
                  } catch (e) {
                    if (e.name === "QuotaExceededError" || e.name === "NS_ERROR_DOM_QUOTA_REACHED") {
                      reject(e);
                    }
                    reject(e);
                  }
                }
              });
            });
          });
          executeCallback(promise, callback);
          return promise;
        }
        function dropInstance$2(options, callback) {
          callback = getCallback.apply(this, arguments);
          options = typeof options !== "function" && options || {};
          if (!options.name) {
            var currentConfig = this.config();
            options.name = options.name || currentConfig.name;
            options.storeName = options.storeName || currentConfig.storeName;
          }
          var self2 = this;
          var promise;
          if (!options.name) {
            promise = Promise$1.reject("Invalid arguments");
          } else {
            promise = new Promise$1(function(resolve) {
              if (!options.storeName) {
                resolve(options.name + "/");
              } else {
                resolve(_getKeyPrefix(options, self2._defaultConfig));
              }
            }).then(function(keyPrefix) {
              for (var i = localStorage.length - 1; i >= 0; i--) {
                var key2 = localStorage.key(i);
                if (key2.indexOf(keyPrefix) === 0) {
                  localStorage.removeItem(key2);
                }
              }
            });
          }
          executeCallback(promise, callback);
          return promise;
        }
        var localStorageWrapper = {
          _driver: "localStorageWrapper",
          _initStorage: _initStorage$2,
          _support: isLocalStorageValid(),
          iterate: iterate$2,
          getItem: getItem$2,
          setItem: setItem$2,
          removeItem: removeItem$2,
          clear: clear$2,
          length: length$2,
          key: key$2,
          keys: keys$2,
          dropInstance: dropInstance$2
        };
        var sameValue = function sameValue2(x, y) {
          return x === y || typeof x === "number" && typeof y === "number" && isNaN(x) && isNaN(y);
        };
        var includes = function includes2(array, searchElement) {
          var len = array.length;
          var i = 0;
          while (i < len) {
            if (sameValue(array[i], searchElement)) {
              return true;
            }
            i++;
          }
          return false;
        };
        var isArray = Array.isArray || function(arg) {
          return Object.prototype.toString.call(arg) === "[object Array]";
        };
        var DefinedDrivers = {};
        var DriverSupport = {};
        var DefaultDrivers = {
          INDEXEDDB: asyncStorage,
          WEBSQL: webSQLStorage,
          LOCALSTORAGE: localStorageWrapper
        };
        var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];
        var OptionalDriverMethods = ["dropInstance"];
        var LibraryMethods = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(OptionalDriverMethods);
        var DefaultConfig = {
          description: "",
          driver: DefaultDriverOrder.slice(),
          name: "localforage",
          size: 4980736,
          storeName: "keyvaluepairs",
          version: 1
        };
        function callWhenReady(localForageInstance, libraryMethod) {
          localForageInstance[libraryMethod] = function() {
            var _args = arguments;
            return localForageInstance.ready().then(function() {
              return localForageInstance[libraryMethod].apply(localForageInstance, _args);
            });
          };
        }
        function extend() {
          for (var i = 1; i < arguments.length; i++) {
            var arg = arguments[i];
            if (arg) {
              for (var _key in arg) {
                if (arg.hasOwnProperty(_key)) {
                  if (isArray(arg[_key])) {
                    arguments[0][_key] = arg[_key].slice();
                  } else {
                    arguments[0][_key] = arg[_key];
                  }
                }
              }
            }
          }
          return arguments[0];
        }
        var LocalForage = function() {
          function LocalForage2(options) {
            _classCallCheck(this, LocalForage2);
            for (var driverTypeKey in DefaultDrivers) {
              if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
                var driver = DefaultDrivers[driverTypeKey];
                var driverName = driver._driver;
                this[driverTypeKey] = driverName;
                if (!DefinedDrivers[driverName]) {
                  this.defineDriver(driver);
                }
              }
            }
            this._defaultConfig = extend({}, DefaultConfig);
            this._config = extend({}, this._defaultConfig, options);
            this._driverSet = null;
            this._initDriver = null;
            this._ready = false;
            this._dbInfo = null;
            this._wrapLibraryMethodsWithReady();
            this.setDriver(this._config.driver)["catch"](function() {
            });
          }
          LocalForage2.prototype.config = function config(options) {
            if ((typeof options === "undefined" ? "undefined" : _typeof(options)) === "object") {
              if (this._ready) {
                return new Error("Can't call config() after localforage has been used.");
              }
              for (var i in options) {
                if (i === "storeName") {
                  options[i] = options[i].replace(/\W/g, "_");
                }
                if (i === "version" && typeof options[i] !== "number") {
                  return new Error("Database version must be a number.");
                }
                this._config[i] = options[i];
              }
              if ("driver" in options && options.driver) {
                return this.setDriver(this._config.driver);
              }
              return true;
            } else if (typeof options === "string") {
              return this._config[options];
            } else {
              return this._config;
            }
          };
          LocalForage2.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
            var promise = new Promise$1(function(resolve, reject) {
              try {
                var driverName = driverObject._driver;
                var complianceError = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
                if (!driverObject._driver) {
                  reject(complianceError);
                  return;
                }
                var driverMethods = LibraryMethods.concat("_initStorage");
                for (var i = 0, len = driverMethods.length; i < len; i++) {
                  var driverMethodName = driverMethods[i];
                  var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                  if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== "function") {
                    reject(complianceError);
                    return;
                  }
                }
                var configureMissingMethods = function configureMissingMethods2() {
                  var methodNotImplementedFactory = function methodNotImplementedFactory2(methodName) {
                    return function() {
                      var error = new Error("Method " + methodName + " is not implemented by the current driver");
                      var promise2 = Promise$1.reject(error);
                      executeCallback(promise2, arguments[arguments.length - 1]);
                      return promise2;
                    };
                  };
                  for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                    var optionalDriverMethod = OptionalDriverMethods[_i];
                    if (!driverObject[optionalDriverMethod]) {
                      driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                    }
                  }
                };
                configureMissingMethods();
                var setDriverSupport = function setDriverSupport2(support) {
                  if (DefinedDrivers[driverName]) {
                    console.info("Redefining LocalForage driver: " + driverName);
                  }
                  DefinedDrivers[driverName] = driverObject;
                  DriverSupport[driverName] = support;
                  resolve();
                };
                if ("_support" in driverObject) {
                  if (driverObject._support && typeof driverObject._support === "function") {
                    driverObject._support().then(setDriverSupport, reject);
                  } else {
                    setDriverSupport(!!driverObject._support);
                  }
                } else {
                  setDriverSupport(true);
                }
              } catch (e) {
                reject(e);
              }
            });
            executeTwoCallbacks(promise, callback, errorCallback);
            return promise;
          };
          LocalForage2.prototype.driver = function driver() {
            return this._driver || null;
          };
          LocalForage2.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
            var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error("Driver not found."));
            executeTwoCallbacks(getDriverPromise, callback, errorCallback);
            return getDriverPromise;
          };
          LocalForage2.prototype.getSerializer = function getSerializer(callback) {
            var serializerPromise = Promise$1.resolve(localforageSerializer);
            executeTwoCallbacks(serializerPromise, callback);
            return serializerPromise;
          };
          LocalForage2.prototype.ready = function ready(callback) {
            var self2 = this;
            var promise = self2._driverSet.then(function() {
              if (self2._ready === null) {
                self2._ready = self2._initDriver();
              }
              return self2._ready;
            });
            executeTwoCallbacks(promise, callback, callback);
            return promise;
          };
          LocalForage2.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
            var self2 = this;
            if (!isArray(drivers)) {
              drivers = [drivers];
            }
            var supportedDrivers = this._getSupportedDrivers(drivers);
            function setDriverToConfig() {
              self2._config.driver = self2.driver();
            }
            function extendSelfWithDriver(driver) {
              self2._extend(driver);
              setDriverToConfig();
              self2._ready = self2._initStorage(self2._config);
              return self2._ready;
            }
            function initDriver(supportedDrivers2) {
              return function() {
                var currentDriverIndex = 0;
                function driverPromiseLoop() {
                  while (currentDriverIndex < supportedDrivers2.length) {
                    var driverName = supportedDrivers2[currentDriverIndex];
                    currentDriverIndex++;
                    self2._dbInfo = null;
                    self2._ready = null;
                    return self2.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                  }
                  setDriverToConfig();
                  var error = new Error("No available storage method found.");
                  self2._driverSet = Promise$1.reject(error);
                  return self2._driverSet;
                }
                return driverPromiseLoop();
              };
            }
            var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function() {
              return Promise$1.resolve();
            }) : Promise$1.resolve();
            this._driverSet = oldDriverSetDone.then(function() {
              var driverName = supportedDrivers[0];
              self2._dbInfo = null;
              self2._ready = null;
              return self2.getDriver(driverName).then(function(driver) {
                self2._driver = driver._driver;
                setDriverToConfig();
                self2._wrapLibraryMethodsWithReady();
                self2._initDriver = initDriver(supportedDrivers);
              });
            })["catch"](function() {
              setDriverToConfig();
              var error = new Error("No available storage method found.");
              self2._driverSet = Promise$1.reject(error);
              return self2._driverSet;
            });
            executeTwoCallbacks(this._driverSet, callback, errorCallback);
            return this._driverSet;
          };
          LocalForage2.prototype.supports = function supports(driverName) {
            return !!DriverSupport[driverName];
          };
          LocalForage2.prototype._extend = function _extend(libraryMethodsAndProperties) {
            extend(this, libraryMethodsAndProperties);
          };
          LocalForage2.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
            var supportedDrivers = [];
            for (var i = 0, len = drivers.length; i < len; i++) {
              var driverName = drivers[i];
              if (this.supports(driverName)) {
                supportedDrivers.push(driverName);
              }
            }
            return supportedDrivers;
          };
          LocalForage2.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
            for (var i = 0, len = LibraryMethods.length; i < len; i++) {
              callWhenReady(this, LibraryMethods[i]);
            }
          };
          LocalForage2.prototype.createInstance = function createInstance(options) {
            return new LocalForage2(options);
          };
          return LocalForage2;
        }();
        var localforage_js = new LocalForage();
        module4.exports = localforage_js;
      }, { "3": 3 }] }, {}, [4])(4);
    });
  }
});

// src/main.ts
__export(exports, {
  default: () => PlantumlPlugin
});
var import_obsidian6 = __toModule(require("obsidian"));

// src/settings.ts
var import_obsidian = __toModule(require("obsidian"));
var DEFAULT_SETTINGS = {
  server_url: "https://www.plantuml.com/plantuml",
  header: "",
  debounce: 3,
  localJar: "",
  javaPath: "java",
  dotPath: "dot",
  defaultProcessor: "png",
  cache: 60,
  exportPath: ""
};
var PlantUMLSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(plugin) {
    super(plugin.app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Server URL").setDesc("PlantUML Server URL").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.server_url).setValue(this.plugin.settings.server_url).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.server_url = value;
      yield this.plugin.saveSettings();
    })));
    if (import_obsidian.Platform.isDesktopApp) {
      const jarDesc = new DocumentFragment();
      jarDesc.createDiv().innerHTML = "Path to local JAR<br>Supports:<ul><li>Absolute path</li><li>Path relative to vault</li><li>Path relative to users home directory <code>~/</code></li></ul>";
      new import_obsidian.Setting(containerEl).setName("Local JAR").setDesc(jarDesc).addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.localJar).setValue(this.plugin.settings.localJar).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.localJar = value;
        yield this.plugin.saveSettings();
      })));
      new import_obsidian.Setting(containerEl).setName("Java path").setDesc("Path to Java executable").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.javaPath).setValue(this.plugin.settings.javaPath).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.javaPath = value;
        yield this.plugin.saveSettings();
      })));
      new import_obsidian.Setting(containerEl).setName("Dot path").setDesc("Path to dot executable").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.dotPath).setValue(this.plugin.settings.dotPath).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.dotPath = value;
        yield this.plugin.saveSettings();
      })));
      new import_obsidian.Setting(containerEl).setName("Diagram export path").setDesc("Path where exported diagrams will be saved relative to the vault root. Leave blank to save along side the note.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.exportPath).setValue(this.plugin.settings.exportPath).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.exportPath = value;
        yield this.plugin.saveSettings();
      })));
    }
    new import_obsidian.Setting(containerEl).setName("Default processor for includes").setDesc("Any .pu/.puml files linked will use this processor").addDropdown((dropdown) => {
      dropdown.addOption("png", "PNG").addOption("svg", "SVG").setValue(this.plugin.settings.defaultProcessor).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.defaultProcessor = value;
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian.Setting(containerEl).setName("Header").setDesc("Included at the head in every diagram. Useful for specifying a common theme (.puml file)").addTextArea((text) => {
      text.setPlaceholder("!include https://raw.githubusercontent.com/....puml\n").setValue(this.plugin.settings.header).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.header = value;
        yield this.plugin.saveSettings();
      }));
      text.inputEl.setAttr("rows", 4);
      text.inputEl.addClass("puml-settings-area");
    });
    new import_obsidian.Setting(containerEl).setName("Cache").setDesc("in days. Only applicable when generating diagrams locally").addSlider((slider) => {
      slider.setLimits(10, 360, 10).setValue(this.plugin.settings.cache).setDynamicTooltip().onChange((value) => __async(this, null, function* () {
        this.plugin.settings.cache = value;
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian.Setting(containerEl).setName("Debounce").setDesc("How often should the diagram refresh in seconds").addText((text) => text.setPlaceholder(String(DEFAULT_SETTINGS.debounce)).setValue(String(this.plugin.settings.debounce)).onChange((value) => __async(this, null, function* () {
      if (!isNaN(Number(value)) || value === void 0) {
        this.plugin.settings.debounce = Number(value || DEFAULT_SETTINGS.debounce);
        yield this.plugin.saveSettings();
      } else {
        new import_obsidian.Notice("Please specify a valid number");
      }
    })));
  }
};

// src/processors/localProcessors.ts
var plantuml = __toModule(require_browser_index());

// src/functions.ts
var Replacer = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  replaceNonBreakingSpaces(text) {
    const lines = text.split(/\r?\n/);
    const resultLines = [];
    if (text.startsWith("@startmindmap")) {
      for (const line of lines) {
        resultLines.push(line.replace(/\s+/g, " "));
      }
    } else {
      resultLines.push(...lines);
    }
    const result = resultLines.join("\r\n");
    return result.replace(/&nbsp;/gi, " ");
  }
  replaceLinks(text, path, filetype) {
    return text.replace(/\[\[\[([\s\S]*?)\]\]\]/g, (_, args) => {
      const split = args.split("|");
      const file = this.plugin.app.metadataCache.getFirstLinkpathDest(split[0], path);
      if (!file) {
        return "File with name: " + split[0] + " not found";
      }
      let alias = file.basename;
      if (filetype === "png") {
        const url = this.plugin.app.getObsidianUrl(file);
        if (split[1]) {
          alias = split[1];
        }
        return "[[" + url + " " + alias + "]]";
      }
      return "[[" + file.basename + "]]";
    });
  }
  getFullPath(path) {
    if (path.length === 0) {
      return this.plugin.app.vault.adapter.getFullPath("");
    }
    const file = this.plugin.app.vault.getAbstractFileByPath(path);
    if (!file) {
      return this.plugin.app.vault.adapter.getFullPath("");
    }
    const folder = this.plugin.app.vault.getDirectParent(file);
    return this.plugin.app.vault.adapter.getFullPath(folder.path);
  }
  getPath(ctx) {
    return this.getFullPath(ctx ? ctx.sourcePath : "");
  }
};
function insertImageWithMap(el, image, map, encodedDiagram) {
  el.empty();
  const img = document.createElement("img");
  if (image.startsWith("http")) {
    img.src = image;
  } else {
    img.src = "data:image/png;base64," + image;
  }
  img.useMap = "#" + encodedDiagram;
  if (map.contains("map")) {
    el.innerHTML = map;
    el.children[0].setAttr("name", encodedDiagram);
  }
  el.appendChild(img);
}
function insertAsciiImage(el, image) {
  el.empty();
  const pre = document.createElement("pre");
  const code = document.createElement("code");
  pre.appendChild(code);
  code.setText(image);
  el.appendChild(pre);
}
function insertSvgImage(el, image) {
  el.empty();
  const parser = new DOMParser();
  const svg = parser.parseFromString(image, "image/svg+xml");
  const links = svg.getElementsByTagName("a");
  for (let i = 0; i < links.length; i++) {
    const link = links[i];
    link.addClass("internal-link");
  }
  el.insertAdjacentHTML("beforeend", svg.documentElement.outerHTML);
}

// src/const.ts
var LOGO_SVG = '<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" width="100" height="100" preserveAspectRatio="xMidYMid meet" viewBox="0 0 32 32"><defs><linearGradient id="svgIDc" x1="-33.423" x2="-33.353" y1="-250.911" y2="-250.858" gradientTransform="matrix(37.134 26.001 13.575 -19.387 4673.473 -3982.019)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#767676"/><stop offset="1"/></linearGradient><linearGradient id="svgIDa" x1="-32.107" x2="-32.028" y1="-242.563" y2="-242.586" gradientTransform="matrix(81.081 56.774 17.306 -24.715 6804.021 -4149.644)" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#0079b9"/><stop offset="1"/></linearGradient><linearGradient id="svgIDd" x1="-33.282" x2="-33.224" y1="-243.423" y2="-243.455" gradientTransform="matrix(60.003 42.015 34.184 -48.82 10343.005 -10469.084)" href="#svgIDa"/><linearGradient id="svgIDb" x1="12.356" x2="14.011" y1="26.268" y2="26.268" gradientUnits="userSpaceOnUse"><stop offset="0" stop-color="#595959"/><stop offset=".087" stop-color="#6e6e6e"/><stop offset=".242" stop-color="#8c8c8c"/><stop offset=".405" stop-color="#a4a4a4"/><stop offset=".577" stop-color="#b5b5b5"/><stop offset=".765" stop-color="#bfbfbf"/><stop offset="1" stop-color="#c2c2c2"/></linearGradient><linearGradient id="svgIDe" x1="18.291" x2="19.946" y1="26.171" y2="26.171" href="#svgIDb"/><linearGradient id="svgIDf" x1="24.44" x2="26.096" y1="26.171" y2="26.171" href="#svgIDb"/></defs><path fill="#1c0a42" d="m20.305 17.872l6.855 4.546l-5.44 3.075l-6.859-4.494l5.444-3.127z"/><path d="m21.716 25.619l-.055-.036l-7.005-4.59l5.653-3.247l7.056 4.68Zm-6.65-4.613l6.658 4.362l5.231-2.957L20.3 18Z"/><path fill="url(#svgIDc)" d="m26.401 11.909l3.017 1.683l-2.348 1.496l-2.857-1.841l2.188-1.338z"/><path d="m27.069 15.215l-3.058-1.97l2.387-1.46l3.228 1.8Zm-2.654-1.966l2.655 1.711l2.138-1.36l-2.8-1.565Z"/><path fill="#ffbd3f" d="m14.498 17.807l6.856 4.547l-5.44 3.075l-6.859-4.494l5.443-3.128z"/><path d="m15.91 25.554l-.055-.036l-7.005-4.589l5.65-3.248l7.056 4.68Zm-6.65-4.613l6.658 4.359l5.231-2.957l-6.654-4.413Z"/><path fill="#a11f40" d="m7.99 17.966l6.964 4.4l-5.377 3.138l-7.359-4.655l5.772-2.883z"/><path d="M9.575 25.629L2 20.838l6-3l7.164 4.527ZM2.436 20.86l7.144 4.518l5.168-3.016l-6.764-4.273Z"/><path fill="url(#svgIDa)" d="m2.111 21.021l7.332 4.494v3.548l-7.332-4.731v-3.311z"/><path d="M9.55 29.26L2 24.391v-3.562l7.55 4.626Zm-7.332-4.986l7.118 4.592v-3.291l-7.118-4.362Z"/><path fill="url(#svgIDd)" d="m24.071 13.343l2.938 1.879v6.909l-2.938-1.884v-6.904z"/><path d="m27.063 22.229l-3.045-1.953v-7.031l3.045 1.947Zm-2.938-2.012l2.831 1.815v-6.781l-2.831-1.81Z"/><path fill="#fff" d="M27.149 22.526v-7.332l2.365-1.419v15.374H9.646v-3.548l5.44-3.075l.699 3.075h.011l5.676-3.075l.419 3.075h.054l5.204-3.075z"/><path d="M29.621 29.256H9.539v-3.718l5.62-3.177l.7 3.083l5.7-3.087l.422 3.1l5.061-2.991v-7.333l2.58-1.548Zm-19.868-.215h19.654V13.964l-2.151 1.29v7.332l-.053.031l-5.229 3.09H21.8l-.411-3.014l-5.564 3.014H15.7l-.686-3.018l-5.26 2.973Z"/><rect width="1.656" height="1.656" x="12.356" y="25.44" fill="url(#svgIDb)" rx=".215" ry=".215"/><path d="M13.8 27.2h-1.23a.322.322 0 0 1-.322-.322v-1.223a.322.322 0 0 1 .322-.322h1.23a.322.322 0 0 1 .322.322v1.226a.322.322 0 0 1-.322.319Zm-1.23-1.653a.108.108 0 0 0-.107.107v1.226a.108.108 0 0 0 .107.107h1.23a.108.108 0 0 0 .107-.107v-1.225a.108.108 0 0 0-.107-.107Z"/><rect width="1.656" height="1.656" x="18.291" y="25.343" fill="url(#svgIDe)" rx=".215" ry=".215"/><path d="M19.732 27.106h-1.227a.322.322 0 0 1-.322-.322v-1.226a.322.322 0 0 1 .322-.322h1.226a.322.322 0 0 1 .322.322v1.226a.322.322 0 0 1-.321.322Zm-1.226-1.656a.108.108 0 0 0-.107.107v1.226a.108.108 0 0 0 .107.107h1.226a.108.108 0 0 0 .107-.107v-1.225a.108.108 0 0 0-.107-.107Z"/><rect width="1.656" height="1.656" x="24.44" y="25.343" fill="url(#svgIDf)" rx=".215" ry=".215"/><path d="M25.881 27.106h-1.226a.322.322 0 0 1-.322-.322v-1.226a.322.322 0 0 1 .322-.322h1.226a.322.322 0 0 1 .322.322v1.226a.322.322 0 0 1-.322.322Zm-1.226-1.656a.108.108 0 0 0-.107.107v1.226a.108.108 0 0 0 .107.107h1.226a.108.108 0 0 0 .107-.107v-1.225a.108.108 0 0 0-.107-.107Z"/><path fill="#ea2d2e" d="M27.215 11.23c-.052.069-.417-.262-.653-.526a4.408 4.408 0 0 1-.516-.73A2.6 2.6 0 0 1 25.7 9.2a2.358 2.358 0 0 1-.052-.682a2.959 2.959 0 0 1 .129-.749a3.142 3.142 0 0 1 .787-1.207a15.532 15.532 0 0 0 1.283-1.4a3.062 3.062 0 0 0 .479-.927a3.979 3.979 0 0 0 .151-.855c.019-.364-.025-.593.023-.613s.215.274.287.564a3.167 3.167 0 0 1-.458 2.1a6.9 6.9 0 0 1-1.094 1.448a2.8 2.8 0 0 0-.849 1.234a2.466 2.466 0 0 0-.086.687a3.465 3.465 0 0 0 .476 1.542c.288.572.48.833.439.888Z"/><path d="M27.193 11.266c-.124 0-.492-.365-.651-.544a4.478 4.478 0 0 1-.52-.734a2.628 2.628 0 0 1-.346-.781a2.375 2.375 0 0 1-.053-.69a2.978 2.978 0 0 1 .13-.756a3.208 3.208 0 0 1 .793-1.216c.294-.331.5-.528.659-.686a4.393 4.393 0 0 0 .622-.711a3.052 3.052 0 0 0 .476-.919a3.951 3.951 0 0 0 .15-.849c.008-.159 0-.294 0-.393c0-.159-.006-.225.038-.243a.05.05 0 0 1 .043 0a1.226 1.226 0 0 1 .28.579a3.167 3.167 0 0 1-.46 2.121a6.928 6.928 0 0 1-1.1 1.453c-.055.06-.109.116-.162.171a2.3 2.3 0 0 0-.681 1.052a2.47 2.47 0 0 0-.082.673a3.458 3.458 0 0 0 .473 1.53c.114.231.215.415.289.549c.129.235.178.323.142.369a.051.051 0 0 1-.04.02ZM28.512 2.8a.863.863 0 0 0 0 .19c0 .1.007.236 0 .4a4.021 4.021 0 0 1-.152.861a3.106 3.106 0 0 1-.483.934a4.437 4.437 0 0 1-.629.719c-.162.158-.364.354-.657.683a3.168 3.168 0 0 0-.782 1.2a2.933 2.933 0 0 0-.128.743a2.325 2.325 0 0 0 .052.675a2.59 2.59 0 0 0 .341.767a4.422 4.422 0 0 0 .513.725a2.035 2.035 0 0 0 .611.526a1.183 1.183 0 0 0-.147-.31a12.935 12.935 0 0 1-.29-.551a3.5 3.5 0 0 1-.483-1.562a2.53 2.53 0 0 1 .084-.688a2.375 2.375 0 0 1 .694-1.075c.052-.055.106-.111.161-.171a6.879 6.879 0 0 0 1.09-1.442a3.119 3.119 0 0 0 .456-2.083a1.281 1.281 0 0 0-.251-.541Z"/><path fill="#ea2d2e" d="M29.972 6.087c-.019-.088-.432-.04-.766.073a2.6 2.6 0 0 0-1.059.722a2.8 2.8 0 0 0-.916 1.855a2.972 2.972 0 0 0 .258 1.06c.221.572.455.773.444 1.225c-.007.3-.114.484-.048.549s.314-.1.462-.313a1.8 1.8 0 0 0 .259-1.022c-.046-.815-.6-1.015-.608-1.8a1.858 1.858 0 0 1 .129-.676c.443-1.251 1.881-1.508 1.845-1.673Z"/><path d="M27.934 11.617a.094.094 0 0 1-.069-.026c-.046-.046-.03-.122-.005-.237a1.718 1.718 0 0 0 .045-.331a1.374 1.374 0 0 0-.214-.72a5 5 0 0 1-.228-.495a2.98 2.98 0 0 1-.259-1.07a2.81 2.81 0 0 1 .923-1.874a2.64 2.64 0 0 1 1.07-.729a1.482 1.482 0 0 1 .766-.1a.065.065 0 0 1 .037.046c.015.07-.092.121-.306.224a2.73 2.73 0 0 0-1.542 1.463a1.827 1.827 0 0 0-.127.667a1.645 1.645 0 0 0 .291.885a1.889 1.889 0 0 1 .317.914a1.814 1.814 0 0 1-.264 1.039a.809.809 0 0 1-.421.342Zm1.889-5.549a2.117 2.117 0 0 0-.608.117a2.588 2.588 0 0 0-1.048.715a2.764 2.764 0 0 0-.909 1.837a2.935 2.935 0 0 0 .256 1.05a4.955 4.955 0 0 0 .225.49a1.433 1.433 0 0 1 .22.745a1.765 1.765 0 0 1-.047.341c-.019.091-.035.163-.009.188a.046.046 0 0 0 .038.01a.769.769 0 0 0 .382-.32a1.793 1.793 0 0 0 .254-1.005a1.844 1.844 0 0 0-.31-.89a1.711 1.711 0 0 1-.3-.911a1.877 1.877 0 0 1 .13-.686a2.776 2.776 0 0 1 1.573-1.492c.126-.061.283-.136.277-.164l-.008-.007a.264.264 0 0 0-.116-.018Z"/></svg>';
var OutputType = /* @__PURE__ */ ((OutputType2) => {
  OutputType2["PNG"] = "png";
  OutputType2["SVG"] = "svg";
  OutputType2["ASCII"] = "txt";
  return OutputType2;
})(OutputType || {});

// src/processors/localProcessors.ts
var localforage = __toModule(require_localforage());
var LocalProcessors = class {
  constructor(plugin) {
    this.ascii = (source, el, ctx) => __async(this, null, function* () {
      const encodedDiagram = plantuml.encode(source);
      const item = yield localforage.getItem("ascii-" + encodedDiagram);
      if (item) {
        insertAsciiImage(el, item);
        yield localforage.setItem("ts-" + encodedDiagram, Date.now());
        return;
      }
      const image = yield this.generateLocalImage(source, OutputType.ASCII, this.plugin.replacer.getPath(ctx));
      insertAsciiImage(el, image);
      yield localforage.setItem("ascii-" + encodedDiagram, image);
      yield localforage.setItem("ts-" + encodedDiagram, Date.now());
    });
    this.png = (source, el, ctx) => __async(this, null, function* () {
      const encodedDiagram = plantuml.encode(source);
      const item = yield localforage.getItem("png-" + encodedDiagram);
      if (item) {
        const map2 = yield localforage.getItem("map-" + encodedDiagram);
        insertImageWithMap(el, item, map2, encodedDiagram);
        yield localforage.setItem("ts-" + encodedDiagram, Date.now());
        return;
      }
      const path = this.plugin.replacer.getPath(ctx);
      const image = yield this.generateLocalImage(source, OutputType.PNG, path);
      const map = yield this.generateLocalMap(source, path);
      yield localforage.setItem("png-" + encodedDiagram, image);
      yield localforage.setItem("map-" + encodedDiagram, map);
      yield localforage.setItem("ts-" + encodedDiagram, Date.now());
      insertImageWithMap(el, image, map, encodedDiagram);
    });
    this.svg = (source, el, ctx) => __async(this, null, function* () {
      const encodedDiagram = plantuml.encode(source);
      const item = yield localforage.getItem("svg-" + encodedDiagram);
      if (item) {
        insertSvgImage(el, item);
        yield localforage.setItem("ts-" + encodedDiagram, Date.now());
        return;
      }
      const image = yield this.generateLocalImage(source, OutputType.SVG, this.plugin.replacer.getPath(ctx));
      yield localforage.setItem("svg-" + encodedDiagram, image);
      yield localforage.setItem("ts-" + encodedDiagram, Date.now());
      insertSvgImage(el, image);
    });
    this.plugin = plugin;
  }
  generateLocalMap(source, path) {
    return __async(this, null, function* () {
      const { exec } = require("child_process");
      const args = this.resolveLocalJarCmd().concat(["-pipemap"]);
      const child = exec(args.join(" "), { encoding: "binary", cwd: path });
      let stdout = "";
      if (child.stdout) {
        child.stdout.on("data", (data) => {
          stdout += data;
        });
      }
      return new Promise((resolve, reject) => {
        child.on("error", reject);
        child.on("close", (code) => {
          if (code === 0) {
            resolve(stdout);
            return;
          } else if (code === 1) {
            console.log(stdout);
            reject(new Error(`an error occurred`));
          } else {
            reject(new Error(`child exited with code ${code}`));
          }
        });
        child.stdin.write(source);
        child.stdin.end();
      });
    });
  }
  generateLocalImage(source, type, path) {
    return __async(this, null, function* () {
      const { ChildProcess, exec } = require("child_process");
      const args = this.resolveLocalJarCmd().concat(["-t" + type, "-pipe"]);
      let child;
      if (type === OutputType.PNG) {
        child = exec(args.join(" "), { encoding: "binary", cwd: path });
      } else {
        child = exec(args.join(" "), { encoding: "utf-8", cwd: path });
      }
      let stdout;
      let stderr;
      if (child.stdout) {
        child.stdout.on("data", (data) => {
          if (stdout === void 0) {
            stdout = data;
          } else
            stdout += data;
        });
      }
      if (child.stderr) {
        child.stderr.on("data", (data) => {
          if (stderr === void 0) {
            stderr = data;
          } else
            stderr += data;
        });
      }
      return new Promise((resolve, reject) => {
        child.on("error", reject);
        child.on("close", (code) => {
          if (stdout === void 0) {
            return;
          }
          if (code === 0) {
            if (type === OutputType.PNG) {
              const buf = new Buffer(stdout, "binary");
              resolve(buf.toString("base64"));
              return;
            }
            resolve(stdout);
            return;
          } else if (code === 1) {
            console.error(stdout);
            reject(new Error(stderr));
          } else {
            if (type === OutputType.PNG) {
              const buf = new Buffer(stdout, "binary");
              resolve(buf.toString("base64"));
              return;
            }
            resolve(stdout);
            return;
          }
        });
        child.stdin.write(source, "utf-8");
        child.stdin.end();
      });
    });
  }
  resolveLocalJarCmd() {
    const jarFromSettings = this.plugin.settings.localJar;
    const { isAbsolute, resolve } = require("path");
    const { userInfo } = require("os");
    let jarFullPath;
    const path = this.plugin.replacer.getFullPath("");
    if (jarFromSettings[0] === "~") {
      jarFullPath = userInfo().homedir + jarFromSettings.slice(1);
    } else {
      if (isAbsolute(jarFromSettings)) {
        jarFullPath = jarFromSettings;
      } else {
        jarFullPath = resolve(path, jarFromSettings);
      }
    }
    if (jarFullPath.length == 0) {
      throw Error("Invalid local jar file");
    }
    if (jarFullPath.endsWith(".jar")) {
      return [
        this.plugin.settings.javaPath,
        "-jar",
        '"' + jarFullPath + '"',
        "-Djava.awt.headless=true",
        "-charset",
        "utf-8",
        "-graphvizdot",
        '"' + this.plugin.settings.dotPath + '"'
      ];
    }
    return [
      jarFullPath,
      "-Djava.awt.headless=true",
      "-charset",
      "utf-8",
      "-graphvizdot",
      '"' + this.plugin.settings.dotPath + '"'
    ];
  }
};

// src/processors/debouncedProcessors.ts
var import_obsidian2 = __toModule(require("obsidian"));

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).substr(1));
}
var i;
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var stringify_default = stringify;

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default = v4;

// src/processors/debouncedProcessors.ts
var DebouncedProcessors = class {
  constructor(plugin) {
    this.SECONDS_TO_MS_FACTOR = 1e3;
    this.debounceMap = /* @__PURE__ */ new Map();
    this.default = (source, el, ctx) => __async(this, null, function* () {
      yield this.png(source, el, ctx);
    });
    this.png = (source, el, ctx) => __async(this, null, function* () {
      yield this.processor(source, el, ctx, "png", this.plugin.getProcessor().png);
    });
    this.ascii = (source, el, ctx) => __async(this, null, function* () {
      yield this.processor(source, el, ctx, "ascii", this.plugin.getProcessor().ascii);
    });
    this.svg = (source, el, ctx) => __async(this, null, function* () {
      yield this.processor(source, el, ctx, "svg", this.plugin.getProcessor().svg);
    });
    this.processor = (source, el, ctx, filetype, processor) => __async(this, null, function* () {
      const originalSource = source;
      el.dataset.filetype = filetype;
      el.createEl("h6", { text: "Generating PlantUML diagram", cls: "puml-loading" });
      if (el.dataset.plantumlDebounce) {
        const debounceId = el.dataset.plantumlDebounce;
        if (this.debounceMap.has(debounceId)) {
          this.debounceMap.get(debounceId)(source, el, ctx);
        }
      } else {
        const func = (0, import_obsidian2.debounce)(processor, this.debounceTime, true);
        const uuid = v4_default();
        el.dataset.plantumlDebouce = uuid;
        this.debounceMap.set(uuid, func);
        source = this.plugin.replacer.replaceNonBreakingSpaces(source);
        source = this.plugin.replacer.replaceLinks(source, this.plugin.replacer.getPath(ctx), filetype);
        source = this.plugin.settings.header + "\r\n" + source;
        yield processor(source, el, ctx);
        el.addEventListener("contextmenu", (event) => {
          const menu = new import_obsidian2.Menu().addItem((item) => {
            item.setTitle("Copy diagram source").setIcon("clipboard-copy").onClick(() => __async(this, null, function* () {
              yield navigator.clipboard.writeText(originalSource);
            }));
          }).addItem((item) => {
            item.setTitle("Copy diagram").setIcon("image").onClick(() => __async(this, null, function* () {
              console.log(el);
              const img = el.querySelector("img");
              if (img) {
                this.renderToBlob(img, "An error occurred while copying image to clipboard", (blob) => __async(this, null, function* () {
                  yield navigator.clipboard.write([
                    new ClipboardItem({
                      "image/png": blob
                    })
                  ]);
                  new import_obsidian2.Notice("Diagram copied to clipboard");
                }));
              }
              const svg = el.querySelector("svg");
              if (svg) {
                yield navigator.clipboard.writeText(svg.outerHTML);
                new import_obsidian2.Notice("Diagram copied to clipboard");
              }
              const code = el.querySelector("code");
              if (code) {
                yield navigator.clipboard.writeText(code.innerText);
                new import_obsidian2.Notice("Diagram copied to clipboard");
              }
            }));
          }).addItem((item) => {
            item.setTitle("Export diagram").setIcon("image-file").onClick(() => __async(this, null, function* () {
              const img = el.querySelector("img");
              if (img) {
                this.renderToBlob(img, "An error occurred while exporting the diagram", (blob) => __async(this, null, function* () {
                  const filename = yield this.getFilePath(source, ctx, "png");
                  const buffer = yield blob.arrayBuffer();
                  const file = this.getFile(filename);
                  if (file) {
                    yield this.plugin.app.vault.modifyBinary(file, buffer);
                  } else {
                    yield this.plugin.app.vault.createBinary(filename, buffer);
                  }
                  new import_obsidian2.Notice(`Diagram exported to '${filename}'`);
                }));
              }
              const svg = el.querySelector("svg");
              if (svg) {
                yield this.saveTextFile(source, ctx, "svg", svg.outerHTML);
              }
              const code = el.querySelector("code");
              if (code) {
                yield this.saveTextFile(source, ctx, "txt", code.innerText);
              }
            }));
          });
          menu.showAtMouseEvent(event);
        });
      }
    });
    this.renderToBlob = (img, errorMessage, handleBlob) => {
      const image = new Image();
      image.crossOrigin = "anonymous";
      image.src = img.src;
      image.addEventListener("load", () => {
        const canvas = document.createElement("canvas");
        canvas.width = image.width;
        canvas.height = image.height;
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = "#fff";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(image, 0, 0);
        try {
          canvas.toBlob((blob) => __async(this, null, function* () {
            try {
              yield handleBlob(blob);
            } catch (error) {
              new import_obsidian2.Notice(errorMessage);
              console.error(error);
            }
          }));
        } catch (error) {
          new import_obsidian2.Notice(errorMessage);
          console.error(error);
        }
      });
    };
    this.getFilename = (source, ctx) => {
      const startuml = source.match(/@startuml (.+)/i);
      if ((startuml == null ? void 0 : startuml.length) >= 2) {
        return `${startuml[1].trim()}`;
      }
      const now = new Date().toISOString().replace(/[:T]+/g, "-");
      const filename = this.plugin.app.vault.getAbstractFileByPath(ctx.sourcePath).name;
      return `${filename.substring(0, filename.lastIndexOf("."))}-${now.substring(0, now.lastIndexOf("."))}`;
    };
    this.getFolder = (ctx) => __async(this, null, function* () {
      let exportPath = this.plugin.settings.exportPath;
      if (!exportPath.startsWith("/")) {
        const documentPath = this.plugin.app.vault.getAbstractFileByPath(ctx.sourcePath).parent;
        exportPath = `${documentPath.path}/${exportPath}`;
      }
      const exists = yield this.plugin.app.vault.adapter.exists(exportPath);
      if (!exists) {
        this.plugin.app.vault.createFolder(exportPath);
      }
      return exportPath;
    });
    this.getFilePath = (source, ctx, type) => __async(this, null, function* () {
      const filename = this.getFilename(source, ctx);
      const path = yield this.getFolder(ctx);
      return `${path}${filename}.${type}`;
    });
    this.getFile = (fileName) => {
      let fName = fileName;
      if (fName.startsWith("/")) {
        fName = fName.substring(1);
      }
      const folderOrFile = this.plugin.app.vault.getAbstractFileByPath(fName);
      if (folderOrFile instanceof import_obsidian2.TFile) {
        return folderOrFile;
      }
      return void 0;
    };
    this.saveTextFile = (source, ctx, type, data) => __async(this, null, function* () {
      try {
        const filename = yield this.getFilePath(source, ctx, type);
        const file = this.getFile(filename);
        if (file) {
          yield this.plugin.app.vault.modify(file, data);
        } else {
          yield this.plugin.app.vault.create(filename, data);
        }
        new import_obsidian2.Notice(`Diagram exported to '${filename}'`);
      } catch (error) {
        new import_obsidian2.Notice("An error occurred while while exporting the diagram");
        console.error(error);
      }
    });
    this.plugin = plugin;
    const debounceTime = plugin.settings.debounce;
    this.debounceTime = debounceTime * this.SECONDS_TO_MS_FACTOR;
  }
};

// src/processors/serverProcessor.ts
var import_obsidian3 = __toModule(require("obsidian"));
var plantuml2 = __toModule(require_browser_index());
var ServerProcessor = class {
  constructor(plugin) {
    this.svg = (source, el, _) => __async(this, null, function* () {
      let url = this.plugin.settings.server_url;
      if (url.length == 0) {
        url = DEFAULT_SETTINGS.server_url;
      }
      const imageUrlBase = url + "/svg/";
      const encodedDiagram = plantuml2.encode(source);
      (0, import_obsidian3.request)({ url: imageUrlBase + encodedDiagram, method: "GET" }).then((value) => {
        insertSvgImage(el, value);
      }).catch((error) => {
        if (error)
          console.error(error);
      });
    });
    this.png = (source, el, _) => __async(this, null, function* () {
      let url = this.plugin.settings.server_url;
      if (url.length == 0) {
        url = DEFAULT_SETTINGS.server_url;
      }
      const imageUrlBase = url + "/png/";
      const encodedDiagram = plantuml2.encode(source);
      const image = imageUrlBase + encodedDiagram;
      const mapUrlBase = url + "/map/";
      const map = yield (0, import_obsidian3.request)({ url: mapUrlBase + encodedDiagram, method: "GET" });
      insertImageWithMap(el, image, map, encodedDiagram);
    });
    this.ascii = (source, el, _) => __async(this, null, function* () {
      let url = this.plugin.settings.server_url;
      if (url.length == 0) {
        url = DEFAULT_SETTINGS.server_url;
      }
      const asciiUrlBase = url + "/txt/";
      const encodedDiagram = plantuml2.encode(source);
      const result = yield (0, import_obsidian3.request)({ url: asciiUrlBase + encodedDiagram });
      if (result.startsWith("\uFFFDPNG")) {
        const text = document.createElement("p");
        text.style.color = "red";
        text.innerText = "Your configured PlantUML Server does not support ASCII Art";
        el.appendChild(text);
        return;
      }
      insertAsciiImage(el, result);
    });
    this.plugin = plugin;
  }
};

// src/PumlView.ts
var import_obsidian4 = __toModule(require("obsidian"));
var import_view = __toModule(require("@codemirror/view"));
var import_state = __toModule(require("@codemirror/state"));
var import_search = __toModule(require("@codemirror/search"));
var import_commands = __toModule(require("@codemirror/commands"));
var VIEW_TYPE = "plantuml";
var views = [];
var syncAnnotation = import_state.Annotation.define();
function syncDispatch(from) {
  return (tr) => {
    views[from].update([tr]);
    if (tr.changes && tr.annotation && !tr.changes.empty && !tr.annotation(syncAnnotation)) {
      for (let i = 0; i < views.length; i++) {
        if (i !== from) {
          views[i].dispatch({
            changes: tr.changes,
            annotations: syncAnnotation.of(true)
          });
        }
      }
    }
  };
}
var PumlView = class extends import_obsidian4.TextFileView {
  constructor(leaf, plugin) {
    super(leaf);
    this.dispatchId = -1;
    this.extensions = [
      (0, import_view.highlightActiveLine)(),
      (0, import_view.highlightActiveLineGutter)(),
      (0, import_search.highlightSelectionMatches)(),
      (0, import_view.drawSelection)(),
      import_view.keymap.of([...import_commands.defaultKeymap, import_commands.indentWithTab]),
      (0, import_commands.history)(),
      (0, import_search.search)(),
      import_view.EditorView.updateListener.of((v) => __async(this, null, function* () {
        if (v.docChanged) {
          this.requestSave();
          yield this.renderPreview();
        }
      }))
    ];
    this.plugin = plugin;
    this.debounced = (0, import_obsidian4.debounce)(this.plugin.getProcessor().png, this.plugin.settings.debounce * 1e3, true);
    this.sourceEl = this.contentEl.createDiv({ cls: "plantuml-source-view", attr: { "style": "display: block" } });
    this.previewEl = this.contentEl.createDiv({ cls: "plantuml-preview-view", attr: { "style": "display: none" } });
    const vault = this.app.vault;
    if (vault.getConfig("showLineNumber")) {
      this.extensions.push((0, import_view.lineNumbers)());
    }
    if (vault.getConfig("lineWrap")) {
      this.extensions.push(import_view.EditorView.lineWrapping);
    }
    this.editor = new import_view.EditorView({
      state: import_state.EditorState.create({
        extensions: this.extensions,
        doc: this.data
      }),
      parent: this.sourceEl,
      dispatch: syncDispatch(views.length)
    });
    this.dispatchId = views.push(this.editor) - 1;
  }
  getViewType() {
    return VIEW_TYPE;
  }
  getState() {
    return super.getState();
  }
  setState(state, result) {
    if (state.mode === "preview") {
      this.currentView = "preview";
      (0, import_obsidian4.setIcon)(this.changeModeButton, "pencil");
      this.changeModeButton.setAttribute("aria-label", "Edit (Ctrl+Click to edit in new pane)");
      this.previewEl.style.setProperty("display", "block");
      this.sourceEl.style.setProperty("display", "none");
      this.renderPreview();
    } else {
      this.currentView = "source";
      (0, import_obsidian4.setIcon)(this.changeModeButton, "lines-of-text");
      this.changeModeButton.setAttribute("aria-label", "Preview (Ctrl+Click to open in new pane)");
      this.previewEl.style.setProperty("display", "none");
      this.sourceEl.style.setProperty("display", "block");
    }
    return super.setState(state, result);
  }
  onload() {
    return __async(this, null, function* () {
      this.changeModeButton = this.addAction("lines-of-text", "Preview (Ctrl+Click to open in new pane)", (evt) => this.switchMode(evt), 17);
      const defaultViewMode = this.app.vault.getConfig("defaultViewMode");
      this.currentView = defaultViewMode;
      yield this.setState(__spreadProps(__spreadValues({}, this.getState()), { mode: defaultViewMode }), {});
    });
  }
  onunload() {
    views.remove(views[this.dispatchId]);
    this.editor.destroy();
  }
  switchMode(arg) {
    return __async(this, null, function* () {
      let mode = arg;
      if (!mode || mode instanceof MouseEvent)
        mode = this.currentView === "source" ? "preview" : "source";
      if (arg instanceof MouseEvent) {
        if (import_obsidian4.Keymap.isModEvent(arg)) {
          this.app.workspace.duplicateLeaf(this.leaf).then(() => __async(this, null, function* () {
            var _a, _b;
            const viewState = (_a = this.app.workspace.activeLeaf) == null ? void 0 : _a.getViewState();
            if (viewState) {
              viewState.state = __spreadProps(__spreadValues({}, viewState.state), { mode });
              yield (_b = this.app.workspace.activeLeaf) == null ? void 0 : _b.setViewState(viewState);
            }
          }));
        } else {
          yield this.setState(__spreadProps(__spreadValues({}, this.getState()), { mode }), {});
        }
      }
    });
  }
  getViewData() {
    return this.editor.state.sliceDoc();
  }
  setViewData(data, clear) {
    return __async(this, null, function* () {
      this.data = data;
      if (clear) {
        this.editor.setState(import_state.EditorState.create({
          doc: data,
          extensions: this.extensions
        }));
      } else {
        this.editor.dispatch({
          changes: {
            from: 0,
            to: this.editor.state.doc.length,
            insert: data
          }
        });
      }
      if (this.currentView === "preview")
        this.renderPreview();
    });
  }
  clear() {
    this.previewEl.empty();
    this.data = null;
  }
  getDisplayText() {
    if (this.file)
      return this.file.basename;
    else
      return "PlantUML (no file)";
  }
  canAcceptExtension(extension) {
    return extension == "puml";
  }
  getIcon() {
    return "document-plantuml";
  }
  renderPreview() {
    return __async(this, null, function* () {
      if (this.currentView !== "preview")
        return;
      this.previewEl.empty();
      const loadingHeader = this.previewEl.createEl("h1", { text: "Loading" });
      const previewDiv = this.previewEl.createDiv();
      this.debounced(this.getViewData(), previewDiv, null);
      loadingHeader.remove();
    });
  }
};

// src/main.ts
var import_localforage = __toModule(require_localforage());

// src/embed.ts
var import_obsidian5 = __toModule(require("obsidian"));
var PumlEmbed = class extends import_obsidian5.Component {
  constructor(plugin, file, ctx) {
    super();
    this.plugin = plugin;
    this.file = file;
    this.ctx = ctx;
  }
  loadFile() {
    return __async(this, null, function* () {
      const data = yield this.plugin.app.vault.cachedRead(this.file);
      yield this.plugin.getProcessor().png(data, this.ctx.containerEl, null);
    });
  }
};

// src/main.ts
var PlantumlPlugin = class extends import_obsidian6.Plugin {
  constructor() {
    super(...arguments);
    this.hover = {
      linkText: null,
      sourcePath: null
    };
  }
  getProcessor() {
    if (import_obsidian6.Platform.isMobileApp) {
      return this.serverProcessor;
    }
    if (this.settings.localJar.length > 0) {
      return this.localProcessor;
    }
    return this.serverProcessor;
  }
  onload() {
    return __async(this, null, function* () {
      console.log("loading plugin plantuml");
      yield this.loadSettings();
      this.addSettingTab(new PlantUMLSettingsTab(this));
      this.replacer = new Replacer(this);
      this.serverProcessor = new ServerProcessor(this);
      if (import_obsidian6.Platform.isDesktopApp) {
        this.localProcessor = new LocalProcessors(this);
      }
      const processor = new DebouncedProcessors(this);
      (0, import_obsidian6.addIcon)("document-" + VIEW_TYPE, LOGO_SVG);
      this.registerView(VIEW_TYPE, (leaf) => {
        return new PumlView(leaf, this);
      });
      this.registerExtensions(["puml", "pu"], VIEW_TYPE);
      this.registerMarkdownCodeBlockProcessor("plantuml", processor.default);
      this.registerMarkdownCodeBlockProcessor("plantuml-png", processor.png);
      this.registerMarkdownCodeBlockProcessor("plantuml-ascii", processor.ascii);
      this.registerMarkdownCodeBlockProcessor("plantuml-svg", processor.svg);
      this.registerMarkdownCodeBlockProcessor("puml", processor.default);
      this.registerMarkdownCodeBlockProcessor("puml-png", processor.png);
      this.registerMarkdownCodeBlockProcessor("puml-svg", processor.svg);
      this.registerMarkdownCodeBlockProcessor("puml-ascii", processor.ascii);
      this.registerMarkdownCodeBlockProcessor("plantuml-map", processor.png);
      this.app.embedRegistry.registerExtensions(["puml", "pu"], (ctx, file, subpath) => new PumlEmbed(this, file, ctx));
      this.cleanupLocalStorage();
      import_localforage.default.config({
        name: "puml",
        description: "PlantUML plugin"
      });
      yield this.cleanupCache();
      this.observer = new MutationObserver((mutation) => __async(this, null, function* () {
        if (mutation.length !== 1)
          return;
        if (mutation[0].addedNodes.length !== 1)
          return;
        if (this.hover.linkText === null)
          return;
        if (mutation[0].addedNodes[0].className !== "popover hover-popover file-embed is-loaded")
          return;
        const file = this.app.metadataCache.getFirstLinkpathDest(this.hover.linkText, this.hover.sourcePath);
        if (!file)
          return;
        if (file.extension !== "puml" && file.extension !== "pu")
          return;
        const fileContent = yield this.app.vault.read(file);
        const imgDiv = createDiv();
        if (this.settings.defaultProcessor === "png") {
          yield this.getProcessor().png(fileContent, imgDiv, null);
        } else {
          yield this.getProcessor().svg(fileContent, imgDiv, null);
        }
        const node = mutation[0].addedNodes[0];
        node.empty();
        const div = createDiv("", (element) => __async(this, null, function* () {
          element.appendChild(imgDiv);
          element.setAttribute("src", file.path);
          element.onClickEvent((event) => {
            event.stopImmediatePropagation();
            const leaf = this.app.workspace.getLeaf(event.ctrlKey);
            leaf.setViewState({
              type: VIEW_TYPE,
              state: { file: file.path }
            });
          });
        }));
        node.appendChild(div);
      }));
      this.registerEvent(this.app.workspace.on("hover-link", (event) => __async(this, null, function* () {
        const linkText = event.linktext;
        if (!linkText)
          return;
        const sourcePath = event.sourcePath;
        if (!linkText.endsWith(".puml") && !linkText.endsWith(".pu")) {
          return;
        }
        this.hover.linkText = linkText;
        this.hover.sourcePath = sourcePath;
      })));
      this.observer.observe(document, { childList: true, subtree: true });
    });
  }
  cleanupCache() {
    return __async(this, null, function* () {
      yield import_localforage.default.iterate((value, key) => {
        if (key.startsWith("ts-")) {
          const encoded = key.split("-")[1];
          if (value < new Date().getTime() - this.settings.cache * 24 * 60 * 60 * 1e3) {
            import_localforage.default.removeItem("png-" + encoded);
            import_localforage.default.removeItem("svg-" + encoded);
            import_localforage.default.removeItem("map-" + encoded);
            import_localforage.default.removeItem("ascii-" + encoded);
          }
        }
      });
    });
  }
  cleanupLocalStorage() {
    for (const key of Object.keys(localStorage)) {
      if (key.endsWith("-map") || key.endsWith("-png") || key.endsWith("-svg") || key.endsWith("ascii")) {
        localStorage.removeItem(key);
      }
    }
  }
  onunload() {
    return __async(this, null, function* () {
      console.log("unloading plugin plantuml");
      this.observer.disconnect();
      this.app.embedRegistry.unregisterExtensions(["puml", "pu"]);
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  onExternalSettingsChange() {
    return __async(this, null, function* () {
      yield this.loadSettings();
    });
  }
};
/*!
    localForage -- Offline Storage, Improved
    Version 1.10.0
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL3BsYW50dW1sLWVuY29kZXIvZGlzdC9wbGFudHVtbC1lbmNvZGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9wbGFudHVtbC1lbmNvZGVyL2Rpc3QvcGxhbnR1bWwtZGVjb2Rlci5qcyIsICJub2RlX21vZHVsZXMvcGxhbnR1bWwtZW5jb2Rlci9icm93c2VyLWluZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9sb2NhbGZvcmFnZS9kaXN0L2xvY2FsZm9yYWdlLmpzIiwgInNyYy9tYWluLnRzIiwgInNyYy9zZXR0aW5ncy50cyIsICJzcmMvcHJvY2Vzc29ycy9sb2NhbFByb2Nlc3NvcnMudHMiLCAic3JjL2Z1bmN0aW9ucy50cyIsICJzcmMvY29uc3QudHMiLCAic3JjL3Byb2Nlc3NvcnMvZGVib3VuY2VkUHJvY2Vzc29ycy50cyIsICJub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3JuZy5qcyIsICJub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3JlZ2V4LmpzIiwgIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdmFsaWRhdGUuanMiLCAibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9zdHJpbmdpZnkuanMiLCAibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92NC5qcyIsICJzcmMvcHJvY2Vzc29ycy9zZXJ2ZXJQcm9jZXNzb3IudHMiLCAic3JjL1B1bWxWaWV3LnRzIiwgInNyYy9lbWJlZC50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcucGxhbnR1bWxFbmNvZGVyID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCdcblxudmFyIHBha28gPSByZXF1aXJlKCdwYWtvL2xpYi9kZWZsYXRlLmpzJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGF0YSkge1xuICByZXR1cm4gcGFrby5kZWZsYXRlUmF3KGRhdGEsIHsgbGV2ZWw6IDksIHRvOiAnc3RyaW5nJyB9KVxufVxuXG59LHtcInBha28vbGliL2RlZmxhdGUuanNcIjo0fV0sMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCdcblxuLy8gRW5jb2RlIGNvZGUgdGFrZW4gZnJvbSB0aGUgUGxhbnRVTUwgd2Vic2l0ZTpcbi8vIGh0dHA6Ly9wbGFudHVtbC5zb3VyY2Vmb3JnZS5uZXQvY29kZWphdmFzY3JpcHQyLmh0bWxcblxuLy8gSXQgaXMgZGVzY3JpYmVkIGFzIGJlaW5nIFwiYSB0cmFuc2Zvcm1hdGlvbiBjbG9zZSB0byBiYXNlNjRcIlxuLy8gVGhlIGNvZGUgaGFzIGJlZW4gc2xpZ2h0bHkgbW9kaWZpZWQgdG8gcGFzcyBsaW50ZXJzXG5cbmZ1bmN0aW9uIGVuY29kZTZiaXQgKGIpIHtcbiAgaWYgKGIgPCAxMCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDQ4ICsgYilcbiAgfVxuICBiIC09IDEwXG4gIGlmIChiIDwgMjYpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSg2NSArIGIpXG4gIH1cbiAgYiAtPSAyNlxuICBpZiAoYiA8IDI2KSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoOTcgKyBiKVxuICB9XG4gIGIgLT0gMjZcbiAgaWYgKGIgPT09IDApIHtcbiAgICByZXR1cm4gJy0nXG4gIH1cbiAgaWYgKGIgPT09IDEpIHtcbiAgICByZXR1cm4gJ18nXG4gIH1cbiAgcmV0dXJuICc/J1xufVxuXG5mdW5jdGlvbiBhcHBlbmQzYnl0ZXMgKGIxLCBiMiwgYjMpIHtcbiAgdmFyIGMxID0gYjEgPj4gMlxuICB2YXIgYzIgPSAoKGIxICYgMHgzKSA8PCA0KSB8IChiMiA+PiA0KVxuICB2YXIgYzMgPSAoKGIyICYgMHhGKSA8PCAyKSB8IChiMyA+PiA2KVxuICB2YXIgYzQgPSBiMyAmIDB4M0ZcbiAgdmFyIHIgPSAnJ1xuICByICs9IGVuY29kZTZiaXQoYzEgJiAweDNGKVxuICByICs9IGVuY29kZTZiaXQoYzIgJiAweDNGKVxuICByICs9IGVuY29kZTZiaXQoYzMgJiAweDNGKVxuICByICs9IGVuY29kZTZiaXQoYzQgJiAweDNGKVxuICByZXR1cm4gclxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciByID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgaWYgKGkgKyAyID09PSBkYXRhLmxlbmd0aCkge1xuICAgICAgciArPSBhcHBlbmQzYnl0ZXMoZGF0YS5jaGFyQ29kZUF0KGkpLCBkYXRhLmNoYXJDb2RlQXQoaSArIDEpLCAwKVxuICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGRhdGEubGVuZ3RoKSB7XG4gICAgICByICs9IGFwcGVuZDNieXRlcyhkYXRhLmNoYXJDb2RlQXQoaSksIDAsIDApXG4gICAgfSBlbHNlIHtcbiAgICAgIHIgKz0gYXBwZW5kM2J5dGVzKGRhdGEuY2hhckNvZGVBdChpKSxcbiAgICAgICAgZGF0YS5jaGFyQ29kZUF0KGkgKyAxKSxcbiAgICAgICAgZGF0YS5jaGFyQ29kZUF0KGkgKyAyKSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJcbn1cblxufSx7fV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCdcblxudmFyIGRlZmxhdGUgPSByZXF1aXJlKCcuL2RlZmxhdGUnKVxudmFyIGVuY29kZTY0ID0gcmVxdWlyZSgnLi9lbmNvZGU2NCcpXG5cbm1vZHVsZS5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChwdW1sKSB7XG4gIHZhciBkZWZsYXRlZCA9IGRlZmxhdGUocHVtbClcbiAgcmV0dXJuIGVuY29kZTY0KGRlZmxhdGVkKVxufVxuXG59LHtcIi4vZGVmbGF0ZVwiOjEsXCIuL2VuY29kZTY0XCI6Mn1dLDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB6bGliX2RlZmxhdGUgPSByZXF1aXJlKCcuL3psaWIvZGVmbGF0ZScpO1xudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvY29tbW9uJyk7XG52YXIgc3RyaW5ncyAgICAgID0gcmVxdWlyZSgnLi91dGlscy9zdHJpbmdzJyk7XG52YXIgbXNnICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL21lc3NhZ2VzJyk7XG52YXIgWlN0cmVhbSAgICAgID0gcmVxdWlyZSgnLi96bGliL3pzdHJlYW0nKTtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbnZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG5cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG52YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcblxudmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xO1xuXG52YXIgWl9ERUZBVUxUX1NUUkFURUdZICAgID0gMDtcblxudmFyIFpfREVGTEFURUQgID0gODtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKipcbiAqIGNsYXNzIERlZmxhdGVcbiAqXG4gKiBHZW5lcmljIEpTLXN0eWxlIHdyYXBwZXIgZm9yIHpsaWIgY2FsbHMuIElmIHlvdSBkb24ndCBuZWVkXG4gKiBzdHJlYW1pbmcgYmVoYXZpb3VyIC0gdXNlIG1vcmUgc2ltcGxlIGZ1bmN0aW9uczogW1tkZWZsYXRlXV0sXG4gKiBbW2RlZmxhdGVSYXddXSBhbmQgW1tnemlwXV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBEZWZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tEZWZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZGVuLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUucmVzdWx0IC0+IFVpbnQ4QXJyYXl8QXJyYXlcbiAqXG4gKiBDb21wcmVzc2VkIHJlc3VsdCwgZ2VuZXJhdGVkIGJ5IGRlZmF1bHQgW1tEZWZsYXRlI29uRGF0YV1dXG4gKiBhbmQgW1tEZWZsYXRlI29uRW5kXV0gaGFuZGxlcnMuIEZpbGxlZCBhZnRlciB5b3UgcHVzaCBsYXN0IGNodW5rXG4gKiAoY2FsbCBbW0RlZmxhdGUjcHVzaF1dIHdpdGggYFpfRklOSVNIYCAvIGB0cnVlYCBwYXJhbSkgIG9yIGlmIHlvdVxuICogcHVzaCBhIGNodW5rIHdpdGggZXhwbGljaXQgZmx1c2ggKGNhbGwgW1tEZWZsYXRlI3B1c2hdXSB3aXRoXG4gKiBgWl9TWU5DX0ZMVVNIYCBwYXJhbSkuXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5lcnIgLT4gTnVtYmVyXG4gKlxuICogRXJyb3IgY29kZSBhZnRlciBkZWZsYXRlIGZpbmlzaGVkLiAwIChaX09LKSBvbiBzdWNjZXNzLlxuICogWW91IHdpbGwgbm90IG5lZWQgaXQgaW4gcmVhbCBsaWZlLCBiZWNhdXNlIGRlZmxhdGUgZXJyb3JzXG4gKiBhcmUgcG9zc2libGUgb25seSBvbiB3cm9uZyBvcHRpb25zIG9yIGJhZCBgb25EYXRhYCAvIGBvbkVuZGBcbiAqIGN1c3RvbSBoYW5kbGVycy5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLm1zZyAtPiBTdHJpbmdcbiAqXG4gKiBFcnJvciBtZXNzYWdlLCBpZiBbW0RlZmxhdGUuZXJyXV0gIT0gMFxuICoqL1xuXG5cbi8qKlxuICogbmV3IERlZmxhdGUob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ3JlYXRlcyBuZXcgZGVmbGF0b3IgaW5zdGFuY2Ugd2l0aCBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgZXhjZXB0aW9uXG4gKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczpcbiAqXG4gKiAtIGBsZXZlbGBcbiAqIC0gYHdpbmRvd0JpdHNgXG4gKiAtIGBtZW1MZXZlbGBcbiAqIC0gYHN0cmF0ZWd5YFxuICogLSBgZGljdGlvbmFyeWBcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMsIGZvciBpbnRlcm5hbCBuZWVkczpcbiAqXG4gKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KVxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBkbyByYXcgZGVmbGF0ZVxuICogLSBgZ3ppcGAgKEJvb2xlYW4pIC0gY3JlYXRlIGd6aXAgd3JhcHBlclxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgXCJiaW5hcnkgc3RyaW5nXCJcbiAqICAgIChlYWNoIGNoYXIgY29kZSBbMC4uMjU1XSlcbiAqIC0gYGhlYWRlcmAgKE9iamVjdCkgLSBjdXN0b20gaGVhZGVyIGZvciBnemlwXG4gKiAgIC0gYHRleHRgIChCb29sZWFuKSAtIHRydWUgaWYgY29tcHJlc3NlZCBkYXRhIGJlbGlldmVkIHRvIGJlIHRleHRcbiAqICAgLSBgdGltZWAgKE51bWJlcikgLSBtb2RpZmljYXRpb24gdGltZSwgdW5peCB0aW1lc3RhbXBcbiAqICAgLSBgb3NgIChOdW1iZXIpIC0gb3BlcmF0aW9uIHN5c3RlbSBjb2RlXG4gKiAgIC0gYGV4dHJhYCAoQXJyYXkpIC0gYXJyYXkgb2YgYnl0ZXMgd2l0aCBleHRyYSBkYXRhIChtYXggNjU1MzYpXG4gKiAgIC0gYG5hbWVgIChTdHJpbmcpIC0gZmlsZSBuYW1lIChiaW5hcnkgc3RyaW5nKVxuICogICAtIGBjb21tZW50YCAoU3RyaW5nKSAtIGNvbW1lbnQgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGhjcmNgIChCb29sZWFuKSAtIHRydWUgaWYgaGVhZGVyIGNyYyBzaG91bGQgYmUgYWRkZWRcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgY2h1bmsxID0gVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIGNodW5rMiA9IFVpbnQ4QXJyYXkoWzEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5XSk7XG4gKlxuICogdmFyIGRlZmxhdGUgPSBuZXcgcGFrby5EZWZsYXRlKHsgbGV2ZWw6IDN9KTtcbiAqXG4gKiBkZWZsYXRlLnB1c2goY2h1bmsxLCBmYWxzZSk7XG4gKiBkZWZsYXRlLnB1c2goY2h1bmsyLCB0cnVlKTsgIC8vIHRydWUgLT4gbGFzdCBjaHVua1xuICpcbiAqIGlmIChkZWZsYXRlLmVycikgeyB0aHJvdyBuZXcgRXJyb3IoZGVmbGF0ZS5lcnIpOyB9XG4gKlxuICogY29uc29sZS5sb2coZGVmbGF0ZS5yZXN1bHQpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBEZWZsYXRlKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERlZmxhdGUpKSByZXR1cm4gbmV3IERlZmxhdGUob3B0aW9ucyk7XG5cbiAgdGhpcy5vcHRpb25zID0gdXRpbHMuYXNzaWduKHtcbiAgICBsZXZlbDogWl9ERUZBVUxUX0NPTVBSRVNTSU9OLFxuICAgIG1ldGhvZDogWl9ERUZMQVRFRCxcbiAgICBjaHVua1NpemU6IDE2Mzg0LFxuICAgIHdpbmRvd0JpdHM6IDE1LFxuICAgIG1lbUxldmVsOiA4LFxuICAgIHN0cmF0ZWd5OiBaX0RFRkFVTFRfU1RSQVRFR1ksXG4gICAgdG86ICcnXG4gIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIHZhciBvcHQgPSB0aGlzLm9wdGlvbnM7XG5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID4gMCkpIHtcbiAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKG9wdC5nemlwICYmIChvcHQud2luZG93Qml0cyA+IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzICs9IDE2O1xuICB9XG5cbiAgdGhpcy5lcnIgICAgPSAwOyAgICAgIC8vIGVycm9yIGNvZGUsIGlmIGhhcHBlbnMgKDAgPSBaX09LKVxuICB0aGlzLm1zZyAgICA9ICcnOyAgICAgLy8gZXJyb3IgbWVzc2FnZVxuICB0aGlzLmVuZGVkICA9IGZhbHNlOyAgLy8gdXNlZCB0byBhdm9pZCBtdWx0aXBsZSBvbkVuZCgpIGNhbGxzXG4gIHRoaXMuY2h1bmtzID0gW107ICAgICAvLyBjaHVua3Mgb2YgY29tcHJlc3NlZCBkYXRhXG5cbiAgdGhpcy5zdHJtID0gbmV3IFpTdHJlYW0oKTtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7XG5cbiAgdmFyIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlSW5pdDIoXG4gICAgdGhpcy5zdHJtLFxuICAgIG9wdC5sZXZlbCxcbiAgICBvcHQubWV0aG9kLFxuICAgIG9wdC53aW5kb3dCaXRzLFxuICAgIG9wdC5tZW1MZXZlbCxcbiAgICBvcHQuc3RyYXRlZ3lcbiAgKTtcblxuICBpZiAoc3RhdHVzICE9PSBaX09LKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgfVxuXG4gIGlmIChvcHQuaGVhZGVyKSB7XG4gICAgemxpYl9kZWZsYXRlLmRlZmxhdGVTZXRIZWFkZXIodGhpcy5zdHJtLCBvcHQuaGVhZGVyKTtcbiAgfVxuXG4gIGlmIChvcHQuZGljdGlvbmFyeSkge1xuICAgIHZhciBkaWN0O1xuICAgIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gSWYgd2UgbmVlZCB0byBjb21wcmVzcyB0ZXh0LCBjaGFuZ2UgZW5jb2RpbmcgdG8gdXRmOC5cbiAgICAgIGRpY3QgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgIGRpY3QgPSBuZXcgVWludDhBcnJheShvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpY3QgPSBvcHQuZGljdGlvbmFyeTtcbiAgICB9XG5cbiAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBkaWN0KTtcblxuICAgIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGljdF9zZXQgPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogRGVmbGF0ZSNwdXNoKGRhdGFbLCBtb2RlXSkgLT4gQm9vbGVhblxuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fEFycmF5QnVmZmVyfFN0cmluZyk6IGlucHV0IGRhdGEuIFN0cmluZ3Mgd2lsbCBiZVxuICogICBjb252ZXJ0ZWQgdG8gdXRmOCBieXRlIHNlcXVlbmNlLlxuICogLSBtb2RlIChOdW1iZXJ8Qm9vbGVhbik6IDAuLjYgZm9yIGNvcnJlc3BvbmRpbmcgWl9OT19GTFVTSC4uWl9UUkVFIG1vZGVzLlxuICogICBTZWUgY29uc3RhbnRzLiBTa2lwcGVkIG9yIGBmYWxzZWAgbWVhbnMgWl9OT19GTFVTSCwgYHRydWVgIG1lYW5zIFpfRklOSVNILlxuICpcbiAqIFNlbmRzIGlucHV0IGRhdGEgdG8gZGVmbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbRGVmbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoXG4gKiBuZXcgY29tcHJlc3NlZCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIFRoZSBsYXN0IGRhdGEgYmxvY2sgbXVzdCBoYXZlXG4gKiBtb2RlIFpfRklOSVNIIChvciBgdHJ1ZWApLiBUaGF0IHdpbGwgZmx1c2ggaW50ZXJuYWwgcGVuZGluZyBidWZmZXJzIGFuZCBjYWxsXG4gKiBbW0RlZmxhdGUjb25FbmRdXS4gRm9yIGludGVyaW0gZXhwbGljaXQgZmx1c2hlcyAod2l0aG91dCBlbmRpbmcgdGhlIHN0cmVhbSkgeW91XG4gKiBjYW4gdXNlIG1vZGUgWl9TWU5DX0ZMVVNILCBrZWVwaW5nIHRoZSBjb21wcmVzc2lvbiBjb250ZXh0LlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0RlZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiBXZSBzdHJvbmdseSByZWNvbW1lbmQgdG8gdXNlIGBVaW50OEFycmF5YCBvbiBpbnB1dCBmb3IgYmVzdCBzcGVlZCAob3V0cHV0XG4gKiBhcnJheSBmb3JtYXQgaXMgZGV0ZWN0ZWQgYXV0b21hdGljYWxseSkuIEFsc28sIGRvbid0IHNraXAgbGFzdCBwYXJhbSBhbmQgYWx3YXlzXG4gKiB1c2UgdGhlIHNhbWUgdHlwZSBpbiB5b3VyIGNvZGUgKGJvb2xlYW4gb3IgbnVtYmVyKS4gVGhhdCB3aWxsIGltcHJvdmUgSlMgc3BlZWQuXG4gKlxuICogRm9yIHJlZ3VsYXIgYEFycmF5YC1zIG1ha2Ugc3VyZSBhbGwgZWxlbWVudHMgYXJlIFswLi4yNTVdLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBwdXNoKGNodW5rLCBmYWxzZSk7IC8vIHB1c2ggb25lIG9mIGRhdGEgY2h1bmtzXG4gKiAuLi5cbiAqIHB1c2goY2h1bmssIHRydWUpOyAgLy8gcHVzaCBsYXN0IGNodW5rXG4gKiBgYGBcbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgbW9kZSkge1xuICB2YXIgc3RybSA9IHRoaXMuc3RybTtcbiAgdmFyIGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7XG4gIHZhciBzdGF0dXMsIF9tb2RlO1xuXG4gIGlmICh0aGlzLmVuZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIF9tb2RlID0gKG1vZGUgPT09IH5+bW9kZSkgPyBtb2RlIDogKChtb2RlID09PSB0cnVlKSA/IFpfRklOSVNIIDogWl9OT19GTFVTSCk7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gSWYgd2UgbmVlZCB0byBjb21wcmVzcyB0ZXh0LCBjaGFuZ2UgZW5jb2RpbmcgdG8gdXRmOC5cbiAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKGRhdGEpO1xuICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZG8ge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgdXRpbHMuQnVmOChjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGUoc3RybSwgX21vZGUpOyAgICAvKiBubyBiYWQgcmV0dXJuIHZhbHVlICovXG5cbiAgICBpZiAoc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBaX09LKSB7XG4gICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IChzdHJtLmF2YWlsX2luID09PSAwICYmIChfbW9kZSA9PT0gWl9GSU5JU0ggfHwgX21vZGUgPT09IFpfU1lOQ19GTFVTSCkpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLm9uRGF0YShzdHJpbmdzLmJ1ZjJiaW5zdHJpbmcodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbkRhdGEodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICB9XG4gICAgfVxuICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDAgfHwgc3RybS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gWl9TVFJFQU1fRU5EKTtcblxuICAvLyBGaW5hbGl6ZSBvbiB0aGUgbGFzdCBjaHVuay5cbiAgaWYgKF9tb2RlID09PSBaX0ZJTklTSCkge1xuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgIHJldHVybiBzdGF0dXMgPT09IFpfT0s7XG4gIH1cblxuICAvLyBjYWxsYmFjayBpbnRlcmltIHJlc3VsdHMgaWYgWl9TWU5DX0ZMVVNILlxuICBpZiAoX21vZGUgPT09IFpfU1lOQ19GTFVTSCkge1xuICAgIHRoaXMub25FbmQoWl9PSyk7XG4gICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogRGVmbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogb3V0cHV0IGRhdGEuIFR5cGUgb2YgYXJyYXkgZGVwZW5kc1xuICogICBvbiBqcyBlbmdpbmUgc3VwcG9ydC4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCwgZWFjaCBjaHVua1xuICogICB3aWxsIGJlIHN0cmluZy5cbiAqXG4gKiBCeSBkZWZhdWx0LCBzdG9yZXMgZGF0YSBibG9ja3MgaW4gYGNodW5rc1tdYCBwcm9wZXJ0eSBhbmQgZ2x1ZVxuICogdGhvc2UgaW4gYG9uRW5kYC4gT3ZlcnJpZGUgdGhpcyBoYW5kbGVyLCBpZiB5b3UgbmVlZCBhbm90aGVyIGJlaGF2aW91ci5cbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbn07XG5cblxuLyoqXG4gKiBEZWZsYXRlI29uRW5kKHN0YXR1cykgLT4gVm9pZFxuICogLSBzdGF0dXMgKE51bWJlcik6IGRlZmxhdGUgc3RhdHVzLiAwIChaX09LKSBvbiBzdWNjZXNzLFxuICogICBvdGhlciBpZiBub3QuXG4gKlxuICogQ2FsbGVkIG9uY2UgYWZ0ZXIgeW91IHRlbGwgZGVmbGF0ZSB0aGF0IHRoZSBpbnB1dCBzdHJlYW0gaXNcbiAqIGNvbXBsZXRlIChaX0ZJTklTSCkgb3Igc2hvdWxkIGJlIGZsdXNoZWQgKFpfU1lOQ19GTFVTSClcbiAqIG9yIGlmIGFuIGVycm9yIGhhcHBlbmVkLiBCeSBkZWZhdWx0IC0gam9pbiBjb2xsZWN0ZWQgY2h1bmtzLFxuICogZnJlZSBtZW1vcnkgYW5kIGZpbGwgYHJlc3VsdHNgIC8gYGVycmAgcHJvcGVydGllcy5cbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAvLyBPbiBzdWNjZXNzIC0gam9pblxuICBpZiAoc3RhdHVzID09PSBaX09LKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdXRpbHMuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7XG4gICAgfVxuICB9XG4gIHRoaXMuY2h1bmtzID0gW107XG4gIHRoaXMuZXJyID0gc3RhdHVzO1xuICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7XG59O1xuXG5cbi8qKlxuICogZGVmbGF0ZShkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ29tcHJlc3MgYGRhdGFgIHdpdGggZGVmbGF0ZSBhbGdvcml0aG0gYW5kIGBvcHRpb25zYC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSBsZXZlbFxuICogLSB3aW5kb3dCaXRzXG4gKiAtIG1lbUxldmVsXG4gKiAtIHN0cmF0ZWd5XG4gKiAtIGRpY3Rpb25hcnlcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBTdWdhciAob3B0aW9ucyk6XG4gKlxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBzYXkgdGhhdCB3ZSB3b3JrIHdpdGggcmF3IHN0cmVhbSwgaWYgeW91IGRvbid0IHdpc2ggdG8gc3BlY2lmeVxuICogICBuZWdhdGl2ZSB3aW5kb3dCaXRzIGltcGxpY2l0bHkuXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBcImJpbmFyeSBzdHJpbmdcIlxuICogICAgKGVhY2ggY2hhciBjb2RlIFswLi4yNTVdKVxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBkYXRhID0gVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhwYWtvLmRlZmxhdGUoZGF0YSkpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBkZWZsYXRvciA9IG5ldyBEZWZsYXRlKG9wdGlvbnMpO1xuXG4gIGRlZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpO1xuXG4gIC8vIFRoYXQgd2lsbCBuZXZlciBoYXBwZW5zLCBpZiB5b3UgZG9uJ3QgY2hlYXQgd2l0aCBvcHRpb25zIDopXG4gIGlmIChkZWZsYXRvci5lcnIpIHsgdGhyb3cgZGVmbGF0b3IubXNnIHx8IG1zZ1tkZWZsYXRvci5lcnJdOyB9XG5cbiAgcmV0dXJuIGRlZmxhdG9yLnJlc3VsdDtcbn1cblxuXG4vKipcbiAqIGRlZmxhdGVSYXcoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbZGVmbGF0ZV1dLCBidXQgY3JlYXRlcyByYXcgZGF0YSwgd2l0aG91dCB3cmFwcGVyXG4gKiAoaGVhZGVyIGFuZCBhZGxlcjMyIGNyYykuXG4gKiovXG5mdW5jdGlvbiBkZWZsYXRlUmF3KGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnJhdyA9IHRydWU7XG4gIHJldHVybiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIGd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbZGVmbGF0ZV1dLCBidXQgY3JlYXRlIGd6aXAgd3JhcHBlciBpbnN0ZWFkIG9mXG4gKiBkZWZsYXRlIG9uZS5cbiAqKi9cbmZ1bmN0aW9uIGd6aXAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuZ3ppcCA9IHRydWU7XG4gIHJldHVybiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG5leHBvcnRzLkRlZmxhdGUgPSBEZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlID0gZGVmbGF0ZTtcbmV4cG9ydHMuZGVmbGF0ZVJhdyA9IGRlZmxhdGVSYXc7XG5leHBvcnRzLmd6aXAgPSBnemlwO1xuXG59LHtcIi4vdXRpbHMvY29tbW9uXCI6NSxcIi4vdXRpbHMvc3RyaW5nc1wiOjYsXCIuL3psaWIvZGVmbGF0ZVwiOjksXCIuL3psaWIvbWVzc2FnZXNcIjoxMCxcIi4vemxpYi96c3RyZWFtXCI6MTJ9XSw1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuXG52YXIgVFlQRURfT0sgPSAgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIFVpbnQxNkFycmF5ICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIEludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKTtcblxuZnVuY3Rpb24gX2hhcyhvYmosIGtleSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cblxuZXhwb3J0cy5hc3NpZ24gPSBmdW5jdGlvbiAob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB3aGlsZSAoc291cmNlcy5sZW5ndGgpIHtcbiAgICB2YXIgc291cmNlID0gc291cmNlcy5zaGlmdCgpO1xuICAgIGlmICghc291cmNlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgbm9uLW9iamVjdCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHAgaW4gc291cmNlKSB7XG4gICAgICBpZiAoX2hhcyhzb3VyY2UsIHApKSB7XG4gICAgICAgIG9ialtwXSA9IHNvdXJjZVtwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG4vLyByZWR1Y2UgYnVmZmVyIHNpemUsIGF2b2lkaW5nIG1lbSBjb3B5XG5leHBvcnRzLnNocmlua0J1ZiA9IGZ1bmN0aW9uIChidWYsIHNpemUpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IHNpemUpIHsgcmV0dXJuIGJ1ZjsgfVxuICBpZiAoYnVmLnN1YmFycmF5KSB7IHJldHVybiBidWYuc3ViYXJyYXkoMCwgc2l6ZSk7IH1cbiAgYnVmLmxlbmd0aCA9IHNpemU7XG4gIHJldHVybiBidWY7XG59O1xuXG5cbnZhciBmblR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgaWYgKHNyYy5zdWJhcnJheSAmJiBkZXN0LnN1YmFycmF5KSB7XG4gICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjX29mZnMsIHNyY19vZmZzICsgbGVuKSwgZGVzdF9vZmZzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgdG8gb3JkaW5hcnkgYXJyYXlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICB2YXIgaSwgbCwgbGVuLCBwb3MsIGNodW5rLCByZXN1bHQ7XG5cbiAgICAvLyBjYWxjdWxhdGUgZGF0YSBsZW5ndGhcbiAgICBsZW4gPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBsZW4gKz0gY2h1bmtzW2ldLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBqb2luIGNodW5rc1xuICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgcG9zID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgICByZXN1bHQuc2V0KGNodW5rLCBwb3MpO1xuICAgICAgcG9zICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG52YXIgZm5VbnR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldO1xuICAgIH1cbiAgfSxcbiAgLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LlxuICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbiAoY2h1bmtzKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgY2h1bmtzKTtcbiAgfVxufTtcblxuXG4vLyBFbmFibGUvRGlzYWJsZSB0eXBlZCBhcnJheXMgdXNlLCBmb3IgdGVzdGluZ1xuLy9cbmV4cG9ydHMuc2V0VHlwZWQgPSBmdW5jdGlvbiAob24pIHtcbiAgaWYgKG9uKSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IFVpbnQ4QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYxNiA9IFVpbnQxNkFycmF5O1xuICAgIGV4cG9ydHMuQnVmMzIgPSBJbnQzMkFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVHlwZWQpO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQnVmOCAgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gQXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVW50eXBlZCk7XG4gIH1cbn07XG5cbmV4cG9ydHMuc2V0VHlwZWQoVFlQRURfT0spO1xuXG59LHt9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIFN0cmluZyBlbmNvZGUvZGVjb2RlIGhlbHBlcnNcbid1c2Ugc3RyaWN0JztcblxuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG5cbi8vIFF1aWNrIGNoZWNrIGlmIHdlIGNhbiB1c2UgZmFzdCBhcnJheSB0byBiaW4gc3RyaW5nIGNvbnZlcnNpb25cbi8vXG4vLyAtIGFwcGx5KEFycmF5KSBjYW4gZmFpbCBvbiBBbmRyb2lkIDIuMlxuLy8gLSBhcHBseShVaW50OEFycmF5KSBjYW4gZmFpbCBvbiBpT1MgNS4xIFNhZmFyaVxuLy9cbnZhciBTVFJfQVBQTFlfT0sgPSB0cnVlO1xudmFyIFNUUl9BUFBMWV9VSUFfT0sgPSB0cnVlO1xuXG50cnkgeyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIFsgMCBdKTsgfSBjYXRjaCAoX18pIHsgU1RSX0FQUExZX09LID0gZmFsc2U7IH1cbnRyeSB7IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoMSkpOyB9IGNhdGNoIChfXykgeyBTVFJfQVBQTFlfVUlBX09LID0gZmFsc2U7IH1cblxuXG4vLyBUYWJsZSB3aXRoIHV0ZjggbGVuZ3RocyAoY2FsY3VsYXRlZCBieSBmaXJzdCBieXRlIG9mIHNlcXVlbmNlKVxuLy8gTm90ZSwgdGhhdCA1ICYgNi1ieXRlIHZhbHVlcyBhbmQgc29tZSA0LWJ5dGUgdmFsdWVzIGNhbiBub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlMsXG4vLyBiZWNhdXNlIG1heCBwb3NzaWJsZSBjb2RlcG9pbnQgaXMgMHgxMGZmZmZcbnZhciBfdXRmOGxlbiA9IG5ldyB1dGlscy5CdWY4KDI1Nik7XG5mb3IgKHZhciBxID0gMDsgcSA8IDI1NjsgcSsrKSB7XG4gIF91dGY4bGVuW3FdID0gKHEgPj0gMjUyID8gNiA6IHEgPj0gMjQ4ID8gNSA6IHEgPj0gMjQwID8gNCA6IHEgPj0gMjI0ID8gMyA6IHEgPj0gMTkyID8gMiA6IDEpO1xufVxuX3V0ZjhsZW5bMjU0XSA9IF91dGY4bGVuWzI1NF0gPSAxOyAvLyBJbnZhbGlkIHNlcXVlbmNlIHN0YXJ0XG5cblxuLy8gY29udmVydCBzdHJpbmcgdG8gYXJyYXkgKHR5cGVkLCB3aGVuIHBvc3NpYmxlKVxuZXhwb3J0cy5zdHJpbmcyYnVmID0gZnVuY3Rpb24gKHN0cikge1xuICB2YXIgYnVmLCBjLCBjMiwgbV9wb3MsIGksIHN0cl9sZW4gPSBzdHIubGVuZ3RoLCBidWZfbGVuID0gMDtcblxuICAvLyBjb3VudCBiaW5hcnkgc2l6ZVxuICBmb3IgKG1fcG9zID0gMDsgbV9wb3MgPCBzdHJfbGVuOyBtX3BvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zICsgMSA8IHN0cl9sZW4pKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtX3BvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBidWZfbGVuICs9IGMgPCAweDgwID8gMSA6IGMgPCAweDgwMCA/IDIgOiBjIDwgMHgxMDAwMCA/IDMgOiA0O1xuICB9XG5cbiAgLy8gYWxsb2NhdGUgYnVmZmVyXG4gIGJ1ZiA9IG5ldyB1dGlscy5CdWY4KGJ1Zl9sZW4pO1xuXG4gIC8vIGNvbnZlcnRcbiAgZm9yIChpID0gMCwgbV9wb3MgPSAwOyBpIDwgYnVmX2xlbjsgbV9wb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcyArIDEgPCBzdHJfbGVuKSkge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbV9wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAvKiBvbmUgYnl0ZSAqL1xuICAgICAgYnVmW2krK10gPSBjO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAvKiB0d28gYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhDMCB8IChjID4+PiA2KTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfSBlbHNlIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgLyogdGhyZWUgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhFMCB8IChjID4+PiAxMik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogZm91ciBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweGYwIHwgKGMgPj4+IDE4KTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiAxMiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1Zjtcbn07XG5cbi8vIEhlbHBlciAodXNlZCBpbiAyIHBsYWNlcylcbmZ1bmN0aW9uIGJ1ZjJiaW5zdHJpbmcoYnVmLCBsZW4pIHtcbiAgLy8gT24gQ2hyb21lLCB0aGUgYXJndW1lbnRzIGluIGEgZnVuY3Rpb24gY2FsbCB0aGF0IGFyZSBhbGxvd2VkIGlzIGA2NTUzNGAuXG4gIC8vIElmIHRoZSBsZW5ndGggb2YgdGhlIGJ1ZmZlciBpcyBzbWFsbGVyIHRoYW4gdGhhdCwgd2UgY2FuIHVzZSB0aGlzIG9wdGltaXphdGlvbixcbiAgLy8gb3RoZXJ3aXNlIHdlIHdpbGwgdGFrZSBhIHNsb3dlciBwYXRoLlxuICBpZiAobGVuIDwgNjU1MzQpIHtcbiAgICBpZiAoKGJ1Zi5zdWJhcnJheSAmJiBTVFJfQVBQTFlfVUlBX09LKSB8fCAoIWJ1Zi5zdWJhcnJheSAmJiBTVFJfQVBQTFlfT0spKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB1dGlscy5zaHJpbmtCdWYoYnVmLCBsZW4pKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuLy8gQ29udmVydCBieXRlIGFycmF5IHRvIGJpbmFyeSBzdHJpbmdcbmV4cG9ydHMuYnVmMmJpbnN0cmluZyA9IGZ1bmN0aW9uIChidWYpIHtcbiAgcmV0dXJuIGJ1ZjJiaW5zdHJpbmcoYnVmLCBidWYubGVuZ3RoKTtcbn07XG5cblxuLy8gQ29udmVydCBiaW5hcnkgc3RyaW5nICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbmV4cG9ydHMuYmluc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGJ1ZiA9IG5ldyB1dGlscy5CdWY4KHN0ci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYnVmW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn07XG5cblxuLy8gY29udmVydCBhcnJheSB0byBzdHJpbmdcbmV4cG9ydHMuYnVmMnN0cmluZyA9IGZ1bmN0aW9uIChidWYsIG1heCkge1xuICB2YXIgaSwgb3V0LCBjLCBjX2xlbjtcbiAgdmFyIGxlbiA9IG1heCB8fCBidWYubGVuZ3RoO1xuXG4gIC8vIFJlc2VydmUgbWF4IHBvc3NpYmxlIGxlbmd0aCAoMiB3b3JkcyBwZXIgY2hhcilcbiAgLy8gTkI6IGJ5IHVua25vd24gcmVhc29ucywgQXJyYXkgaXMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgZm9yXG4gIC8vICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5IHRoYW4gVWludDE2QXJyYXkuXG4gIHZhciB1dGYxNmJ1ZiA9IG5ldyBBcnJheShsZW4gKiAyKTtcblxuICBmb3IgKG91dCA9IDAsIGkgPSAwOyBpIDwgbGVuOykge1xuICAgIGMgPSBidWZbaSsrXTtcbiAgICAvLyBxdWljayBwcm9jZXNzIGFzY2lpXG4gICAgaWYgKGMgPCAweDgwKSB7IHV0ZjE2YnVmW291dCsrXSA9IGM7IGNvbnRpbnVlOyB9XG5cbiAgICBjX2xlbiA9IF91dGY4bGVuW2NdO1xuICAgIC8vIHNraXAgNSAmIDYgYnl0ZSBjb2Rlc1xuICAgIGlmIChjX2xlbiA+IDQpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBpICs9IGNfbGVuIC0gMTsgY29udGludWU7IH1cblxuICAgIC8vIGFwcGx5IG1hc2sgb24gZmlyc3QgYnl0ZVxuICAgIGMgJj0gY19sZW4gPT09IDIgPyAweDFmIDogY19sZW4gPT09IDMgPyAweDBmIDogMHgwNztcbiAgICAvLyBqb2luIHRoZSByZXN0XG4gICAgd2hpbGUgKGNfbGVuID4gMSAmJiBpIDwgbGVuKSB7XG4gICAgICBjID0gKGMgPDwgNikgfCAoYnVmW2krK10gJiAweDNmKTtcbiAgICAgIGNfbGVuLS07XG4gICAgfVxuXG4gICAgLy8gdGVybWluYXRlZCBieSBlbmQgb2Ygc3RyaW5nP1xuICAgIGlmIChjX2xlbiA+IDEpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBjb250aW51ZTsgfVxuXG4gICAgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSBjO1xuICAgIH0gZWxzZSB7XG4gICAgICBjIC09IDB4MTAwMDA7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGQ4MDAgfCAoKGMgPj4gMTApICYgMHgzZmYpO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkYzAwIHwgKGMgJiAweDNmZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZjJiaW5zdHJpbmcodXRmMTZidWYsIG91dCk7XG59O1xuXG5cbi8vIENhbGN1bGF0ZSBtYXggcG9zc2libGUgcG9zaXRpb24gaW4gdXRmOCBidWZmZXIsXG4vLyB0aGF0IHdpbGwgbm90IGJyZWFrIHNlcXVlbmNlLiBJZiB0aGF0J3Mgbm90IHBvc3NpYmxlXG4vLyAtICh2ZXJ5IHNtYWxsIGxpbWl0cykgcmV0dXJuIG1heCBzaXplIGFzIGlzLlxuLy9cbi8vIGJ1ZltdIC0gdXRmOCBieXRlcyBhcnJheVxuLy8gbWF4ICAgLSBsZW5ndGggbGltaXQgKG1hbmRhdG9yeSk7XG5leHBvcnRzLnV0Zjhib3JkZXIgPSBmdW5jdGlvbiAoYnVmLCBtYXgpIHtcbiAgdmFyIHBvcztcblxuICBtYXggPSBtYXggfHwgYnVmLmxlbmd0aDtcbiAgaWYgKG1heCA+IGJ1Zi5sZW5ndGgpIHsgbWF4ID0gYnVmLmxlbmd0aDsgfVxuXG4gIC8vIGdvIGJhY2sgZnJvbSBsYXN0IHBvc2l0aW9uLCB1bnRpbCBzdGFydCBvZiBzZXF1ZW5jZSBmb3VuZFxuICBwb3MgPSBtYXggLSAxO1xuICB3aGlsZSAocG9zID49IDAgJiYgKGJ1Zltwb3NdICYgMHhDMCkgPT09IDB4ODApIHsgcG9zLS07IH1cblxuICAvLyBWZXJ5IHNtYWxsIGFuZCBicm9rZW4gc2VxdWVuY2UsXG4gIC8vIHJldHVybiBtYXgsIGJlY2F1c2Ugd2Ugc2hvdWxkIHJldHVybiBzb21ldGhpbmcgYW55d2F5LlxuICBpZiAocG9zIDwgMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgLy8gSWYgd2UgY2FtZSB0byBzdGFydCBvZiBidWZmZXIgLSB0aGF0IG1lYW5zIGJ1ZmZlciBpcyB0b28gc21hbGwsXG4gIC8vIHJldHVybiBtYXggdG9vLlxuICBpZiAocG9zID09PSAwKSB7IHJldHVybiBtYXg7IH1cblxuICByZXR1cm4gKHBvcyArIF91dGY4bGVuW2J1Zltwb3NdXSA+IG1heCkgPyBwb3MgOiBtYXg7XG59O1xuXG59LHtcIi4vY29tbW9uXCI6NX1dLDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBOb3RlOiBhZGxlcjMyIHRha2VzIDEyJSBmb3IgbGV2ZWwgMCBhbmQgMiUgZm9yIGxldmVsIDYuXG4vLyBJdCBpc24ndCB3b3J0aCBpdCB0byBtYWtlIGFkZGl0aW9uYWwgb3B0aW1pemF0aW9ucyBhcyBpbiBvcmlnaW5hbC5cbi8vIFNtYWxsIHNpemUgaXMgcHJlZmVyYWJsZS5cblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5mdW5jdGlvbiBhZGxlcjMyKGFkbGVyLCBidWYsIGxlbiwgcG9zKSB7XG4gIHZhciBzMSA9IChhZGxlciAmIDB4ZmZmZikgfDAsXG4gICAgICBzMiA9ICgoYWRsZXIgPj4+IDE2KSAmIDB4ZmZmZikgfDAsXG4gICAgICBuID0gMDtcblxuICB3aGlsZSAobGVuICE9PSAwKSB7XG4gICAgLy8gU2V0IGxpbWl0IH4gdHdpY2UgbGVzcyB0aGFuIDU1NTIsIHRvIGtlZXBcbiAgICAvLyBzMiBpbiAzMS1iaXRzLCBiZWNhdXNlIHdlIGZvcmNlIHNpZ25lZCBpbnRzLlxuICAgIC8vIGluIG90aGVyIGNhc2UgJT0gd2lsbCBmYWlsLlxuICAgIG4gPSBsZW4gPiAyMDAwID8gMjAwMCA6IGxlbjtcbiAgICBsZW4gLT0gbjtcblxuICAgIGRvIHtcbiAgICAgIHMxID0gKHMxICsgYnVmW3BvcysrXSkgfDA7XG4gICAgICBzMiA9IChzMiArIHMxKSB8MDtcbiAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgczEgJT0gNjU1MjE7XG4gICAgczIgJT0gNjU1MjE7XG4gIH1cblxuICByZXR1cm4gKHMxIHwgKHMyIDw8IDE2KSkgfDA7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBhZGxlcjMyO1xuXG59LHt9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogd2UgY2FuJ3QgZ2V0IHNpZ25pZmljYW50IHNwZWVkIGJvb3N0IGhlcmUuXG4vLyBTbyB3cml0ZSBjb2RlIHRvIG1pbmltaXplIHNpemUgLSBubyBwcmVnZW5lcmF0ZWQgdGFibGVzXG4vLyBhbmQgYXJyYXkgdG9vbHMgZGVwZW5kZW5jaWVzLlxuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8vIFVzZSBvcmRpbmFyeSBhcnJheSwgc2luY2UgdW50eXBlZCBtYWtlcyBubyBib29zdCBoZXJlXG5mdW5jdGlvbiBtYWtlVGFibGUoKSB7XG4gIHZhciBjLCB0YWJsZSA9IFtdO1xuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgMjU2OyBuKyspIHtcbiAgICBjID0gbjtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IDg7IGsrKykge1xuICAgICAgYyA9ICgoYyAmIDEpID8gKDB4RURCODgzMjAgXiAoYyA+Pj4gMSkpIDogKGMgPj4+IDEpKTtcbiAgICB9XG4gICAgdGFibGVbbl0gPSBjO1xuICB9XG5cbiAgcmV0dXJuIHRhYmxlO1xufVxuXG4vLyBDcmVhdGUgdGFibGUgb24gbG9hZC4gSnVzdCAyNTUgc2lnbmVkIGxvbmdzLiBOb3QgYSBwcm9ibGVtLlxudmFyIGNyY1RhYmxlID0gbWFrZVRhYmxlKCk7XG5cblxuZnVuY3Rpb24gY3JjMzIoY3JjLCBidWYsIGxlbiwgcG9zKSB7XG4gIHZhciB0ID0gY3JjVGFibGUsXG4gICAgICBlbmQgPSBwb3MgKyBsZW47XG5cbiAgY3JjIF49IC0xO1xuXG4gIGZvciAodmFyIGkgPSBwb3M7IGkgPCBlbmQ7IGkrKykge1xuICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdFsoY3JjIF4gYnVmW2ldKSAmIDB4RkZdO1xuICB9XG5cbiAgcmV0dXJuIChjcmMgXiAoLTEpKTsgLy8gPj4+IDA7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBjcmMzMjtcblxufSx7fV0sOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzICAgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcbnZhciB0cmVlcyAgID0gcmVxdWlyZSgnLi90cmVlcycpO1xudmFyIGFkbGVyMzIgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbnZhciBjcmMzMiAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xudmFyIG1zZyAgICAgPSByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbnZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xudmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7XG4vL3ZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xudmFyIFpfRlVMTF9GTFVTSCAgICA9IDM7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcbnZhciBaX0JMT0NLICAgICAgICAgPSA1O1xuLy92YXIgWl9UUkVFUyAgICAgICAgID0gNjtcblxuXG4vKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gKi9cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG4vL3ZhciBaX05FRURfRElDVCAgICAgPSAyO1xuLy92YXIgWl9FUlJOTyAgICAgICAgID0gLTE7XG52YXIgWl9TVFJFQU1fRVJST1IgID0gLTI7XG52YXIgWl9EQVRBX0VSUk9SICAgID0gLTM7XG4vL3ZhciBaX01FTV9FUlJPUiAgICAgPSAtNDtcbnZhciBaX0JVRl9FUlJPUiAgICAgPSAtNTtcbi8vdmFyIFpfVkVSU0lPTl9FUlJPUiA9IC02O1xuXG5cbi8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuLy92YXIgWl9OT19DT01QUkVTU0lPTiAgICAgID0gMDtcbi8vdmFyIFpfQkVTVF9TUEVFRCAgICAgICAgICA9IDE7XG4vL3ZhciBaX0JFU1RfQ09NUFJFU1NJT04gICAgPSA5O1xudmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xO1xuXG5cbnZhciBaX0ZJTFRFUkVEICAgICAgICAgICAgPSAxO1xudmFyIFpfSFVGRk1BTl9PTkxZICAgICAgICA9IDI7XG52YXIgWl9STEUgICAgICAgICAgICAgICAgID0gMztcbnZhciBaX0ZJWEVEICAgICAgICAgICAgICAgPSA0O1xudmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbi8vdmFyIFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG4vL3ZhciBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy92YXIgWl9BU0NJSSAgICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbnZhciBaX1VOS05PV04gICAgICAgICAgICAgPSAyO1xuXG5cbi8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xudmFyIFpfREVGTEFURUQgID0gODtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG52YXIgTUFYX01FTV9MRVZFTCA9IDk7XG4vKiBNYXhpbXVtIHZhbHVlIGZvciBtZW1MZXZlbCBpbiBkZWZsYXRlSW5pdDIgKi9cbnZhciBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xudmFyIERFRl9NRU1fTEVWRUwgPSA4O1xuXG5cbnZhciBMRU5HVEhfQ09ERVMgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cbnZhciBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG52YXIgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xudmFyIERfQ09ERVMgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xudmFyIEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xudmFyIEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xudmFyIE1BWF9CSVRTICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbnZhciBNSU5fTUFUQ0ggPSAzO1xudmFyIE1BWF9NQVRDSCA9IDI1ODtcbnZhciBNSU5fTE9PS0FIRUFEID0gKE1BWF9NQVRDSCArIE1JTl9NQVRDSCArIDEpO1xuXG52YXIgUFJFU0VUX0RJQ1QgPSAweDIwO1xuXG52YXIgSU5JVF9TVEFURSA9IDQyO1xudmFyIEVYVFJBX1NUQVRFID0gNjk7XG52YXIgTkFNRV9TVEFURSA9IDczO1xudmFyIENPTU1FTlRfU1RBVEUgPSA5MTtcbnZhciBIQ1JDX1NUQVRFID0gMTAzO1xudmFyIEJVU1lfU1RBVEUgPSAxMTM7XG52YXIgRklOSVNIX1NUQVRFID0gNjY2O1xuXG52YXIgQlNfTkVFRF9NT1JFICAgICAgPSAxOyAvKiBibG9jayBub3QgY29tcGxldGVkLCBuZWVkIG1vcmUgaW5wdXQgb3IgbW9yZSBvdXRwdXQgKi9cbnZhciBCU19CTE9DS19ET05FICAgICA9IDI7IC8qIGJsb2NrIGZsdXNoIHBlcmZvcm1lZCAqL1xudmFyIEJTX0ZJTklTSF9TVEFSVEVEID0gMzsgLyogZmluaXNoIHN0YXJ0ZWQsIG5lZWQgb25seSBtb3JlIG91dHB1dCBhdCBuZXh0IGRlZmxhdGUgKi9cbnZhciBCU19GSU5JU0hfRE9ORSAgICA9IDQ7IC8qIGZpbmlzaCBkb25lLCBhY2NlcHQgbm8gbW9yZSBpbnB1dCBvciBvdXRwdXQgKi9cblxudmFyIE9TX0NPREUgPSAweDAzOyAvLyBVbml4IDopIC4gRG9uJ3QgZGV0ZWN0LCB1c2UgdGhpcyBkZWZhdWx0LlxuXG5mdW5jdGlvbiBlcnIoc3RybSwgZXJyb3JDb2RlKSB7XG4gIHN0cm0ubXNnID0gbXNnW2Vycm9yQ29kZV07XG4gIHJldHVybiBlcnJvckNvZGU7XG59XG5cbmZ1bmN0aW9uIHJhbmsoZikge1xuICByZXR1cm4gKChmKSA8PCAxKSAtICgoZikgPiA0ID8gOSA6IDApO1xufVxuXG5mdW5jdGlvbiB6ZXJvKGJ1ZikgeyB2YXIgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlLiBBbGwgZGVmbGF0ZSgpIG91dHB1dCBnb2VzXG4gKiB0aHJvdWdoIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0XG4gKiB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+b3V0cHV0IGJ1ZmZlciBhbmQgY29weWluZyBpbnRvIGl0LlxuICogKFNlZSBhbHNvIHJlYWRfYnVmKCkpLlxuICovXG5mdW5jdGlvbiBmbHVzaF9wZW5kaW5nKHN0cm0pIHtcbiAgdmFyIHMgPSBzdHJtLnN0YXRlO1xuXG4gIC8vX3RyX2ZsdXNoX2JpdHMocyk7XG4gIHZhciBsZW4gPSBzLnBlbmRpbmc7XG4gIGlmIChsZW4gPiBzdHJtLmF2YWlsX291dCkge1xuICAgIGxlbiA9IHN0cm0uYXZhaWxfb3V0O1xuICB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHMucGVuZGluZ19idWYsIHMucGVuZGluZ19vdXQsIGxlbiwgc3RybS5uZXh0X291dCk7XG4gIHN0cm0ubmV4dF9vdXQgKz0gbGVuO1xuICBzLnBlbmRpbmdfb3V0ICs9IGxlbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gbGVuO1xuICBzdHJtLmF2YWlsX291dCAtPSBsZW47XG4gIHMucGVuZGluZyAtPSBsZW47XG4gIGlmIChzLnBlbmRpbmcgPT09IDApIHtcbiAgICBzLnBlbmRpbmdfb3V0ID0gMDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGZsdXNoX2Jsb2NrX29ubHkocywgbGFzdCkge1xuICB0cmVlcy5fdHJfZmx1c2hfYmxvY2socywgKHMuYmxvY2tfc3RhcnQgPj0gMCA/IHMuYmxvY2tfc3RhcnQgOiAtMSksIHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0LCBsYXN0KTtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIGZsdXNoX3BlbmRpbmcocy5zdHJtKTtcbn1cblxuXG5mdW5jdGlvbiBwdXRfYnl0ZShzLCBiKSB7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBQdXQgYSBzaG9ydCBpbiB0aGUgcGVuZGluZyBidWZmZXIuIFRoZSAxNi1iaXQgdmFsdWUgaXMgcHV0IGluIE1TQiBvcmRlci5cbiAqIElOIGFzc2VydGlvbjogdGhlIHN0cmVhbSBzdGF0ZSBpcyBjb3JyZWN0IGFuZCB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpblxuICogcGVuZGluZ19idWYuXG4gKi9cbmZ1bmN0aW9uIHB1dFNob3J0TVNCKHMsIGIpIHtcbi8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiA+PiA4KSk7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgJiAweGZmKSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKGIgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiICYgMHhmZjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlYWQgYSBuZXcgYnVmZmVyIGZyb20gdGhlIGN1cnJlbnQgaW5wdXQgc3RyZWFtLCB1cGRhdGUgdGhlIGFkbGVyMzJcbiAqIGFuZCB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC4gIEFsbCBkZWZsYXRlKCkgaW5wdXQgZ29lcyB0aHJvdWdoXG4gKiB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdCB0byBhdm9pZFxuICogYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPmlucHV0IGJ1ZmZlciBhbmQgY29weWluZyBmcm9tIGl0LlxuICogKFNlZSBhbHNvIGZsdXNoX3BlbmRpbmcoKSkuXG4gKi9cbmZ1bmN0aW9uIHJlYWRfYnVmKHN0cm0sIGJ1Ziwgc3RhcnQsIHNpemUpIHtcbiAgdmFyIGxlbiA9IHN0cm0uYXZhaWxfaW47XG5cbiAgaWYgKGxlbiA+IHNpemUpIHsgbGVuID0gc2l6ZTsgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybiAwOyB9XG5cbiAgc3RybS5hdmFpbF9pbiAtPSBsZW47XG5cbiAgLy8gem1lbWNweShidWYsIHN0cm0tPm5leHRfaW4sIGxlbik7XG4gIHV0aWxzLmFycmF5U2V0KGJ1Ziwgc3RybS5pbnB1dCwgc3RybS5uZXh0X2luLCBsZW4sIHN0YXJ0KTtcbiAgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMSkge1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBlbHNlIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDIpIHtcbiAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiArPSBsZW47XG4gIHN0cm0udG90YWxfaW4gKz0gbGVuO1xuXG4gIHJldHVybiBsZW47XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZXQgbWF0Y2hfc3RhcnQgdG8gdGhlIGxvbmdlc3QgbWF0Y2ggc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHN0cmluZyBhbmRcbiAqIHJldHVybiBpdHMgbGVuZ3RoLiBNYXRjaGVzIHNob3J0ZXIgb3IgZXF1YWwgdG8gcHJldl9sZW5ndGggYXJlIGRpc2NhcmRlZCxcbiAqIGluIHdoaWNoIGNhc2UgdGhlIHJlc3VsdCBpcyBlcXVhbCB0byBwcmV2X2xlbmd0aCBhbmQgbWF0Y2hfc3RhcnQgaXNcbiAqIGdhcmJhZ2UuXG4gKiBJTiBhc3NlcnRpb25zOiBjdXJfbWF0Y2ggaXMgdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gZm9yIHRoZSBjdXJyZW50XG4gKiAgIHN0cmluZyAoc3Ryc3RhcnQpIGFuZCBpdHMgZGlzdGFuY2UgaXMgPD0gTUFYX0RJU1QsIGFuZCBwcmV2X2xlbmd0aCA+PSAxXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdCBncmVhdGVyIHRoYW4gcy0+bG9va2FoZWFkLlxuICovXG5mdW5jdGlvbiBsb25nZXN0X21hdGNoKHMsIGN1cl9tYXRjaCkge1xuICB2YXIgY2hhaW5fbGVuZ3RoID0gcy5tYXhfY2hhaW5fbGVuZ3RoOyAgICAgIC8qIG1heCBoYXNoIGNoYWluIGxlbmd0aCAqL1xuICB2YXIgc2NhbiA9IHMuc3Ryc3RhcnQ7IC8qIGN1cnJlbnQgc3RyaW5nICovXG4gIHZhciBtYXRjaDsgICAgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoZWQgc3RyaW5nICovXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgbWF0Y2ggKi9cbiAgdmFyIGJlc3RfbGVuID0gcy5wcmV2X2xlbmd0aDsgICAgICAgICAgICAgIC8qIGJlc3QgbWF0Y2ggbGVuZ3RoIHNvIGZhciAqL1xuICB2YXIgbmljZV9tYXRjaCA9IHMubmljZV9tYXRjaDsgICAgICAgICAgICAgLyogc3RvcCBpZiBtYXRjaCBsb25nIGVub3VnaCAqL1xuICB2YXIgbGltaXQgPSAocy5zdHJzdGFydCA+IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSA/XG4gICAgICBzLnN0cnN0YXJ0IC0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgOiAwLypOSUwqLztcblxuICB2YXIgX3dpbiA9IHMud2luZG93OyAvLyBzaG9ydGN1dFxuXG4gIHZhciB3bWFzayA9IHMud19tYXNrO1xuICB2YXIgcHJldiAgPSBzLnByZXY7XG5cbiAgLyogU3RvcCB3aGVuIGN1cl9tYXRjaCBiZWNvbWVzIDw9IGxpbWl0LiBUbyBzaW1wbGlmeSB0aGUgY29kZSxcbiAgICogd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZyBvZiB3aW5kb3cgaW5kZXggMC5cbiAgICovXG5cbiAgdmFyIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gIHZhciBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgdmFyIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG5cbiAgLyogVGhlIGNvZGUgaXMgb3B0aW1pemVkIGZvciBIQVNIX0JJVFMgPj0gOCBhbmQgTUFYX01BVENILTIgbXVsdGlwbGUgb2YgMTYuXG4gICAqIEl0IGlzIGVhc3kgdG8gZ2V0IHJpZCBvZiB0aGlzIG9wdGltaXphdGlvbiBpZiBuZWNlc3NhcnkuXG4gICAqL1xuICAvLyBBc3NlcnQocy0+aGFzaF9iaXRzID49IDggJiYgTUFYX01BVENIID09IDI1OCwgXCJDb2RlIHRvbyBjbGV2ZXJcIik7XG5cbiAgLyogRG8gbm90IHdhc3RlIHRvbyBtdWNoIHRpbWUgaWYgd2UgYWxyZWFkeSBoYXZlIGEgZ29vZCBtYXRjaDogKi9cbiAgaWYgKHMucHJldl9sZW5ndGggPj0gcy5nb29kX21hdGNoKSB7XG4gICAgY2hhaW5fbGVuZ3RoID4+PSAyO1xuICB9XG4gIC8qIERvIG5vdCBsb29rIGZvciBtYXRjaGVzIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBpbnB1dC4gVGhpcyBpcyBuZWNlc3NhcnlcbiAgICogdG8gbWFrZSBkZWZsYXRlIGRldGVybWluaXN0aWMuXG4gICAqL1xuICBpZiAobmljZV9tYXRjaCA+IHMubG9va2FoZWFkKSB7IG5pY2VfbWF0Y2ggPSBzLmxvb2thaGVhZDsgfVxuXG4gIC8vIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplLU1JTl9MT09LQUhFQUQsIFwibmVlZCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIC8vIEFzc2VydChjdXJfbWF0Y2ggPCBzLT5zdHJzdGFydCwgXCJubyBmdXR1cmVcIik7XG4gICAgbWF0Y2ggPSBjdXJfbWF0Y2g7XG5cbiAgICAvKiBTa2lwIHRvIG5leHQgbWF0Y2ggaWYgdGhlIG1hdGNoIGxlbmd0aCBjYW5ub3QgaW5jcmVhc2VcbiAgICAgKiBvciBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIGxlc3MgdGhhbiAyLiAgTm90ZSB0aGF0IHRoZSBjaGVja3MgYmVsb3dcbiAgICAgKiBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IG9jY3VyIG9jY2FzaW9uYWxseSBmb3IgcGVyZm9ybWFuY2VcbiAgICAgKiByZWFzb25zLiAgVGhlcmVmb3JlIHVuaW5pdGlhbGl6ZWQgbWVtb3J5IHdpbGwgYmUgYWNjZXNzZWQsIGFuZFxuICAgICAqIGNvbmRpdGlvbmFsIGp1bXBzIHdpbGwgYmUgbWFkZSB0aGF0IGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMuXG4gICAgICogSG93ZXZlciB0aGUgbGVuZ3RoIG9mIHRoZSBtYXRjaCBpcyBsaW1pdGVkIHRvIHRoZSBsb29rYWhlYWQsIHNvXG4gICAgICogdGhlIG91dHB1dCBvZiBkZWZsYXRlIGlzIG5vdCBhZmZlY3RlZCBieSB0aGUgdW5pbml0aWFsaXplZCB2YWx1ZXMuXG4gICAgICovXG5cbiAgICBpZiAoX3dpblttYXRjaCArIGJlc3RfbGVuXSAgICAgIT09IHNjYW5fZW5kICB8fFxuICAgICAgICBfd2luW21hdGNoICsgYmVzdF9sZW4gLSAxXSAhPT0gc2Nhbl9lbmQxIHx8XG4gICAgICAgIF93aW5bbWF0Y2hdICAgICAgICAgICAgICAgICE9PSBfd2luW3NjYW5dIHx8XG4gICAgICAgIF93aW5bKyttYXRjaF0gICAgICAgICAgICAgICE9PSBfd2luW3NjYW4gKyAxXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyogVGhlIGNoZWNrIGF0IGJlc3RfbGVuLTEgY2FuIGJlIHJlbW92ZWQgYmVjYXVzZSBpdCB3aWxsIGJlIG1hZGVcbiAgICAgKiBhZ2FpbiBsYXRlci4gKFRoaXMgaGV1cmlzdGljIGlzIG5vdCBhbHdheXMgYSB3aW4uKVxuICAgICAqIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gY29tcGFyZSBzY2FuWzJdIGFuZCBtYXRjaFsyXSBzaW5jZSB0aGV5XG4gICAgICogYXJlIGFsd2F5cyBlcXVhbCB3aGVuIHRoZSBvdGhlciBieXRlcyBtYXRjaCwgZ2l2ZW4gdGhhdFxuICAgICAqIHRoZSBoYXNoIGtleXMgYXJlIGVxdWFsIGFuZCB0aGF0IEhBU0hfQklUUyA+PSA4LlxuICAgICAqL1xuICAgIHNjYW4gKz0gMjtcbiAgICBtYXRjaCsrO1xuICAgIC8vIEFzc2VydCgqc2NhbiA9PSAqbWF0Y2gsIFwibWF0Y2hbMl0/XCIpO1xuXG4gICAgLyogV2UgY2hlY2sgZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBldmVyeSA4dGggY29tcGFyaXNvbjtcbiAgICAgKiB0aGUgMjU2dGggY2hlY2sgd2lsbCBiZSBtYWRlIGF0IHN0cnN0YXJ0KzI1OC5cbiAgICAgKi9cbiAgICBkbyB7XG4gICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICB9IHdoaWxlIChfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG5cbiAgICAvLyBBc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVuc2lnbmVkKShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG5cbiAgICBsZW4gPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgc2NhbiA9IHN0cmVuZCAtIE1BWF9NQVRDSDtcblxuICAgIGlmIChsZW4gPiBiZXN0X2xlbikge1xuICAgICAgcy5tYXRjaF9zdGFydCA9IGN1cl9tYXRjaDtcbiAgICAgIGJlc3RfbGVuID0gbGVuO1xuICAgICAgaWYgKGxlbiA+PSBuaWNlX21hdGNoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gICAgICBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuICAgIH1cbiAgfSB3aGlsZSAoKGN1cl9tYXRjaCA9IHByZXZbY3VyX21hdGNoICYgd21hc2tdKSA+IGxpbWl0ICYmIC0tY2hhaW5fbGVuZ3RoICE9PSAwKTtcblxuICBpZiAoYmVzdF9sZW4gPD0gcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gYmVzdF9sZW47XG4gIH1cbiAgcmV0dXJuIHMubG9va2FoZWFkO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmlsbCB0aGUgd2luZG93IHdoZW4gdGhlIGxvb2thaGVhZCBiZWNvbWVzIGluc3VmZmljaWVudC5cbiAqIFVwZGF0ZXMgc3Ryc3RhcnQgYW5kIGxvb2thaGVhZC5cbiAqXG4gKiBJTiBhc3NlcnRpb246IGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQURcbiAqIE9VVCBhc3NlcnRpb25zOiBzdHJzdGFydCA8PSB3aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFEXG4gKiAgICBBdCBsZWFzdCBvbmUgYnl0ZSBoYXMgYmVlbiByZWFkLCBvciBhdmFpbF9pbiA9PSAwOyByZWFkcyBhcmVcbiAqICAgIHBlcmZvcm1lZCBmb3IgYXQgbGVhc3QgdHdvIGJ5dGVzIChyZXF1aXJlZCBmb3IgdGhlIHppcCB0cmFuc2xhdGVfZW9sXG4gKiAgICBvcHRpb24gLS0gbm90IHN1cHBvcnRlZCBoZXJlKS5cbiAqL1xuZnVuY3Rpb24gZmlsbF93aW5kb3cocykge1xuICB2YXIgX3dfc2l6ZSA9IHMud19zaXplO1xuICB2YXIgcCwgbiwgbSwgbW9yZSwgc3RyO1xuXG4gIC8vQXNzZXJ0KHMtPmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQsIFwiYWxyZWFkeSBlbm91Z2ggbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICBtb3JlID0gcy53aW5kb3dfc2l6ZSAtIHMubG9va2FoZWFkIC0gcy5zdHJzdGFydDtcblxuICAgIC8vIEpTIGludHMgaGF2ZSAzMiBiaXQsIGJsb2NrIGJlbG93IG5vdCBuZWVkZWRcbiAgICAvKiBEZWFsIHdpdGggIUAjJCUgNjRLIGxpbWl0OiAqL1xuICAgIC8vaWYgKHNpemVvZihpbnQpIDw9IDIpIHtcbiAgICAvLyAgICBpZiAobW9yZSA9PSAwICYmIHMtPnN0cnN0YXJ0ID09IDAgJiYgcy0+bG9va2FoZWFkID09IDApIHtcbiAgICAvLyAgICAgICAgbW9yZSA9IHdzaXplO1xuICAgIC8vXG4gICAgLy8gIH0gZWxzZSBpZiAobW9yZSA9PSAodW5zaWduZWQpKC0xKSkge1xuICAgIC8vICAgICAgICAvKiBWZXJ5IHVubGlrZWx5LCBidXQgcG9zc2libGUgb24gMTYgYml0IG1hY2hpbmUgaWZcbiAgICAvLyAgICAgICAgICogc3Ryc3RhcnQgPT0gMCAmJiBsb29rYWhlYWQgPT0gMSAoaW5wdXQgZG9uZSBhIGJ5dGUgYXQgdGltZSlcbiAgICAvLyAgICAgICAgICovXG4gICAgLy8gICAgICAgIG1vcmUtLTtcbiAgICAvLyAgICB9XG4gICAgLy99XG5cblxuICAgIC8qIElmIHRoZSB3aW5kb3cgaXMgYWxtb3N0IGZ1bGwgYW5kIHRoZXJlIGlzIGluc3VmZmljaWVudCBsb29rYWhlYWQsXG4gICAgICogbW92ZSB0aGUgdXBwZXIgaGFsZiB0byB0aGUgbG93ZXIgb25lIHRvIG1ha2Ugcm9vbSBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCA+PSBfd19zaXplICsgKF93X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuXG4gICAgICB1dGlscy5hcnJheVNldChzLndpbmRvdywgcy53aW5kb3csIF93X3NpemUsIF93X3NpemUsIDApO1xuICAgICAgcy5tYXRjaF9zdGFydCAtPSBfd19zaXplO1xuICAgICAgcy5zdHJzdGFydCAtPSBfd19zaXplO1xuICAgICAgLyogd2Ugbm93IGhhdmUgc3Ryc3RhcnQgPj0gTUFYX0RJU1QgKi9cbiAgICAgIHMuYmxvY2tfc3RhcnQgLT0gX3dfc2l6ZTtcblxuICAgICAgLyogU2xpZGUgdGhlIGhhc2ggdGFibGUgKGNvdWxkIGJlIGF2b2lkZWQgd2l0aCAzMiBiaXQgdmFsdWVzXG4gICAgICAgYXQgdGhlIGV4cGVuc2Ugb2YgbWVtb3J5IHVzYWdlKS4gV2Ugc2xpZGUgZXZlbiB3aGVuIGxldmVsID09IDBcbiAgICAgICB0byBrZWVwIHRoZSBoYXNoIHRhYmxlIGNvbnNpc3RlbnQgaWYgd2Ugc3dpdGNoIGJhY2sgdG8gbGV2ZWwgPiAwXG4gICAgICAgbGF0ZXIuIChVc2luZyBsZXZlbCAwIHBlcm1hbmVudGx5IGlzIG5vdCBhbiBvcHRpbWFsIHVzYWdlIG9mXG4gICAgICAgemxpYiwgc28gd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGlzIHBhdGhvbG9naWNhbCBjYXNlLilcbiAgICAgICAqL1xuXG4gICAgICBuID0gcy5oYXNoX3NpemU7XG4gICAgICBwID0gbjtcbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMuaGVhZFstLXBdO1xuICAgICAgICBzLmhlYWRbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG4gPSBfd19zaXplO1xuICAgICAgcCA9IG47XG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLnByZXZbLS1wXTtcbiAgICAgICAgcy5wcmV2W3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICAgIC8qIElmIG4gaXMgbm90IG9uIGFueSBoYXNoIGNoYWluLCBwcmV2W25dIGlzIGdhcmJhZ2UgYnV0XG4gICAgICAgICAqIGl0cyB2YWx1ZSB3aWxsIG5ldmVyIGJlIHVzZWQuXG4gICAgICAgICAqL1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbW9yZSArPSBfd19zaXplO1xuICAgIH1cbiAgICBpZiAocy5zdHJtLmF2YWlsX2luID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvKiBJZiB0aGVyZSB3YXMgbm8gc2xpZGluZzpcbiAgICAgKiAgICBzdHJzdGFydCA8PSBXU0laRStNQVhfRElTVC0xICYmIGxvb2thaGVhZCA8PSBNSU5fTE9PS0FIRUFEIC0gMSAmJlxuICAgICAqICAgIG1vcmUgPT0gd2luZG93X3NpemUgLSBsb29rYWhlYWQgLSBzdHJzdGFydFxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAoTUlOX0xPT0tBSEVBRC0xICsgV1NJWkUgKyBNQVhfRElTVC0xKVxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAyKldTSVpFICsgMlxuICAgICAqIEluIHRoZSBCSUdfTUVNIG9yIE1NQVAgY2FzZSAobm90IHlldCBzdXBwb3J0ZWQpLFxuICAgICAqICAgd2luZG93X3NpemUgPT0gaW5wdXRfc2l6ZSArIE1JTl9MT09LQUhFQUQgICYmXG4gICAgICogICBzdHJzdGFydCArIHMtPmxvb2thaGVhZCA8PSBpbnB1dF9zaXplID0+IG1vcmUgPj0gTUlOX0xPT0tBSEVBRC5cbiAgICAgKiBPdGhlcndpc2UsIHdpbmRvd19zaXplID09IDIqV1NJWkUgc28gbW9yZSA+PSAyLlxuICAgICAqIElmIHRoZXJlIHdhcyBzbGlkaW5nLCBtb3JlID49IFdTSVpFLiBTbyBpbiBhbGwgY2FzZXMsIG1vcmUgPj0gMi5cbiAgICAgKi9cbiAgICAvL0Fzc2VydChtb3JlID49IDIsIFwibW9yZSA8IDJcIik7XG4gICAgbiA9IHJlYWRfYnVmKHMuc3RybSwgcy53aW5kb3csIHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCwgbW9yZSk7XG4gICAgcy5sb29rYWhlYWQgKz0gbjtcblxuICAgIC8qIEluaXRpYWxpemUgdGhlIGhhc2ggdmFsdWUgbm93IHRoYXQgd2UgaGF2ZSBzb21lIGlucHV0OiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0ID49IE1JTl9NQVRDSCkge1xuICAgICAgc3RyID0gcy5zdHJzdGFydCAtIHMuaW5zZXJ0O1xuICAgICAgcy5pbnNfaCA9IHMud2luZG93W3N0cl07XG5cbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgMV0pICYgcy5oYXNoX21hc2s7XG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgIENhbGwgdXBkYXRlX2hhc2goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgd2hpbGUgKHMuaW5zZXJ0KSB7XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG5cbiAgICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgICBzdHIrKztcbiAgICAgICAgcy5pbnNlcnQtLTtcbiAgICAgICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPCBNSU5fTUFUQ0gpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGUgd2hvbGUgaW5wdXQgaGFzIGxlc3MgdGhhbiBNSU5fTUFUQ0ggYnl0ZXMsIGluc19oIGlzIGdhcmJhZ2UsXG4gICAgICogYnV0IHRoaXMgaXMgbm90IGltcG9ydGFudCBzaW5jZSBvbmx5IGxpdGVyYWwgYnl0ZXMgd2lsbCBiZSBlbWl0dGVkLlxuICAgICAqL1xuXG4gIH0gd2hpbGUgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBzLnN0cm0uYXZhaWxfaW4gIT09IDApO1xuXG4gIC8qIElmIHRoZSBXSU5fSU5JVCBieXRlcyBhZnRlciB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGRhdGEgaGF2ZSBuZXZlciBiZWVuXG4gICAqIHdyaXR0ZW4sIHRoZW4gemVybyB0aG9zZSBieXRlcyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgcmVwb3J0cyBvZlxuICAgKiB0aGUgdXNlIG9mIHVuaW5pdGlhbGl6ZWQgKG9yIHVuaW5pdGlhbGlzZWQgYXMgSnVsaWFuIHdyaXRlcykgYnl0ZXMgYnlcbiAgICogdGhlIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMuICBVcGRhdGUgdGhlIGhpZ2ggd2F0ZXIgbWFyayBmb3IgdGhlIG5leHRcbiAgICogdGltZSB0aHJvdWdoIGhlcmUuICBXSU5fSU5JVCBpcyBzZXQgdG8gTUFYX01BVENIIHNpbmNlIHRoZSBsb25nZXN0IG1hdGNoXG4gICAqIHJvdXRpbmVzIGFsbG93IHNjYW5uaW5nIHRvIHN0cnN0YXJ0ICsgTUFYX01BVENILCBpZ25vcmluZyBsb29rYWhlYWQuXG4gICAqL1xuLy8gIGlmIChzLmhpZ2hfd2F0ZXIgPCBzLndpbmRvd19zaXplKSB7XG4vLyAgICB2YXIgY3VyciA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZDtcbi8vICAgIHZhciBpbml0ID0gMDtcbi8vXG4vLyAgICBpZiAocy5oaWdoX3dhdGVyIDwgY3Vycikge1xuLy8gICAgICAvKiBQcmV2aW91cyBoaWdoIHdhdGVyIG1hcmsgYmVsb3cgY3VycmVudCBkYXRhIC0tIHplcm8gV0lOX0lOSVRcbi8vICAgICAgICogYnl0ZXMgb3IgdXAgdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gcy53aW5kb3dfc2l6ZSAtIGN1cnI7XG4vLyAgICAgIGlmIChpbml0ID4gV0lOX0lOSVQpXG4vLyAgICAgICAgaW5pdCA9IFdJTl9JTklUO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBjdXJyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgPSBjdXJyICsgaW5pdDtcbi8vICAgIH1cbi8vICAgIGVsc2UgaWYgKHMtPmhpZ2hfd2F0ZXIgPCAodWxnKWN1cnIgKyBXSU5fSU5JVCkge1xuLy8gICAgICAvKiBIaWdoIHdhdGVyIG1hcmsgYXQgb3IgYWJvdmUgY3VycmVudCBkYXRhLCBidXQgYmVsb3cgY3VycmVudCBkYXRhXG4vLyAgICAgICAqIHBsdXMgV0lOX0lOSVQgLS0gemVybyBvdXQgdG8gY3VycmVudCBkYXRhIHBsdXMgV0lOX0lOSVQsIG9yIHVwXG4vLyAgICAgICAqIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9ICh1bGcpY3VyciArIFdJTl9JTklUIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgaWYgKGluaXQgPiBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXIpXG4vLyAgICAgICAgaW5pdCA9IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgcy0+aGlnaF93YXRlciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyICs9IGluaXQ7XG4vLyAgICB9XG4vLyAgfVxuLy9cbi8vICBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQsXG4vLyAgICBcIm5vdCBlbm91Z2ggcm9vbSBmb3Igc2VhcmNoXCIpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgd2l0aG91dCBjb21wcmVzc2lvbiBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuXG4gKiB0aGUgY3VycmVudCBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgaW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IHNpbmNlXG4gKiB1bmNvbXByZXNzaWJsZSBkYXRhIGlzIHByb2JhYmx5IG5vdCB1c2VmdWwuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZFxuICogb25seSBmb3IgdGhlIGxldmVsPTAgY29tcHJlc3Npb24gb3B0aW9uLlxuICogTk9URTogdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgb3B0aW1pemVkIHRvIGF2b2lkIGV4dHJhIGNvcHlpbmcgZnJvbVxuICogd2luZG93IHRvIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3N0b3JlZChzLCBmbHVzaCkge1xuICAvKiBTdG9yZWQgYmxvY2tzIGFyZSBsaW1pdGVkIHRvIDB4ZmZmZiBieXRlcywgcGVuZGluZ19idWYgaXMgbGltaXRlZFxuICAgKiB0byBwZW5kaW5nX2J1Zl9zaXplLCBhbmQgZWFjaCBzdG9yZWQgYmxvY2sgaGFzIGEgNSBieXRlIGhlYWRlcjpcbiAgICovXG4gIHZhciBtYXhfYmxvY2tfc2l6ZSA9IDB4ZmZmZjtcblxuICBpZiAobWF4X2Jsb2NrX3NpemUgPiBzLnBlbmRpbmdfYnVmX3NpemUgLSA1KSB7XG4gICAgbWF4X2Jsb2NrX3NpemUgPSBzLnBlbmRpbmdfYnVmX3NpemUgLSA1O1xuICB9XG5cbiAgLyogQ29weSBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gaW5wdXQgdG8gb3V0cHV0OiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogRmlsbCB0aGUgd2luZG93IGFzIG11Y2ggYXMgcG9zc2libGU6ICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IDEpIHtcblxuICAgICAgLy9Bc3NlcnQocy0+c3Ryc3RhcnQgPCBzLT53X3NpemUrTUFYX0RJU1QocykgfHxcbiAgICAgIC8vICBzLT5ibG9ja19zdGFydCA+PSAobG9uZylzLT53X3NpemUsIFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIGlmICghKHMuc3Ryc3RhcnQgPCBzLndfc2l6ZSArIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHx8XG4vLyAgICAgICAgcy5ibG9ja19zdGFydCA+PSBzLndfc2l6ZSkpIHtcbi8vICAgICAgICB0aHJvdyAgbmV3IEVycm9yKFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIH1cblxuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDAgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cblxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG4gICAgLy9Bc3NlcnQocy0+YmxvY2tfc3RhcnQgPj0gMEwsIFwiYmxvY2sgZ29uZVwiKTtcbi8vICAgIGlmIChzLmJsb2NrX3N0YXJ0IDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiYmxvY2sgZ29uZVwiKTtcblxuICAgIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gICAgcy5sb29rYWhlYWQgPSAwO1xuXG4gICAgLyogRW1pdCBhIHN0b3JlZCBibG9jayBpZiBwZW5kaW5nX2J1ZiB3aWxsIGJlIGZ1bGw6ICovXG4gICAgdmFyIG1heF9zdGFydCA9IHMuYmxvY2tfc3RhcnQgKyBtYXhfYmxvY2tfc2l6ZTtcblxuICAgIGlmIChzLnN0cnN0YXJ0ID09PSAwIHx8IHMuc3Ryc3RhcnQgPj0gbWF4X3N0YXJ0KSB7XG4gICAgICAvKiBzdHJzdGFydCA9PSAwIGlzIHBvc3NpYmxlIHdoZW4gd3JhcGFyb3VuZCBvbiAxNi1iaXQgbWFjaGluZSAqL1xuICAgICAgcy5sb29rYWhlYWQgPSBzLnN0cnN0YXJ0IC0gbWF4X3N0YXJ0O1xuICAgICAgcy5zdHJzdGFydCA9IG1heF9zdGFydDtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG5cblxuICAgIH1cbiAgICAvKiBGbHVzaCBpZiB3ZSBtYXkgaGF2ZSB0byBzbGlkZSwgb3RoZXJ3aXNlIGJsb2NrX3N0YXJ0IG1heSBiZWNvbWVcbiAgICAgKiBuZWdhdGl2ZSBhbmQgdGhlIGRhdGEgd2lsbCBiZSBnb25lOlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCA+PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cblxuICBzLmluc2VydCA9IDA7XG5cbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG5cbiAgaWYgKHMuc3Ryc3RhcnQgPiBzLmJsb2NrX3N0YXJ0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX05FRURfTU9SRTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wcmVzcyBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuIHRoZSBjdXJyZW50XG4gKiBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcGVyZm9ybSBsYXp5IGV2YWx1YXRpb24gb2YgbWF0Y2hlcyBhbmQgaW5zZXJ0c1xuICogbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgb25seSBmb3IgdW5tYXRjaGVkIHN0cmluZ3Mgb3IgZm9yIHNob3J0XG4gKiBtYXRjaGVzLiBJdCBpcyB1c2VkIG9ubHkgZm9yIHRoZSBmYXN0IGNvbXByZXNzaW9uIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfZmFzdChzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgLyogaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiAqL1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhazsgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKiBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYWx3YXlzIG1hdGNoX2xlbmd0aCA8IE1JTl9NQVRDSFxuICAgICAqL1xuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmICgocy5zdHJzdGFydCAtIGhhc2hfaGVhZCkgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cbiAgICB9XG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy8gY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGgpOyAvLyBmb3IgZGVidWcgb25seVxuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcblxuICAgICAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aFxuICAgICAgICogaXMgbm90IHRvbyBsYXJnZS4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICAgICAqL1xuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IHMubWF4X2xhenlfbWF0Y2gvKm1heF9pbnNlcnRfbGVuZ3RoKi8gJiYgcy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoLS07IC8qIHN0cmluZyBhdCBzdHJzdGFydCBhbHJlYWR5IGluIHRhYmxlICovXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICAgIC8qIHN0cnN0YXJ0IG5ldmVyIGV4Y2VlZHMgV1NJWkUtTUFYX01BVENILCBzbyB0aGVyZSBhcmVcbiAgICAgICAgICAgKiBhbHdheXMgTUlOX01BVENIIGJ5dGVzIGFoZWFkLlxuICAgICAgICAgICAqL1xuICAgICAgICB9IHdoaWxlICgtLXMubWF0Y2hfbGVuZ3RoICE9PSAwKTtcbiAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgfSBlbHNlXG4gICAgICB7XG4gICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAgICAgcy5pbnNfaCA9IHMud2luZG93W3Muc3Ryc3RhcnRdO1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0KzFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgICAgICAgICAgQ2FsbCBVUERBVEVfSEFTSCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICAgIC8qIElmIGxvb2thaGVhZCA8IE1JTl9NQVRDSCwgaW5zX2ggaXMgZ2FyYmFnZSwgYnV0IGl0IGRvZXMgbm90XG4gICAgICAgICAqIG1hdHRlciBzaW5jZSBpdCB3aWxsIGJlIHJlY29tcHV0ZWQgYXQgbmV4dCBkZWZsYXRlIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMud2luZG93W3Muc3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gKChzLnN0cnN0YXJ0IDwgKE1JTl9NQVRDSCAtIDEpKSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxKTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhbWUgYXMgYWJvdmUsIGJ1dCBhY2hpZXZlcyBiZXR0ZXIgY29tcHJlc3Npb24uIFdlIHVzZSBhIGxhenlcbiAqIGV2YWx1YXRpb24gZm9yIG1hdGNoZXM6IGEgbWF0Y2ggaXMgZmluYWxseSBhZG9wdGVkIG9ubHkgaWYgdGhlcmUgaXNcbiAqIG5vIGJldHRlciBtYXRjaCBhdCB0aGUgbmV4dCB3aW5kb3cgcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfc2xvdyhzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgICAvKiBoZWFkIG9mIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIHZhciBtYXhfaW5zZXJ0O1xuXG4gIC8qIFByb2Nlc3MgdGhlIGlucHV0IGJsb2NrLiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICovXG4gICAgcy5wcmV2X2xlbmd0aCA9IHMubWF0Y2hfbGVuZ3RoO1xuICAgIHMucHJldl9tYXRjaCA9IHMubWF0Y2hfc3RhcnQ7XG4gICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgcy5wcmV2X2xlbmd0aCA8IHMubWF4X2xhenlfbWF0Y2ggJiZcbiAgICAgICAgcy5zdHJzdGFydCAtIGhhc2hfaGVhZCA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKS8qTUFYX0RJU1QocykqLykge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG5cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSA1ICYmXG4gICAgICAgICAocy5zdHJhdGVneSA9PT0gWl9GSUxURVJFRCB8fCAocy5tYXRjaF9sZW5ndGggPT09IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCA+IDQwOTYvKlRPT19GQVIqLykpKSB7XG5cbiAgICAgICAgLyogSWYgcHJldl9tYXRjaCBpcyBhbHNvIE1JTl9NQVRDSCwgbWF0Y2hfc3RhcnQgaXMgZ2FyYmFnZVxuICAgICAgICAgKiBidXQgd2Ugd2lsbCBpZ25vcmUgdGhlIGN1cnJlbnQgbWF0Y2ggYW55d2F5LlxuICAgICAgICAgKi9cbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBhdCB0aGUgcHJldmlvdXMgc3RlcCBhbmQgdGhlIGN1cnJlbnRcbiAgICAgKiBtYXRjaCBpcyBub3QgYmV0dGVyLCBvdXRwdXQgdGhlIHByZXZpb3VzIG1hdGNoOlxuICAgICAqL1xuICAgIGlmIChzLnByZXZfbGVuZ3RoID49IE1JTl9NQVRDSCAmJiBzLm1hdGNoX2xlbmd0aCA8PSBzLnByZXZfbGVuZ3RoKSB7XG4gICAgICBtYXhfaW5zZXJ0ID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkIC0gTUlOX01BVENIO1xuICAgICAgLyogRG8gbm90IGluc2VydCBzdHJpbmdzIGluIGhhc2ggdGFibGUgYmV5b25kIHRoaXMuICovXG5cbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydC0xLCBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGgpO1xuXG4gICAgICAvKioqX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgICBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCk7XG4gICAgICAvKiBJbnNlcnQgaW4gaGFzaCB0YWJsZSBhbGwgc3RyaW5ncyB1cCB0byB0aGUgZW5kIG9mIHRoZSBtYXRjaC5cbiAgICAgICAqIHN0cnN0YXJ0LTEgYW5kIHN0cnN0YXJ0IGFyZSBhbHJlYWR5IGluc2VydGVkLiBJZiB0aGVyZSBpcyBub3RcbiAgICAgICAqIGVub3VnaCBsb29rYWhlYWQsIHRoZSBsYXN0IHR3byBzdHJpbmdzIGFyZSBub3QgaW5zZXJ0ZWQgaW5cbiAgICAgICAqIHRoZSBoYXNoIHRhYmxlLlxuICAgICAgICovXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLnByZXZfbGVuZ3RoIC0gMTtcbiAgICAgIHMucHJldl9sZW5ndGggLT0gMjtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKCsrcy5zdHJzdGFydCA8PSBtYXhfaW5zZXJ0KSB7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgtLXMucHJldl9sZW5ndGggIT09IDApO1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICAvKioqL1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgICAgLyogSWYgdGhlcmUgd2FzIG5vIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBwb3NpdGlvbiwgb3V0cHV0IGFcbiAgICAgICAqIHNpbmdsZSBsaXRlcmFsLiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBidXQgdGhlIGN1cnJlbnQgbWF0Y2hcbiAgICAgICAqIGlzIGxvbmdlciwgdHJ1bmNhdGUgdGhlIHByZXZpb3VzIG1hdGNoIHRvIGEgc2luZ2xlIGxpdGVyYWwuXG4gICAgICAgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DS19PTkxZKHMsIDApICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIC8qKiovXG4gICAgICB9XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogVGhlcmUgaXMgbm8gcHJldmlvdXMgbWF0Y2ggdG8gY29tcGFyZSB3aXRoLCB3YWl0IGZvclxuICAgICAgICogdGhlIG5leHQgc3RlcCB0byBkZWNpZGUuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChmbHVzaCAhPSBaX05PX0ZMVVNILCBcIm5vIGZsdXNoP1wiKTtcbiAgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICB9XG4gIHMuaW5zZXJ0ID0gcy5zdHJzdGFydCA8IE1JTl9NQVRDSCAtIDEgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9STEUsIHNpbXBseSBsb29rIGZvciBydW5zIG9mIGJ5dGVzLCBnZW5lcmF0ZSBtYXRjaGVzIG9ubHkgb2YgZGlzdGFuY2VcbiAqIG9uZS4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuICAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZlxuICogZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gWl9STEUuKVxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3JsZShzLCBmbHVzaCkge1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuICB2YXIgcHJldjsgICAgICAgICAgICAgIC8qIGJ5dGUgYXQgZGlzdGFuY2Ugb25lIHRvIG1hdGNoICovXG4gIHZhciBzY2FuLCBzdHJlbmQ7ICAgICAgLyogc2NhbiBnb2VzIHVwIHRvIHN0cmVuZCBmb3IgbGVuZ3RoIG9mIHJ1biAqL1xuXG4gIHZhciBfd2luID0gcy53aW5kb3c7XG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBsb25nZXN0IHJ1biwgcGx1cyBvbmUgZm9yIHRoZSB1bnJvbGxlZCBsb29wLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0gpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogU2VlIGhvdyBtYW55IHRpbWVzIHRoZSBwcmV2aW91cyBieXRlIHJlcGVhdHMgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0ID4gMCkge1xuICAgICAgc2NhbiA9IHMuc3Ryc3RhcnQgLSAxO1xuICAgICAgcHJldiA9IF93aW5bc2Nhbl07XG4gICAgICBpZiAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0pIHtcbiAgICAgICAgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgICAgICB9IHdoaWxlIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoID4gcy5sb29rYWhlYWQpIHtcbiAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IHMubG9va2FoZWFkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChzY2FuIDw9IHMtPndpbmRvdysodUludCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuICAgIH1cblxuICAgIC8qIEVtaXQgbWF0Y2ggaWYgaGF2ZSBydW4gb2YgTUlOX01BVENIIG9yIGxvbmdlciwgZWxzZSBlbWl0IGxpdGVyYWwgKi9cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMuc3Ryc3RhcnQgLSAxLCBzLm1hdGNoX2xlbmd0aCk7XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3QocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX0hVRkZNQU5fT05MWSwgZG8gbm90IGxvb2sgZm9yIG1hdGNoZXMuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLlxuICogKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2YgZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gSHVmZm1hbi4pXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfaHVmZihzLCBmbHVzaCkge1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgaGF2ZSBhIGxpdGVyYWwgdG8gd3JpdGUuICovXG4gICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrOyAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogT3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG4gICAgcy5sb29rYWhlYWQtLTtcbiAgICBzLnN0cnN0YXJ0Kys7XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qIFZhbHVlcyBmb3IgbWF4X2xhenlfbWF0Y2gsIGdvb2RfbWF0Y2ggYW5kIG1heF9jaGFpbl9sZW5ndGgsIGRlcGVuZGluZyBvblxuICogdGhlIGRlc2lyZWQgcGFjayBsZXZlbCAoMC4uOSkuIFRoZSB2YWx1ZXMgZ2l2ZW4gYmVsb3cgaGF2ZSBiZWVuIHR1bmVkIHRvXG4gKiBleGNsdWRlIHdvcnN0IGNhc2UgcGVyZm9ybWFuY2UgZm9yIHBhdGhvbG9naWNhbCBmaWxlcy4gQmV0dGVyIHZhbHVlcyBtYXkgYmVcbiAqIGZvdW5kIGZvciBzcGVjaWZpYyBmaWxlcy5cbiAqL1xuZnVuY3Rpb24gQ29uZmlnKGdvb2RfbGVuZ3RoLCBtYXhfbGF6eSwgbmljZV9sZW5ndGgsIG1heF9jaGFpbiwgZnVuYykge1xuICB0aGlzLmdvb2RfbGVuZ3RoID0gZ29vZF9sZW5ndGg7XG4gIHRoaXMubWF4X2xhenkgPSBtYXhfbGF6eTtcbiAgdGhpcy5uaWNlX2xlbmd0aCA9IG5pY2VfbGVuZ3RoO1xuICB0aGlzLm1heF9jaGFpbiA9IG1heF9jaGFpbjtcbiAgdGhpcy5mdW5jID0gZnVuYztcbn1cblxudmFyIGNvbmZpZ3VyYXRpb25fdGFibGU7XG5cbmNvbmZpZ3VyYXRpb25fdGFibGUgPSBbXG4gIC8qICAgICAgZ29vZCBsYXp5IG5pY2UgY2hhaW4gKi9cbiAgbmV3IENvbmZpZygwLCAwLCAwLCAwLCBkZWZsYXRlX3N0b3JlZCksICAgICAgICAgIC8qIDAgc3RvcmUgb25seSAqL1xuICBuZXcgQ29uZmlnKDQsIDQsIDgsIDQsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAgLyogMSBtYXggc3BlZWQsIG5vIGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDQsIDUsIDE2LCA4LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgLyogMiAqL1xuICBuZXcgQ29uZmlnKDQsIDYsIDMyLCAzMiwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgLyogMyAqL1xuXG4gIG5ldyBDb25maWcoNCwgNCwgMTYsIDE2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgICAvKiA0IGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAzMiwgMzIsIGRlZmxhdGVfc2xvdyksICAgICAgICAgLyogNSAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAxMjgsIDEyOCwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNiAqL1xuICBuZXcgQ29uZmlnKDgsIDMyLCAxMjgsIDI1NiwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNyAqL1xuICBuZXcgQ29uZmlnKDMyLCAxMjgsIDI1OCwgMTAyNCwgZGVmbGF0ZV9zbG93KSwgICAgLyogOCAqL1xuICBuZXcgQ29uZmlnKDMyLCAyNTgsIDI1OCwgNDA5NiwgZGVmbGF0ZV9zbG93KSAgICAgLyogOSBtYXggY29tcHJlc3Npb24gKi9cbl07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSBcImxvbmdlc3QgbWF0Y2hcIiByb3V0aW5lcyBmb3IgYSBuZXcgemxpYiBzdHJlYW1cbiAqL1xuZnVuY3Rpb24gbG1faW5pdChzKSB7XG4gIHMud2luZG93X3NpemUgPSAyICogcy53X3NpemU7XG5cbiAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAvKiBTZXQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzOlxuICAgKi9cbiAgcy5tYXhfbGF6eV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2xhenk7XG4gIHMuZ29vZF9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZ29vZF9sZW5ndGg7XG4gIHMubmljZV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubmljZV9sZW5ndGg7XG4gIHMubWF4X2NoYWluX2xlbmd0aCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2NoYWluO1xuXG4gIHMuc3Ryc3RhcnQgPSAwO1xuICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLmluc2VydCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgcy5pbnNfaCA9IDA7XG59XG5cblxuZnVuY3Rpb24gRGVmbGF0ZVN0YXRlKCkge1xuICB0aGlzLnN0cm0gPSBudWxsOyAgICAgICAgICAgIC8qIHBvaW50ZXIgYmFjayB0byB0aGlzIHpsaWIgc3RyZWFtICovXG4gIHRoaXMuc3RhdHVzID0gMDsgICAgICAgICAgICAvKiBhcyB0aGUgbmFtZSBpbXBsaWVzICovXG4gIHRoaXMucGVuZGluZ19idWYgPSBudWxsOyAgICAgIC8qIG91dHB1dCBzdGlsbCBwZW5kaW5nICovXG4gIHRoaXMucGVuZGluZ19idWZfc2l6ZSA9IDA7ICAvKiBzaXplIG9mIHBlbmRpbmdfYnVmICovXG4gIHRoaXMucGVuZGluZ19vdXQgPSAwOyAgICAgICAvKiBuZXh0IHBlbmRpbmcgYnl0ZSB0byBvdXRwdXQgdG8gdGhlIHN0cmVhbSAqL1xuICB0aGlzLnBlbmRpbmcgPSAwOyAgICAgICAgICAgLyogbmIgb2YgYnl0ZXMgaW4gdGhlIHBlbmRpbmcgYnVmZmVyICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuZ3poZWFkID0gbnVsbDsgICAgICAgICAvKiBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiB0byB3cml0ZSAqL1xuICB0aGlzLmd6aW5kZXggPSAwOyAgICAgICAgICAgLyogd2hlcmUgaW4gZXh0cmEsIG5hbWUsIG9yIGNvbW1lbnQgKi9cbiAgdGhpcy5tZXRob2QgPSBaX0RFRkxBVEVEOyAvKiBjYW4gb25seSBiZSBERUZMQVRFRCAqL1xuICB0aGlzLmxhc3RfZmx1c2ggPSAtMTsgICAvKiB2YWx1ZSBvZiBmbHVzaCBwYXJhbSBmb3IgcHJldmlvdXMgZGVmbGF0ZSBjYWxsICovXG5cbiAgdGhpcy53X3NpemUgPSAwOyAgLyogTFo3NyB3aW5kb3cgc2l6ZSAoMzJLIGJ5IGRlZmF1bHQpICovXG4gIHRoaXMud19iaXRzID0gMDsgIC8qIGxvZzIod19zaXplKSAgKDguLjE2KSAqL1xuICB0aGlzLndfbWFzayA9IDA7ICAvKiB3X3NpemUgLSAxICovXG5cbiAgdGhpcy53aW5kb3cgPSBudWxsO1xuICAvKiBTbGlkaW5nIHdpbmRvdy4gSW5wdXQgYnl0ZXMgYXJlIHJlYWQgaW50byB0aGUgc2Vjb25kIGhhbGYgb2YgdGhlIHdpbmRvdyxcbiAgICogYW5kIG1vdmUgdG8gdGhlIGZpcnN0IGhhbGYgbGF0ZXIgdG8ga2VlcCBhIGRpY3Rpb25hcnkgb2YgYXQgbGVhc3Qgd1NpemVcbiAgICogYnl0ZXMuIFdpdGggdGhpcyBvcmdhbml6YXRpb24sIG1hdGNoZXMgYXJlIGxpbWl0ZWQgdG8gYSBkaXN0YW5jZSBvZlxuICAgKiB3U2l6ZS1NQVhfTUFUQ0ggYnl0ZXMsIGJ1dCB0aGlzIGVuc3VyZXMgdGhhdCBJTyBpcyBhbHdheXNcbiAgICogcGVyZm9ybWVkIHdpdGggYSBsZW5ndGggbXVsdGlwbGUgb2YgdGhlIGJsb2NrIHNpemUuXG4gICAqL1xuXG4gIHRoaXMud2luZG93X3NpemUgPSAwO1xuICAvKiBBY3R1YWwgc2l6ZSBvZiB3aW5kb3c6IDIqd1NpemUsIGV4Y2VwdCB3aGVuIHRoZSB1c2VyIGlucHV0IGJ1ZmZlclxuICAgKiBpcyBkaXJlY3RseSB1c2VkIGFzIHNsaWRpbmcgd2luZG93LlxuICAgKi9cblxuICB0aGlzLnByZXYgPSBudWxsO1xuICAvKiBMaW5rIHRvIG9sZGVyIHN0cmluZyB3aXRoIHNhbWUgaGFzaCBpbmRleC4gVG8gbGltaXQgdGhlIHNpemUgb2YgdGhpc1xuICAgKiBhcnJheSB0byA2NEssIHRoaXMgbGluayBpcyBtYWludGFpbmVkIG9ubHkgZm9yIHRoZSBsYXN0IDMySyBzdHJpbmdzLlxuICAgKiBBbiBpbmRleCBpbiB0aGlzIGFycmF5IGlzIHRodXMgYSB3aW5kb3cgaW5kZXggbW9kdWxvIDMySy5cbiAgICovXG5cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAvKiBIZWFkcyBvZiB0aGUgaGFzaCBjaGFpbnMgb3IgTklMLiAqL1xuXG4gIHRoaXMuaW5zX2ggPSAwOyAgICAgICAvKiBoYXNoIGluZGV4IG9mIHN0cmluZyB0byBiZSBpbnNlcnRlZCAqL1xuICB0aGlzLmhhc2hfc2l6ZSA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIGhhc2ggdGFibGUgKi9cbiAgdGhpcy5oYXNoX2JpdHMgPSAwOyAgIC8qIGxvZzIoaGFzaF9zaXplKSAqL1xuICB0aGlzLmhhc2hfbWFzayA9IDA7ICAgLyogaGFzaF9zaXplLTEgKi9cblxuICB0aGlzLmhhc2hfc2hpZnQgPSAwO1xuICAvKiBOdW1iZXIgb2YgYml0cyBieSB3aGljaCBpbnNfaCBtdXN0IGJlIHNoaWZ0ZWQgYXQgZWFjaCBpbnB1dFxuICAgKiBzdGVwLiBJdCBtdXN0IGJlIHN1Y2ggdGhhdCBhZnRlciBNSU5fTUFUQ0ggc3RlcHMsIHRoZSBvbGRlc3RcbiAgICogYnl0ZSBubyBsb25nZXIgdGFrZXMgcGFydCBpbiB0aGUgaGFzaCBrZXksIHRoYXQgaXM6XG4gICAqICAgaGFzaF9zaGlmdCAqIE1JTl9NQVRDSCA+PSBoYXNoX2JpdHNcbiAgICovXG5cbiAgdGhpcy5ibG9ja19zdGFydCA9IDA7XG4gIC8qIFdpbmRvdyBwb3NpdGlvbiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjdXJyZW50IG91dHB1dCBibG9jay4gR2V0c1xuICAgKiBuZWdhdGl2ZSB3aGVuIHRoZSB3aW5kb3cgaXMgbW92ZWQgYmFja3dhcmRzLlxuICAgKi9cblxuICB0aGlzLm1hdGNoX2xlbmd0aCA9IDA7ICAgICAgLyogbGVuZ3RoIG9mIGJlc3QgbWF0Y2ggKi9cbiAgdGhpcy5wcmV2X21hdGNoID0gMDsgICAgICAgIC8qIHByZXZpb3VzIG1hdGNoICovXG4gIHRoaXMubWF0Y2hfYXZhaWxhYmxlID0gMDsgICAvKiBzZXQgaWYgcHJldmlvdXMgbWF0Y2ggZXhpc3RzICovXG4gIHRoaXMuc3Ryc3RhcnQgPSAwOyAgICAgICAgICAvKiBzdGFydCBvZiBzdHJpbmcgdG8gaW5zZXJ0ICovXG4gIHRoaXMubWF0Y2hfc3RhcnQgPSAwOyAgICAgICAvKiBzdGFydCBvZiBtYXRjaGluZyBzdHJpbmcgKi9cbiAgdGhpcy5sb29rYWhlYWQgPSAwOyAgICAgICAgIC8qIG51bWJlciBvZiB2YWxpZCBieXRlcyBhaGVhZCBpbiB3aW5kb3cgKi9cblxuICB0aGlzLnByZXZfbGVuZ3RoID0gMDtcbiAgLyogTGVuZ3RoIG9mIHRoZSBiZXN0IG1hdGNoIGF0IHByZXZpb3VzIHN0ZXAuIE1hdGNoZXMgbm90IGdyZWF0ZXIgdGhhbiB0aGlzXG4gICAqIGFyZSBkaXNjYXJkZWQuIFRoaXMgaXMgdXNlZCBpbiB0aGUgbGF6eSBtYXRjaCBldmFsdWF0aW9uLlxuICAgKi9cblxuICB0aGlzLm1heF9jaGFpbl9sZW5ndGggPSAwO1xuICAvKiBUbyBzcGVlZCB1cCBkZWZsYXRpb24sIGhhc2ggY2hhaW5zIGFyZSBuZXZlciBzZWFyY2hlZCBiZXlvbmQgdGhpc1xuICAgKiBsZW5ndGguICBBIGhpZ2hlciBsaW1pdCBpbXByb3ZlcyBjb21wcmVzc2lvbiByYXRpbyBidXQgZGVncmFkZXMgdGhlXG4gICAqIHNwZWVkLlxuICAgKi9cblxuICB0aGlzLm1heF9sYXp5X21hdGNoID0gMDtcbiAgLyogQXR0ZW1wdCB0byBmaW5kIGEgYmV0dGVyIG1hdGNoIG9ubHkgd2hlbiB0aGUgY3VycmVudCBtYXRjaCBpcyBzdHJpY3RseVxuICAgKiBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZS4gVGhpcyBtZWNoYW5pc20gaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvblxuICAgKiBsZXZlbHMgPj0gNC5cbiAgICovXG4gIC8vIFRoYXQncyBhbGlhcyB0byBtYXhfbGF6eV9tYXRjaCwgZG9uJ3QgdXNlIGRpcmVjdGx5XG4gIC8vdGhpcy5tYXhfaW5zZXJ0X2xlbmd0aCA9IDA7XG4gIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbm90XG4gICAqIGdyZWF0ZXIgdGhhbiB0aGlzIGxlbmd0aC4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICogbWF4X2luc2VydF9sZW5ndGggaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvbiBsZXZlbHMgPD0gMy5cbiAgICovXG5cbiAgdGhpcy5sZXZlbCA9IDA7ICAgICAvKiBjb21wcmVzc2lvbiBsZXZlbCAoMS4uOSkgKi9cbiAgdGhpcy5zdHJhdGVneSA9IDA7ICAvKiBmYXZvciBvciBmb3JjZSBIdWZmbWFuIGNvZGluZyovXG5cbiAgdGhpcy5nb29kX21hdGNoID0gMDtcbiAgLyogVXNlIGEgZmFzdGVyIHNlYXJjaCB3aGVuIHRoZSBwcmV2aW91cyBtYXRjaCBpcyBsb25nZXIgdGhhbiB0aGlzICovXG5cbiAgdGhpcy5uaWNlX21hdGNoID0gMDsgLyogU3RvcCBzZWFyY2hpbmcgd2hlbiBjdXJyZW50IG1hdGNoIGV4Y2VlZHMgdGhpcyAqL1xuXG4gICAgICAgICAgICAgIC8qIHVzZWQgYnkgdHJlZXMuYzogKi9cblxuICAvKiBEaWRuJ3QgdXNlIGN0X2RhdGEgdHlwZWRlZiBiZWxvdyB0byBzdXBwcmVzcyBjb21waWxlciB3YXJuaW5nICovXG5cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fbHRyZWVbSEVBUF9TSVpFXTsgICAvKiBsaXRlcmFsIGFuZCBsZW5ndGggdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9kdHJlZVsyKkRfQ09ERVMrMV07IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBibF90cmVlWzIqQkxfQ09ERVMrMV07ICAvKiBIdWZmbWFuIHRyZWUgZm9yIGJpdCBsZW5ndGhzICovXG5cbiAgLy8gVXNlIGZsYXQgYXJyYXkgb2YgRE9VQkxFIHNpemUsIHdpdGggaW50ZXJsZWF2ZWQgZmF0YSxcbiAgLy8gYmVjYXVzZSBKUyBkb2VzIG5vdCBzdXBwb3J0IGVmZmVjdGl2ZVxuICB0aGlzLmR5bl9sdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoSEVBUF9TSVpFICogMik7XG4gIHRoaXMuZHluX2R0cmVlICA9IG5ldyB1dGlscy5CdWYxNigoMiAqIERfQ09ERVMgKyAxKSAqIDIpO1xuICB0aGlzLmJsX3RyZWUgICAgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBCTF9DT0RFUyArIDEpICogMik7XG4gIHplcm8odGhpcy5keW5fbHRyZWUpO1xuICB6ZXJvKHRoaXMuZHluX2R0cmVlKTtcbiAgemVybyh0aGlzLmJsX3RyZWUpO1xuXG4gIHRoaXMubF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBsaXRlcmFsIHRyZWUgKi9cbiAgdGhpcy5kX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGRpc3RhbmNlIHRyZWUgKi9cbiAgdGhpcy5ibF9kZXNjICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGJpdCBsZW5ndGggdHJlZSAqL1xuXG4gIC8vdXNoIGJsX2NvdW50W01BWF9CSVRTKzFdO1xuICB0aGlzLmJsX2NvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vaW50IGhlYXBbMipMX0NPREVTKzFdOyAgICAgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB0aGlzLmhlYXAgPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB6ZXJvKHRoaXMuaGVhcCk7XG5cbiAgdGhpcy5oZWFwX2xlbiA9IDA7ICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBoZWFwICovXG4gIHRoaXMuaGVhcF9tYXggPSAwOyAgICAgICAgICAgICAgIC8qIGVsZW1lbnQgb2YgbGFyZ2VzdCBmcmVxdWVuY3kgKi9cbiAgLyogVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS4gaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICogVGhlIHNhbWUgaGVhcCBhcnJheSBpcyB1c2VkIHRvIGJ1aWxkIGFsbCB0cmVlcy5cbiAgICovXG5cbiAgdGhpcy5kZXB0aCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOyAvL3VjaCBkZXB0aFsyKkxfQ09ERVMrMV07XG4gIHplcm8odGhpcy5kZXB0aCk7XG4gIC8qIERlcHRoIG9mIGVhY2ggc3VidHJlZSB1c2VkIGFzIHRpZSBicmVha2VyIGZvciB0cmVlcyBvZiBlcXVhbCBmcmVxdWVuY3lcbiAgICovXG5cbiAgdGhpcy5sX2J1ZiA9IDA7ICAgICAgICAgIC8qIGJ1ZmZlciBpbmRleCBmb3IgbGl0ZXJhbHMgb3IgbGVuZ3RocyAqL1xuXG4gIHRoaXMubGl0X2J1ZnNpemUgPSAwO1xuICAvKiBTaXplIG9mIG1hdGNoIGJ1ZmZlciBmb3IgbGl0ZXJhbHMvbGVuZ3Rocy4gIFRoZXJlIGFyZSA0IHJlYXNvbnMgZm9yXG4gICAqIGxpbWl0aW5nIGxpdF9idWZzaXplIHRvIDY0SzpcbiAgICogICAtIGZyZXF1ZW5jaWVzIGNhbiBiZSBrZXB0IGluIDE2IGJpdCBjb3VudGVyc1xuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIHRoZSBmaXJzdCBibG9jaywgYWxsIGlucHV0XG4gICAqICAgICBkYXRhIGlzIHN0aWxsIGluIHRoZSB3aW5kb3cgc28gd2UgY2FuIHN0aWxsIGVtaXQgYSBzdG9yZWQgYmxvY2sgZXZlblxuICAgKiAgICAgd2hlbiBpbnB1dCBjb21lcyBmcm9tIHN0YW5kYXJkIGlucHV0LiAgKFRoaXMgY2FuIGFsc28gYmUgZG9uZSBmb3JcbiAgICogICAgIGFsbCBibG9ja3MgaWYgbGl0X2J1ZnNpemUgaXMgbm90IGdyZWF0ZXIgdGhhbiAzMksuKVxuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIGEgZmlsZSBzbWFsbGVyIHRoYW4gNjRLLCB3ZSBjYW5cbiAgICogICAgIGV2ZW4gZW1pdCBhIHN0b3JlZCBmaWxlIGluc3RlYWQgb2YgYSBzdG9yZWQgYmxvY2sgKHNhdmluZyA1IGJ5dGVzKS5cbiAgICogICAgIFRoaXMgaXMgYXBwbGljYWJsZSBvbmx5IGZvciB6aXAgKG5vdCBnemlwIG9yIHpsaWIpLlxuICAgKiAgIC0gY3JlYXRpbmcgbmV3IEh1ZmZtYW4gdHJlZXMgbGVzcyBmcmVxdWVudGx5IG1heSBub3QgcHJvdmlkZSBmYXN0XG4gICAqICAgICBhZGFwdGF0aW9uIHRvIGNoYW5nZXMgaW4gdGhlIGlucHV0IGRhdGEgc3RhdGlzdGljcy4gKFRha2UgZm9yXG4gICAqICAgICBleGFtcGxlIGEgYmluYXJ5IGZpbGUgd2l0aCBwb29ybHkgY29tcHJlc3NpYmxlIGNvZGUgZm9sbG93ZWQgYnlcbiAgICogICAgIGEgaGlnaGx5IGNvbXByZXNzaWJsZSBzdHJpbmcgdGFibGUuKSBTbWFsbGVyIGJ1ZmZlciBzaXplcyBnaXZlXG4gICAqICAgICBmYXN0IGFkYXB0YXRpb24gYnV0IGhhdmUgb2YgY291cnNlIHRoZSBvdmVyaGVhZCBvZiB0cmFuc21pdHRpbmdcbiAgICogICAgIHRyZWVzIG1vcmUgZnJlcXVlbnRseS5cbiAgICogICAtIEkgY2FuJ3QgY291bnQgYWJvdmUgNFxuICAgKi9cblxuICB0aGlzLmxhc3RfbGl0ID0gMDsgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG5cbiAgdGhpcy5kX2J1ZiA9IDA7XG4gIC8qIEJ1ZmZlciBpbmRleCBmb3IgZGlzdGFuY2VzLiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgZF9idWYgYW5kIGxfYnVmIGhhdmVcbiAgICogdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLiBUbyB1c2UgZGlmZmVyZW50IGxlbmd0aHMsIGFuIGV4dHJhIGZsYWdcbiAgICogYXJyYXkgd291bGQgYmUgbmVjZXNzYXJ5LlxuICAgKi9cblxuICB0aGlzLm9wdF9sZW4gPSAwOyAgICAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBvcHRpbWFsIHRyZWVzICovXG4gIHRoaXMuc3RhdGljX2xlbiA9IDA7ICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIHN0YXRpYyB0cmVlcyAqL1xuICB0aGlzLm1hdGNoZXMgPSAwOyAgICAgICAvKiBudW1iZXIgb2Ygc3RyaW5nIG1hdGNoZXMgaW4gY3VycmVudCBibG9jayAqL1xuICB0aGlzLmluc2VydCA9IDA7ICAgICAgICAvKiBieXRlcyBhdCBlbmQgb2Ygd2luZG93IGxlZnQgdG8gaW5zZXJ0ICovXG5cblxuICB0aGlzLmJpX2J1ZiA9IDA7XG4gIC8qIE91dHB1dCBidWZmZXIuIGJpdHMgYXJlIGluc2VydGVkIHN0YXJ0aW5nIGF0IHRoZSBib3R0b20gKGxlYXN0XG4gICAqIHNpZ25pZmljYW50IGJpdHMpLlxuICAgKi9cbiAgdGhpcy5iaV92YWxpZCA9IDA7XG4gIC8qIE51bWJlciBvZiB2YWxpZCBiaXRzIGluIGJpX2J1Zi4gIEFsbCBiaXRzIGFib3ZlIHRoZSBsYXN0IHZhbGlkIGJpdFxuICAgKiBhcmUgYWx3YXlzIHplcm8uXG4gICAqL1xuXG4gIC8vIFVzZWQgZm9yIHdpbmRvdyBtZW1vcnkgaW5pdC4gV2Ugc2FmZWx5IGlnbm9yZSBpdCBmb3IgSlMuIFRoYXQgbWFrZXNcbiAgLy8gc2Vuc2Ugb25seSBmb3IgcG9pbnRlcnMgYW5kIG1lbW9yeSBjaGVjayB0b29scy5cbiAgLy90aGlzLmhpZ2hfd2F0ZXIgPSAwO1xuICAvKiBIaWdoIHdhdGVyIG1hcmsgb2Zmc2V0IGluIHdpbmRvdyBmb3IgaW5pdGlhbGl6ZWQgYnl0ZXMgLS0gYnl0ZXMgYWJvdmVcbiAgICogdGhpcyBhcmUgc2V0IHRvIHplcm8gaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHdhcm5pbmdzIHdoZW5cbiAgICogbG9uZ2VzdCBtYXRjaCByb3V0aW5lcyBhY2Nlc3MgYnl0ZXMgcGFzdCB0aGUgaW5wdXQuICBUaGlzIGlzIHRoZW5cbiAgICogdXBkYXRlZCB0byB0aGUgbmV3IGhpZ2ggd2F0ZXIgbWFyay5cbiAgICovXG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKSB7XG4gIHZhciBzO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gMDtcbiAgc3RybS5kYXRhX3R5cGUgPSBaX1VOS05PV047XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG4gIHMucGVuZGluZyA9IDA7XG4gIHMucGVuZGluZ19vdXQgPSAwO1xuXG4gIGlmIChzLndyYXAgPCAwKSB7XG4gICAgcy53cmFwID0gLXMud3JhcDtcbiAgICAvKiB3YXMgbWFkZSBuZWdhdGl2ZSBieSBkZWZsYXRlKC4uLiwgWl9GSU5JU0gpOyAqL1xuICB9XG4gIHMuc3RhdHVzID0gKHMud3JhcCA/IElOSVRfU1RBVEUgOiBCVVNZX1NUQVRFKTtcbiAgc3RybS5hZGxlciA9IChzLndyYXAgPT09IDIpID9cbiAgICAwICAvLyBjcmMzMigwLCBaX05VTEwsIDApXG4gIDpcbiAgICAxOyAvLyBhZGxlcjMyKDAsIFpfTlVMTCwgMClcbiAgcy5sYXN0X2ZsdXNoID0gWl9OT19GTFVTSDtcbiAgdHJlZXMuX3RyX2luaXQocyk7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldChzdHJtKSB7XG4gIHZhciByZXQgPSBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuICBpZiAocmV0ID09PSBaX09LKSB7XG4gICAgbG1faW5pdChzdHJtLnN0YXRlKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVTZXRIZWFkZXIoc3RybSwgaGVhZCkge1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgIT09IDIpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0cm0uc3RhdGUuZ3poZWFkID0gaGVhZDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBtZXRob2QsIHdpbmRvd0JpdHMsIG1lbUxldmVsLCBzdHJhdGVneSkge1xuICBpZiAoIXN0cm0pIHsgLy8gPT09IFpfTlVMTFxuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICB2YXIgd3JhcCA9IDE7XG5cbiAgaWYgKGxldmVsID09PSBaX0RFRkFVTFRfQ09NUFJFU1NJT04pIHtcbiAgICBsZXZlbCA9IDY7XG4gIH1cblxuICBpZiAod2luZG93Qml0cyA8IDApIHsgLyogc3VwcHJlc3MgemxpYiB3cmFwcGVyICovXG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAod2luZG93Qml0cyA+IDE1KSB7XG4gICAgd3JhcCA9IDI7ICAgICAgICAgICAvKiB3cml0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCAqL1xuICAgIHdpbmRvd0JpdHMgLT0gMTY7XG4gIH1cblxuXG4gIGlmIChtZW1MZXZlbCA8IDEgfHwgbWVtTGV2ZWwgPiBNQVhfTUVNX0xFVkVMIHx8IG1ldGhvZCAhPT0gWl9ERUZMQVRFRCB8fFxuICAgIHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSB8fCBsZXZlbCA8IDAgfHwgbGV2ZWwgPiA5IHx8XG4gICAgc3RyYXRlZ3kgPCAwIHx8IHN0cmF0ZWd5ID4gWl9GSVhFRCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cblxuICBpZiAod2luZG93Qml0cyA9PT0gOCkge1xuICAgIHdpbmRvd0JpdHMgPSA5O1xuICB9XG4gIC8qIHVudGlsIDI1Ni1ieXRlIHdpbmRvdyBidWcgZml4ZWQgKi9cblxuICB2YXIgcyA9IG5ldyBEZWZsYXRlU3RhdGUoKTtcblxuICBzdHJtLnN0YXRlID0gcztcbiAgcy5zdHJtID0gc3RybTtcblxuICBzLndyYXAgPSB3cmFwO1xuICBzLmd6aGVhZCA9IG51bGw7XG4gIHMud19iaXRzID0gd2luZG93Qml0cztcbiAgcy53X3NpemUgPSAxIDw8IHMud19iaXRzO1xuICBzLndfbWFzayA9IHMud19zaXplIC0gMTtcblxuICBzLmhhc2hfYml0cyA9IG1lbUxldmVsICsgNztcbiAgcy5oYXNoX3NpemUgPSAxIDw8IHMuaGFzaF9iaXRzO1xuICBzLmhhc2hfbWFzayA9IHMuaGFzaF9zaXplIC0gMTtcbiAgcy5oYXNoX3NoaWZ0ID0gfn4oKHMuaGFzaF9iaXRzICsgTUlOX01BVENIIC0gMSkgLyBNSU5fTUFUQ0gpO1xuXG4gIHMud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUgKiAyKTtcbiAgcy5oZWFkID0gbmV3IHV0aWxzLkJ1ZjE2KHMuaGFzaF9zaXplKTtcbiAgcy5wcmV2ID0gbmV3IHV0aWxzLkJ1ZjE2KHMud19zaXplKTtcblxuICAvLyBEb24ndCBuZWVkIG1lbSBpbml0IG1hZ2ljIGZvciBKUy5cbiAgLy9zLmhpZ2hfd2F0ZXIgPSAwOyAgLyogbm90aGluZyB3cml0dGVuIHRvIHMtPndpbmRvdyB5ZXQgKi9cblxuICBzLmxpdF9idWZzaXplID0gMSA8PCAobWVtTGV2ZWwgKyA2KTsgLyogMTZLIGVsZW1lbnRzIGJ5IGRlZmF1bHQgKi9cblxuICBzLnBlbmRpbmdfYnVmX3NpemUgPSBzLmxpdF9idWZzaXplICogNDtcblxuICAvL292ZXJsYXkgPSAodXNoZiAqKSBaQUxMT0Moc3RybSwgcy0+bGl0X2J1ZnNpemUsIHNpemVvZih1c2gpKzIpO1xuICAvL3MtPnBlbmRpbmdfYnVmID0gKHVjaGYgKikgb3ZlcmxheTtcbiAgcy5wZW5kaW5nX2J1ZiA9IG5ldyB1dGlscy5CdWY4KHMucGVuZGluZ19idWZfc2l6ZSk7XG5cbiAgLy8gSXQgaXMgb2Zmc2V0IGZyb20gYHMucGVuZGluZ19idWZgIChzaXplIGlzIGBzLmxpdF9idWZzaXplICogMmApXG4gIC8vcy0+ZF9idWYgPSBvdmVybGF5ICsgcy0+bGl0X2J1ZnNpemUvc2l6ZW9mKHVzaCk7XG4gIHMuZF9idWYgPSAxICogcy5saXRfYnVmc2l6ZTtcblxuICAvL3MtPmxfYnVmID0gcy0+cGVuZGluZ19idWYgKyAoMStzaXplb2YodXNoKSkqcy0+bGl0X2J1ZnNpemU7XG4gIHMubF9idWYgPSAoMSArIDIpICogcy5saXRfYnVmc2l6ZTtcblxuICBzLmxldmVsID0gbGV2ZWw7XG4gIHMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgcy5tZXRob2QgPSBtZXRob2Q7XG5cbiAgcmV0dXJuIGRlZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQoc3RybSwgbGV2ZWwpIHtcbiAgcmV0dXJuIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgWl9ERUZMQVRFRCwgTUFYX1dCSVRTLCBERUZfTUVNX0xFVkVMLCBaX0RFRkFVTFRfU1RSQVRFR1kpO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGUoc3RybSwgZmx1c2gpIHtcbiAgdmFyIG9sZF9mbHVzaCwgcztcbiAgdmFyIGJlZywgdmFsOyAvLyBmb3IgZ3ppcCBoZWFkZXIgd3JpdGUgb25seVxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fFxuICAgIGZsdXNoID4gWl9CTE9DSyB8fCBmbHVzaCA8IDApIHtcbiAgICByZXR1cm4gc3RybSA/IGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUikgOiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHMgPSBzdHJtLnN0YXRlO1xuXG4gIGlmICghc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB8fFxuICAgICAgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgZmx1c2ggIT09IFpfRklOSVNIKSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSA/IFpfQlVGX0VSUk9SIDogWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgcy5zdHJtID0gc3RybTsgLyoganVzdCBpbiBjYXNlICovXG4gIG9sZF9mbHVzaCA9IHMubGFzdF9mbHVzaDtcbiAgcy5sYXN0X2ZsdXNoID0gZmx1c2g7XG5cbiAgLyogV3JpdGUgdGhlIGhlYWRlciAqL1xuICBpZiAocy5zdGF0dXMgPT09IElOSVRfU1RBVEUpIHtcblxuICAgIGlmIChzLndyYXAgPT09IDIpIHsgLy8gR1pJUCBoZWFkZXJcbiAgICAgIHN0cm0uYWRsZXIgPSAwOyAgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgIHB1dF9ieXRlKHMsIDMxKTtcbiAgICAgIHB1dF9ieXRlKHMsIDEzOSk7XG4gICAgICBwdXRfYnl0ZShzLCA4KTtcbiAgICAgIGlmICghcy5nemhlYWQpIHsgLy8gcy0+Z3poZWFkID09IFpfTlVMTFxuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgT1NfQ09ERSk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGV4dCA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzLmd6aGVhZC5oY3JjID8gMiA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5leHRyYSA/IDAgOiA0KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQubmFtZSA/IDAgOiA4KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuY29tbWVudCA/IDAgOiAxNilcbiAgICAgICAgKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAxNikgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMjQpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQub3MgJiAweGZmKTtcbiAgICAgICAgaWYgKHMuZ3poZWFkLmV4dHJhICYmIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmYpO1xuICAgICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC5leHRyYS5sZW5ndGggPj4gOCkgJiAweGZmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcsIDApO1xuICAgICAgICB9XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gRVhUUkFfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgLy8gREVGTEFURSBoZWFkZXJcbiAgICB7XG4gICAgICB2YXIgaGVhZGVyID0gKFpfREVGTEFURUQgKyAoKHMud19iaXRzIC0gOCkgPDwgNCkpIDw8IDg7XG4gICAgICB2YXIgbGV2ZWxfZmxhZ3MgPSAtMTtcblxuICAgICAgaWYgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsIDwgNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPT09IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAzO1xuICAgICAgfVxuICAgICAgaGVhZGVyIHw9IChsZXZlbF9mbGFncyA8PCA2KTtcbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7IGhlYWRlciB8PSBQUkVTRVRfRElDVDsgfVxuICAgICAgaGVhZGVyICs9IDMxIC0gKGhlYWRlciAlIDMxKTtcblxuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgcHV0U2hvcnRNU0IocywgaGVhZGVyKTtcblxuICAgICAgLyogU2F2ZSB0aGUgYWRsZXIzMiBvZiB0aGUgcHJlc2V0IGRpY3Rpb25hcnk6ICovXG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkge1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICAgICAgfVxuICAgICAgc3RybS5hZGxlciA9IDE7IC8vIGFkbGVyMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgfVxuICB9XG5cbi8vI2lmZGVmIEdaSVBcbiAgaWYgKHMuc3RhdHVzID09PSBFWFRSQV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5leHRyYS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG5cbiAgICAgIHdoaWxlIChzLmd6aW5kZXggPCAocy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZmZmKSkge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhW3MuZ3ppbmRleF0gJiAweGZmKTtcbiAgICAgICAgcy5nemluZGV4Kys7XG4gICAgICB9XG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aW5kZXggPT09IHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IE5BTUVfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQubmFtZS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLm5hbWUubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQubmFtZS5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gQ09NTUVOVF9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5jb21tZW50LyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQuY29tbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5jb21tZW50LmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBIQ1JDX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyID4gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICB9XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA8PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBzdHJtLmFkbGVyID0gMDsgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICB9XG4gIH1cbi8vI2VuZGlmXG5cbiAgLyogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZSAqL1xuICBpZiAocy5wZW5kaW5nICE9PSAwKSB7XG4gICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIC8qIFNpbmNlIGF2YWlsX291dCBpcyAwLCBkZWZsYXRlIHdpbGwgYmUgY2FsbGVkIGFnYWluIHdpdGhcbiAgICAgICAqIG1vcmUgb3V0cHV0IHNwYWNlLCBidXQgcG9zc2libHkgd2l0aCBib3RoIHBlbmRpbmcgYW5kXG4gICAgICAgKiBhdmFpbF9pbiBlcXVhbCB0byB6ZXJvLiBUaGVyZSB3b24ndCBiZSBhbnl0aGluZyB0byBkbyxcbiAgICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBhbiBlcnJvciBzaXR1YXRpb24gc28gbWFrZSBzdXJlIHdlXG4gICAgICAgKiByZXR1cm4gT0sgaW5zdGVhZCBvZiBCVUZfRVJST1IgYXQgbmV4dCBjYWxsIG9mIGRlZmxhdGU6XG4gICAgICAgKi9cbiAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgfVxuXG4gICAgLyogTWFrZSBzdXJlIHRoZXJlIGlzIHNvbWV0aGluZyB0byBkbyBhbmQgYXZvaWQgZHVwbGljYXRlIGNvbnNlY3V0aXZlXG4gICAgICogZmx1c2hlcy4gRm9yIHJlcGVhdGVkIGFuZCB1c2VsZXNzIGNhbGxzIHdpdGggWl9GSU5JU0gsIHdlIGtlZXBcbiAgICAgKiByZXR1cm5pbmcgWl9TVFJFQU1fRU5EIGluc3RlYWQgb2YgWl9CVUZfRVJST1IuXG4gICAgICovXG4gIH0gZWxzZSBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiByYW5rKGZsdXNoKSA8PSByYW5rKG9sZF9mbHVzaCkgJiZcbiAgICBmbHVzaCAhPT0gWl9GSU5JU0gpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFVzZXIgbXVzdCBub3QgcHJvdmlkZSBtb3JlIGlucHV0IGFmdGVyIHRoZSBmaXJzdCBGSU5JU0g6ICovXG4gIGlmIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFN0YXJ0IGEgbmV3IGJsb2NrIG9yIGNvbnRpbnVlIHRoZSBjdXJyZW50IG9uZS5cbiAgICovXG4gIGlmIChzdHJtLmF2YWlsX2luICE9PSAwIHx8IHMubG9va2FoZWFkICE9PSAwIHx8XG4gICAgKGZsdXNoICE9PSBaX05PX0ZMVVNIICYmIHMuc3RhdHVzICE9PSBGSU5JU0hfU1RBVEUpKSB7XG4gICAgdmFyIGJzdGF0ZSA9IChzLnN0cmF0ZWd5ID09PSBaX0hVRkZNQU5fT05MWSkgPyBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIDpcbiAgICAgIChzLnN0cmF0ZWd5ID09PSBaX1JMRSA/IGRlZmxhdGVfcmxlKHMsIGZsdXNoKSA6XG4gICAgICAgIGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZnVuYyhzLCBmbHVzaCkpO1xuXG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfRE9ORSkge1xuICAgICAgcy5zdGF0dXMgPSBGSU5JU0hfU1RBVEU7XG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX05FRURfTU9SRSB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEKSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICAgIC8qIGF2b2lkIEJVRl9FUlJPUiBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgfVxuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICAvKiBJZiBmbHVzaCAhPSBaX05PX0ZMVVNIICYmIGF2YWlsX291dCA9PSAwLCB0aGUgbmV4dCBjYWxsXG4gICAgICAgKiBvZiBkZWZsYXRlIHNob3VsZCB1c2UgdGhlIHNhbWUgZmx1c2ggcGFyYW1ldGVyIHRvIG1ha2Ugc3VyZVxuICAgICAgICogdGhhdCB0aGUgZmx1c2ggaXMgY29tcGxldGUuIFNvIHdlIGRvbid0IGhhdmUgdG8gb3V0cHV0IGFuXG4gICAgICAgKiBlbXB0eSBibG9jayBoZXJlLCB0aGlzIHdpbGwgYmUgZG9uZSBhdCBuZXh0IGNhbGwuIFRoaXMgYWxzb1xuICAgICAgICogZW5zdXJlcyB0aGF0IGZvciBhIHZlcnkgc21hbGwgb3V0cHV0IGJ1ZmZlciwgd2UgZW1pdCBhdCBtb3N0XG4gICAgICAgKiBvbmUgZW1wdHkgYmxvY2suXG4gICAgICAgKi9cbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfQkxPQ0tfRE9ORSkge1xuICAgICAgaWYgKGZsdXNoID09PSBaX1BBUlRJQUxfRkxVU0gpIHtcbiAgICAgICAgdHJlZXMuX3RyX2FsaWduKHMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmx1c2ggIT09IFpfQkxPQ0spIHsgLyogRlVMTF9GTFVTSCBvciBTWU5DX0ZMVVNIICovXG5cbiAgICAgICAgdHJlZXMuX3RyX3N0b3JlZF9ibG9jayhzLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgIC8qIEZvciBhIGZ1bGwgZmx1c2gsIHRoaXMgZW1wdHkgYmxvY2sgd2lsbCBiZSByZWNvZ25pemVkXG4gICAgICAgICAqIGFzIGEgc3BlY2lhbCBtYXJrZXIgYnkgaW5mbGF0ZV9zeW5jKCkuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfRlVMTF9GTFVTSCkge1xuICAgICAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqLyAgICAgICAgICAgICAvKiBmb3JnZXQgaGlzdG9yeSAqL1xuICAgICAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7IC8qIGF2b2lkIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgICByZXR1cm4gWl9PSztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQoc3RybS0+YXZhaWxfb3V0ID4gMCwgXCJidWcyXCIpO1xuICAvL2lmIChzdHJtLmF2YWlsX291dCA8PSAwKSB7IHRocm93IG5ldyBFcnJvcihcImJ1ZzJcIik7fVxuXG4gIGlmIChmbHVzaCAhPT0gWl9GSU5JU0gpIHsgcmV0dXJuIFpfT0s7IH1cbiAgaWYgKHMud3JhcCA8PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FTkQ7IH1cblxuICAvKiBXcml0ZSB0aGUgdHJhaWxlciAqL1xuICBpZiAocy53cmFwID09PSAyKSB7XG4gICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMjQpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMjQpICYgMHhmZik7XG4gIH1cbiAgZWxzZVxuICB7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICB9XG5cbiAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgLyogSWYgYXZhaWxfb3V0IGlzIHplcm8sIHRoZSBhcHBsaWNhdGlvbiB3aWxsIGNhbGwgZGVmbGF0ZSBhZ2FpblxuICAgKiB0byBmbHVzaCB0aGUgcmVzdC5cbiAgICovXG4gIGlmIChzLndyYXAgPiAwKSB7IHMud3JhcCA9IC1zLndyYXA7IH1cbiAgLyogd3JpdGUgdGhlIHRyYWlsZXIgb25seSBvbmNlISAqL1xuICByZXR1cm4gcy5wZW5kaW5nICE9PSAwID8gWl9PSyA6IFpfU1RSRUFNX0VORDtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUVuZChzdHJtKSB7XG4gIHZhciBzdGF0dXM7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzdGF0dXMgPSBzdHJtLnN0YXRlLnN0YXR1cztcbiAgaWYgKHN0YXR1cyAhPT0gSU5JVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRVhUUkFfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IE5BTUVfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IENPTU1FTlRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEhDUkNfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEJVU1lfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEZJTklTSF9TVEFURVxuICApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuXG4gIHJldHVybiBzdGF0dXMgPT09IEJVU1lfU1RBVEUgPyBlcnIoc3RybSwgWl9EQVRBX0VSUk9SKSA6IFpfT0s7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbXByZXNzaW9uIGRpY3Rpb25hcnkgZnJvbSB0aGUgZ2l2ZW4gYnl0ZVxuICogc2VxdWVuY2Ugd2l0aG91dCBwcm9kdWNpbmcgYW55IGNvbXByZXNzZWQgb3V0cHV0LlxuICovXG5mdW5jdGlvbiBkZWZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7XG4gIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgdmFyIHM7XG4gIHZhciBzdHIsIG47XG4gIHZhciB3cmFwO1xuICB2YXIgYXZhaWw7XG4gIHZhciBuZXh0O1xuICB2YXIgaW5wdXQ7XG4gIHZhciB0bXBEaWN0O1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG4gIHdyYXAgPSBzLndyYXA7XG5cbiAgaWYgKHdyYXAgPT09IDIgfHwgKHdyYXAgPT09IDEgJiYgcy5zdGF0dXMgIT09IElOSVRfU1RBVEUpIHx8IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgLyogd2hlbiB1c2luZyB6bGliIHdyYXBwZXJzLCBjb21wdXRlIEFkbGVyLTMyIGZvciBwcm92aWRlZCBkaWN0aW9uYXJ5ICovXG4gIGlmICh3cmFwID09PSAxKSB7XG4gICAgLyogYWRsZXIzMihzdHJtLT5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gIH1cblxuICBzLndyYXAgPSAwOyAgIC8qIGF2b2lkIGNvbXB1dGluZyBBZGxlci0zMiBpbiByZWFkX2J1ZiAqL1xuXG4gIC8qIGlmIGRpY3Rpb25hcnkgd291bGQgZmlsbCB3aW5kb3csIGp1c3QgcmVwbGFjZSB0aGUgaGlzdG9yeSAqL1xuICBpZiAoZGljdExlbmd0aCA+PSBzLndfc2l6ZSkge1xuICAgIGlmICh3cmFwID09PSAwKSB7ICAgICAgICAgICAgLyogYWxyZWFkeSBlbXB0eSBvdGhlcndpc2UgKi9cbiAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICB9XG4gICAgLyogdXNlIHRoZSB0YWlsICovXG4gICAgLy8gZGljdGlvbmFyeSA9IGRpY3Rpb25hcnkuc2xpY2UoZGljdExlbmd0aCAtIHMud19zaXplKTtcbiAgICB0bXBEaWN0ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUpO1xuICAgIHV0aWxzLmFycmF5U2V0KHRtcERpY3QsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGggLSBzLndfc2l6ZSwgcy53X3NpemUsIDApO1xuICAgIGRpY3Rpb25hcnkgPSB0bXBEaWN0O1xuICAgIGRpY3RMZW5ndGggPSBzLndfc2l6ZTtcbiAgfVxuICAvKiBpbnNlcnQgZGljdGlvbmFyeSBpbnRvIHdpbmRvdyBhbmQgaGFzaCAqL1xuICBhdmFpbCA9IHN0cm0uYXZhaWxfaW47XG4gIG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGRpY3RMZW5ndGg7XG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uaW5wdXQgPSBkaWN0aW9uYXJ5O1xuICBmaWxsX3dpbmRvdyhzKTtcbiAgd2hpbGUgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgIHN0ciA9IHMuc3Ryc3RhcnQ7XG4gICAgbiA9IHMubG9va2FoZWFkIC0gKE1JTl9NQVRDSCAtIDEpO1xuICAgIGRvIHtcbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4gICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuXG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICBzdHIrKztcbiAgICB9IHdoaWxlICgtLW4pO1xuICAgIHMuc3Ryc3RhcnQgPSBzdHI7XG4gICAgcy5sb29rYWhlYWQgPSBNSU5fTUFUQ0ggLSAxO1xuICAgIGZpbGxfd2luZG93KHMpO1xuICB9XG4gIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBzLmluc2VydCA9IHMubG9va2FoZWFkO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5pbnB1dCA9IGlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gYXZhaWw7XG4gIHMud3JhcCA9IHdyYXA7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmV4cG9ydHMuZGVmbGF0ZUluaXQgPSBkZWZsYXRlSW5pdDtcbmV4cG9ydHMuZGVmbGF0ZUluaXQyID0gZGVmbGF0ZUluaXQyO1xuZXhwb3J0cy5kZWZsYXRlUmVzZXQgPSBkZWZsYXRlUmVzZXQ7XG5leHBvcnRzLmRlZmxhdGVSZXNldEtlZXAgPSBkZWZsYXRlUmVzZXRLZWVwO1xuZXhwb3J0cy5kZWZsYXRlU2V0SGVhZGVyID0gZGVmbGF0ZVNldEhlYWRlcjtcbmV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGVFbmQgPSBkZWZsYXRlRW5kO1xuZXhwb3J0cy5kZWZsYXRlU2V0RGljdGlvbmFyeSA9IGRlZmxhdGVTZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5kZWZsYXRlSW5mbyA9ICdwYWtvIGRlZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5leHBvcnRzLmRlZmxhdGVCb3VuZCA9IGRlZmxhdGVCb3VuZDtcbmV4cG9ydHMuZGVmbGF0ZUNvcHkgPSBkZWZsYXRlQ29weTtcbmV4cG9ydHMuZGVmbGF0ZVBhcmFtcyA9IGRlZmxhdGVQYXJhbXM7XG5leHBvcnRzLmRlZmxhdGVQZW5kaW5nID0gZGVmbGF0ZVBlbmRpbmc7XG5leHBvcnRzLmRlZmxhdGVQcmltZSA9IGRlZmxhdGVQcmltZTtcbmV4cG9ydHMuZGVmbGF0ZVR1bmUgPSBkZWZsYXRlVHVuZTtcbiovXG5cbn0se1wiLi4vdXRpbHMvY29tbW9uXCI6NSxcIi4vYWRsZXIzMlwiOjcsXCIuL2NyYzMyXCI6OCxcIi4vbWVzc2FnZXNcIjoxMCxcIi4vdHJlZXNcIjoxMX1dLDEwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgMjogICAgICAnbmVlZCBkaWN0aW9uYXJ5JywgICAgIC8qIFpfTkVFRF9ESUNUICAgICAgIDIgICovXG4gIDE6ICAgICAgJ3N0cmVhbSBlbmQnLCAgICAgICAgICAvKiBaX1NUUkVBTV9FTkQgICAgICAxICAqL1xuICAwOiAgICAgICcnLCAgICAgICAgICAgICAgICAgICAgLyogWl9PSyAgICAgICAgICAgICAgMCAgKi9cbiAgJy0xJzogICAnZmlsZSBlcnJvcicsICAgICAgICAgIC8qIFpfRVJSTk8gICAgICAgICAoLTEpICovXG4gICctMic6ICAgJ3N0cmVhbSBlcnJvcicsICAgICAgICAvKiBaX1NUUkVBTV9FUlJPUiAgKC0yKSAqL1xuICAnLTMnOiAgICdkYXRhIGVycm9yJywgICAgICAgICAgLyogWl9EQVRBX0VSUk9SICAgICgtMykgKi9cbiAgJy00JzogICAnaW5zdWZmaWNpZW50IG1lbW9yeScsIC8qIFpfTUVNX0VSUk9SICAgICAoLTQpICovXG4gICctNSc6ICAgJ2J1ZmZlciBlcnJvcicsICAgICAgICAvKiBaX0JVRl9FUlJPUiAgICAgKC01KSAqL1xuICAnLTYnOiAgICdpbmNvbXBhdGlibGUgdmVyc2lvbicgLyogWl9WRVJTSU9OX0VSUk9SICgtNikgKi9cbn07XG5cbn0se31dLDExOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vKiBlc2xpbnQtZGlzYWJsZSBzcGFjZS11bmFyeS1vcHMgKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8vdmFyIFpfRklMVEVSRUQgICAgICAgICAgPSAxO1xuLy92YXIgWl9IVUZGTUFOX09OTFkgICAgICA9IDI7XG4vL3ZhciBaX1JMRSAgICAgICAgICAgICAgID0gMztcbnZhciBaX0ZJWEVEICAgICAgICAgICAgICAgPSA0O1xuLy92YXIgWl9ERUZBVUxUX1NUUkFURUdZICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbnZhciBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xudmFyIFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7XG4vL3ZhciBaX0FTQ0lJICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbnZhciBaX1VOS05PV04gICAgICAgICAgICAgPSAyO1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbmZ1bmN0aW9uIHplcm8oYnVmKSB7IHZhciBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG4vLyBGcm9tIHp1dGlsLmhcblxudmFyIFNUT1JFRF9CTE9DSyA9IDA7XG52YXIgU1RBVElDX1RSRUVTID0gMTtcbnZhciBEWU5fVFJFRVMgICAgPSAyO1xuLyogVGhlIHRocmVlIGtpbmRzIG9mIGJsb2NrIHR5cGUgKi9cblxudmFyIE1JTl9NQVRDSCAgICA9IDM7XG52YXIgTUFYX01BVENIICAgID0gMjU4O1xuLyogVGhlIG1pbmltdW0gYW5kIG1heGltdW0gbWF0Y2ggbGVuZ3RocyAqL1xuXG4vLyBGcm9tIGRlZmxhdGUuaFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbnRlcm5hbCBjb21wcmVzc2lvbiBzdGF0ZS5cbiAqL1xuXG52YXIgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG5cbnZhciBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG5cbnZhciBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG5cbnZhciBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cblxudmFyIEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xuXG52YXIgSEVBUF9TSVpFICAgICA9IDIgKiBMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG5cbnZhciBNQVhfQklUUyAgICAgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxudmFyIEJ1Zl9zaXplICAgICAgPSAxNjtcbi8qIHNpemUgb2YgYml0IGJ1ZmZlciBpbiBiaV9idWYgKi9cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0YW50c1xuICovXG5cbnZhciBNQVhfQkxfQklUUyA9IDc7XG4vKiBCaXQgbGVuZ3RoIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQkxfQklUUyBiaXRzICovXG5cbnZhciBFTkRfQkxPQ0sgICA9IDI1Njtcbi8qIGVuZCBvZiBibG9jayBsaXRlcmFsIGNvZGUgKi9cblxudmFyIFJFUF8zXzYgICAgID0gMTY7XG4vKiByZXBlYXQgcHJldmlvdXMgYml0IGxlbmd0aCAzLTYgdGltZXMgKDIgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbnZhciBSRVBaXzNfMTAgICA9IDE3O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMy0xMCB0aW1lcyAgKDMgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbnZhciBSRVBaXzExXzEzOCA9IDE4O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMTEtMTM4IHRpbWVzICAoNyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxuLyogZXNsaW50LWRpc2FibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cbnZhciBleHRyYV9sYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBsZW5ndGggY29kZSAqL1xuICBbMCwwLDAsMCwwLDAsMCwwLDEsMSwxLDEsMiwyLDIsMiwzLDMsMywzLDQsNCw0LDQsNSw1LDUsNSwwXTtcblxudmFyIGV4dHJhX2RiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGRpc3RhbmNlIGNvZGUgKi9cbiAgWzAsMCwwLDAsMSwxLDIsMiwzLDMsNCw0LDUsNSw2LDYsNyw3LDgsOCw5LDksMTAsMTAsMTEsMTEsMTIsMTIsMTMsMTNdO1xuXG52YXIgZXh0cmFfYmxiaXRzID0gIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggYml0IGxlbmd0aCBjb2RlICovXG4gIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDIsMyw3XTtcblxudmFyIGJsX29yZGVyID1cbiAgWzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdO1xuLyogZXNsaW50LWVuYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xuXG4vKiBUaGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcyBhcmUgc2VudCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nXG4gKiBwcm9iYWJpbGl0eSwgdG8gYXZvaWQgdHJhbnNtaXR0aW5nIHRoZSBsZW5ndGhzIGZvciB1bnVzZWQgYml0IGxlbmd0aCBjb2Rlcy5cbiAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIExvY2FsIGRhdGEuIFRoZXNlIGFyZSBpbml0aWFsaXplZCBvbmx5IG9uY2UuXG4gKi9cblxuLy8gV2UgcHJlLWZpbGwgYXJyYXlzIHdpdGggMCB0byBhdm9pZCB1bmluaXRpYWxpemVkIGdhcHNcblxudmFyIERJU1RfQ09ERV9MRU4gPSA1MTI7IC8qIHNlZSBkZWZpbml0aW9uIG9mIGFycmF5IGRpc3RfY29kZSBiZWxvdyAqL1xuXG4vLyAhISEhIFVzZSBmbGF0IGFycmF5IGluc3RlYWQgb2Ygc3RydWN0dXJlLCBGcmVxID0gaSoyLCBMZW4gPSBpKjIrMVxudmFyIHN0YXRpY19sdHJlZSAgPSBuZXcgQXJyYXkoKExfQ09ERVMgKyAyKSAqIDIpO1xuemVybyhzdGF0aWNfbHRyZWUpO1xuLyogVGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUuIFNpbmNlIHRoZSBiaXQgbGVuZ3RocyBhcmUgaW1wb3NlZCwgdGhlcmUgaXMgbm9cbiAqIG5lZWQgZm9yIHRoZSBMX0NPREVTIGV4dHJhIGNvZGVzIHVzZWQgZHVyaW5nIGhlYXAgY29uc3RydWN0aW9uLiBIb3dldmVyXG4gKiBUaGUgY29kZXMgMjg2IGFuZCAyODcgYXJlIG5lZWRlZCB0byBidWlsZCBhIGNhbm9uaWNhbCB0cmVlIChzZWUgX3RyX2luaXRcbiAqIGJlbG93KS5cbiAqL1xuXG52YXIgc3RhdGljX2R0cmVlICA9IG5ldyBBcnJheShEX0NPREVTICogMik7XG56ZXJvKHN0YXRpY19kdHJlZSk7XG4vKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUuIChBY3R1YWxseSBhIHRyaXZpYWwgdHJlZSBzaW5jZSBhbGwgY29kZXMgdXNlXG4gKiA1IGJpdHMuKVxuICovXG5cbnZhciBfZGlzdF9jb2RlICAgID0gbmV3IEFycmF5KERJU1RfQ09ERV9MRU4pO1xuemVybyhfZGlzdF9jb2RlKTtcbi8qIERpc3RhbmNlIGNvZGVzLiBUaGUgZmlyc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSBkaXN0YW5jZXNcbiAqIDMgLi4gMjU4LCB0aGUgbGFzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIHRvcCA4IGJpdHMgb2ZcbiAqIHRoZSAxNSBiaXQgZGlzdGFuY2VzLlxuICovXG5cbnZhciBfbGVuZ3RoX2NvZGUgID0gbmV3IEFycmF5KE1BWF9NQVRDSCAtIE1JTl9NQVRDSCArIDEpO1xuemVybyhfbGVuZ3RoX2NvZGUpO1xuLyogbGVuZ3RoIGNvZGUgZm9yIGVhY2ggbm9ybWFsaXplZCBtYXRjaCBsZW5ndGggKDAgPT0gTUlOX01BVENIKSAqL1xuXG52YXIgYmFzZV9sZW5ndGggICA9IG5ldyBBcnJheShMRU5HVEhfQ09ERVMpO1xuemVybyhiYXNlX2xlbmd0aCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGxlbmd0aCBmb3IgZWFjaCBjb2RlICgwID0gTUlOX01BVENIKSAqL1xuXG52YXIgYmFzZV9kaXN0ICAgICA9IG5ldyBBcnJheShEX0NPREVTKTtcbnplcm8oYmFzZV9kaXN0KTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgZGlzdGFuY2UgZm9yIGVhY2ggY29kZSAoMCA9IGRpc3RhbmNlIG9mIDEpICovXG5cblxuZnVuY3Rpb24gU3RhdGljVHJlZURlc2Moc3RhdGljX3RyZWUsIGV4dHJhX2JpdHMsIGV4dHJhX2Jhc2UsIGVsZW1zLCBtYXhfbGVuZ3RoKSB7XG5cbiAgdGhpcy5zdGF0aWNfdHJlZSAgPSBzdGF0aWNfdHJlZTsgIC8qIHN0YXRpYyB0cmVlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iaXRzICAgPSBleHRyYV9iaXRzOyAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggY29kZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYmFzZSAgID0gZXh0cmFfYmFzZTsgICAvKiBiYXNlIGluZGV4IGZvciBleHRyYV9iaXRzICovXG4gIHRoaXMuZWxlbXMgICAgICAgID0gZWxlbXM7ICAgICAgICAvKiBtYXggbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSB0cmVlICovXG4gIHRoaXMubWF4X2xlbmd0aCAgID0gbWF4X2xlbmd0aDsgICAvKiBtYXggYml0IGxlbmd0aCBmb3IgdGhlIGNvZGVzICovXG5cbiAgLy8gc2hvdyBpZiBgc3RhdGljX3RyZWVgIGhhcyBkYXRhIG9yIGR1bW15IC0gbmVlZGVkIGZvciBtb25vbW9ycGhpYyBvYmplY3RzXG4gIHRoaXMuaGFzX3N0cmVlICAgID0gc3RhdGljX3RyZWUgJiYgc3RhdGljX3RyZWUubGVuZ3RoO1xufVxuXG5cbnZhciBzdGF0aWNfbF9kZXNjO1xudmFyIHN0YXRpY19kX2Rlc2M7XG52YXIgc3RhdGljX2JsX2Rlc2M7XG5cblxuZnVuY3Rpb24gVHJlZURlc2MoZHluX3RyZWUsIHN0YXRfZGVzYykge1xuICB0aGlzLmR5bl90cmVlID0gZHluX3RyZWU7ICAgICAvKiB0aGUgZHluYW1pYyB0cmVlICovXG4gIHRoaXMubWF4X2NvZGUgPSAwOyAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICB0aGlzLnN0YXRfZGVzYyA9IHN0YXRfZGVzYzsgICAvKiB0aGUgY29ycmVzcG9uZGluZyBzdGF0aWMgdHJlZSAqL1xufVxuXG5cblxuZnVuY3Rpb24gZF9jb2RlKGRpc3QpIHtcbiAgcmV0dXJuIGRpc3QgPCAyNTYgPyBfZGlzdF9jb2RlW2Rpc3RdIDogX2Rpc3RfY29kZVsyNTYgKyAoZGlzdCA+Pj4gNyldO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogT3V0cHV0IGEgc2hvcnQgTFNCIGZpcnN0IG9uIHRoZSBzdHJlYW0uXG4gKiBJTiBhc3NlcnRpb246IHRoZXJlIGlzIGVub3VnaCByb29tIGluIHBlbmRpbmdCdWYuXG4gKi9cbmZ1bmN0aW9uIHB1dF9zaG9ydChzLCB3KSB7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodykgJiAweGZmKSk7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodXNoKSh3KSA+PiA4KSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodyA+Pj4gOCkgJiAweGZmO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHZhbHVlIG9uIGEgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKiBJTiBhc3NlcnRpb246IGxlbmd0aCA8PSAxNiBhbmQgdmFsdWUgZml0cyBpbiBsZW5ndGggYml0cy5cbiAqL1xuZnVuY3Rpb24gc2VuZF9iaXRzKHMsIHZhbHVlLCBsZW5ndGgpIHtcbiAgaWYgKHMuYmlfdmFsaWQgPiAoQnVmX3NpemUgLSBsZW5ndGgpKSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSB2YWx1ZSA+PiAoQnVmX3NpemUgLSBzLmJpX3ZhbGlkKTtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aCAtIEJ1Zl9zaXplO1xuICB9IGVsc2Uge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHNlbmRfY29kZShzLCBjLCB0cmVlKSB7XG4gIHNlbmRfYml0cyhzLCB0cmVlW2MgKiAyXS8qLkNvZGUqLywgdHJlZVtjICogMiArIDFdLyouTGVuKi8pO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmV2ZXJzZSB0aGUgZmlyc3QgbGVuIGJpdHMgb2YgYSBjb2RlLCB1c2luZyBzdHJhaWdodGZvcndhcmQgY29kZSAoYSBmYXN0ZXJcbiAqIG1ldGhvZCB3b3VsZCB1c2UgYSB0YWJsZSlcbiAqIElOIGFzc2VydGlvbjogMSA8PSBsZW4gPD0gMTVcbiAqL1xuZnVuY3Rpb24gYmlfcmV2ZXJzZShjb2RlLCBsZW4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGRvIHtcbiAgICByZXMgfD0gY29kZSAmIDE7XG4gICAgY29kZSA+Pj49IDE7XG4gICAgcmVzIDw8PSAxO1xuICB9IHdoaWxlICgtLWxlbiA+IDApO1xuICByZXR1cm4gcmVzID4+PiAxO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIsIGtlZXBpbmcgYXQgbW9zdCA3IGJpdHMgaW4gaXQuXG4gKi9cbmZ1bmN0aW9uIGJpX2ZsdXNoKHMpIHtcbiAgaWYgKHMuYmlfdmFsaWQgPT09IDE2KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IDA7XG4gICAgcy5iaV92YWxpZCA9IDA7XG5cbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID49IDgpIHtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmICYgMHhmZjtcbiAgICBzLmJpX2J1ZiA+Pj0gODtcbiAgICBzLmJpX3ZhbGlkIC09IDg7XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgZm9yIGEgdHJlZSBhbmQgdXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoXG4gKiBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQsIGhlYXBbaGVhcF9tYXhdIGFuZFxuICogICAgYWJvdmUgYXJlIHRoZSB0cmVlIG5vZGVzIHNvcnRlZCBieSBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGQgbGVuIGlzIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoLCB0aGVcbiAqICAgICBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgZnJlcXVlbmNpZXMgZm9yIGVhY2ggYml0IGxlbmd0aC5cbiAqICAgICBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpcyBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXNcbiAqICAgICBub3QgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZ2VuX2JpdGxlbihzLCBkZXNjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgICAgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICB2YXIgdHJlZSAgICAgICAgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgdmFyIG1heF9jb2RlICAgICAgICA9IGRlc2MubWF4X2NvZGU7XG4gIHZhciBzdHJlZSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgdmFyIGhhc19zdHJlZSAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgdmFyIGV4dHJhICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2JpdHM7XG4gIHZhciBiYXNlICAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iYXNlO1xuICB2YXIgbWF4X2xlbmd0aCAgICAgID0gZGVzYy5zdGF0X2Rlc2MubWF4X2xlbmd0aDtcbiAgdmFyIGg7ICAgICAgICAgICAgICAvKiBoZWFwIGluZGV4ICovXG4gIHZhciBuLCBtOyAgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgLyogYml0IGxlbmd0aCAqL1xuICB2YXIgeGJpdHM7ICAgICAgICAgIC8qIGV4dHJhIGJpdHMgKi9cbiAgdmFyIGY7ICAgICAgICAgICAgICAvKiBmcmVxdWVuY3kgKi9cbiAgdmFyIG92ZXJmbG93ID0gMDsgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgd2l0aCBiaXQgbGVuZ3RoIHRvbyBsYXJnZSAqL1xuXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIHMuYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgLyogSW4gYSBmaXJzdCBwYXNzLCBjb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzICh3aGljaCBtYXlcbiAgICogb3ZlcmZsb3cgaW4gdGhlIGNhc2Ugb2YgdGhlIGJpdCBsZW5ndGggdHJlZSkuXG4gICAqL1xuICB0cmVlW3MuaGVhcFtzLmhlYXBfbWF4XSAqIDIgKyAxXS8qLkxlbiovID0gMDsgLyogcm9vdCBvZiB0aGUgaGVhcCAqL1xuXG4gIGZvciAoaCA9IHMuaGVhcF9tYXggKyAxOyBoIDwgSEVBUF9TSVpFOyBoKyspIHtcbiAgICBuID0gcy5oZWFwW2hdO1xuICAgIGJpdHMgPSB0cmVlW3RyZWVbbiAqIDIgKyAxXS8qLkRhZCovICogMiArIDFdLyouTGVuKi8gKyAxO1xuICAgIGlmIChiaXRzID4gbWF4X2xlbmd0aCkge1xuICAgICAgYml0cyA9IG1heF9sZW5ndGg7XG4gICAgICBvdmVyZmxvdysrO1xuICAgIH1cbiAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgLyogV2Ugb3ZlcndyaXRlIHRyZWVbbl0uRGFkIHdoaWNoIGlzIG5vIGxvbmdlciBuZWVkZWQgKi9cblxuICAgIGlmIChuID4gbWF4X2NvZGUpIHsgY29udGludWU7IH0gLyogbm90IGEgbGVhZiBub2RlICovXG5cbiAgICBzLmJsX2NvdW50W2JpdHNdKys7XG4gICAgeGJpdHMgPSAwO1xuICAgIGlmIChuID49IGJhc2UpIHtcbiAgICAgIHhiaXRzID0gZXh0cmFbbiAtIGJhc2VdO1xuICAgIH1cbiAgICBmID0gdHJlZVtuICogMl0vKi5GcmVxKi87XG4gICAgcy5vcHRfbGVuICs9IGYgKiAoYml0cyArIHhiaXRzKTtcbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gKz0gZiAqIChzdHJlZVtuICogMiArIDFdLyouTGVuKi8gKyB4Yml0cyk7XG4gICAgfVxuICB9XG4gIGlmIChvdmVyZmxvdyA9PT0gMCkgeyByZXR1cm47IH1cblxuICAvLyBUcmFjZSgoc3RkZXJyLFwiXFxuYml0IGxlbmd0aCBvdmVyZmxvd1xcblwiKSk7XG4gIC8qIFRoaXMgaGFwcGVucyBmb3IgZXhhbXBsZSBvbiBvYmoyIGFuZCBwaWMgb2YgdGhlIENhbGdhcnkgY29ycHVzICovXG5cbiAgLyogRmluZCB0aGUgZmlyc3QgYml0IGxlbmd0aCB3aGljaCBjb3VsZCBpbmNyZWFzZTogKi9cbiAgZG8ge1xuICAgIGJpdHMgPSBtYXhfbGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAocy5ibF9jb3VudFtiaXRzXSA9PT0gMCkgeyBiaXRzLS07IH1cbiAgICBzLmJsX2NvdW50W2JpdHNdLS07ICAgICAgLyogbW92ZSBvbmUgbGVhZiBkb3duIHRoZSB0cmVlICovXG4gICAgcy5ibF9jb3VudFtiaXRzICsgMV0gKz0gMjsgLyogbW92ZSBvbmUgb3ZlcmZsb3cgaXRlbSBhcyBpdHMgYnJvdGhlciAqL1xuICAgIHMuYmxfY291bnRbbWF4X2xlbmd0aF0tLTtcbiAgICAvKiBUaGUgYnJvdGhlciBvZiB0aGUgb3ZlcmZsb3cgaXRlbSBhbHNvIG1vdmVzIG9uZSBzdGVwIHVwLFxuICAgICAqIGJ1dCB0aGlzIGRvZXMgbm90IGFmZmVjdCBibF9jb3VudFttYXhfbGVuZ3RoXVxuICAgICAqL1xuICAgIG92ZXJmbG93IC09IDI7XG4gIH0gd2hpbGUgKG92ZXJmbG93ID4gMCk7XG5cbiAgLyogTm93IHJlY29tcHV0ZSBhbGwgYml0IGxlbmd0aHMsIHNjYW5uaW5nIGluIGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICAgKiBoIGlzIHN0aWxsIGVxdWFsIHRvIEhFQVBfU0laRS4gKEl0IGlzIHNpbXBsZXIgdG8gcmVjb25zdHJ1Y3QgYWxsXG4gICAqIGxlbmd0aHMgaW5zdGVhZCBvZiBmaXhpbmcgb25seSB0aGUgd3Jvbmcgb25lcy4gVGhpcyBpZGVhIGlzIHRha2VuXG4gICAqIGZyb20gJ2FyJyB3cml0dGVuIGJ5IEhhcnVoaWtvIE9rdW11cmEuKVxuICAgKi9cbiAgZm9yIChiaXRzID0gbWF4X2xlbmd0aDsgYml0cyAhPT0gMDsgYml0cy0tKSB7XG4gICAgbiA9IHMuYmxfY291bnRbYml0c107XG4gICAgd2hpbGUgKG4gIT09IDApIHtcbiAgICAgIG0gPSBzLmhlYXBbLS1oXTtcbiAgICAgIGlmIChtID4gbWF4X2NvZGUpIHsgY29udGludWU7IH1cbiAgICAgIGlmICh0cmVlW20gKiAyICsgMV0vKi5MZW4qLyAhPT0gYml0cykge1xuICAgICAgICAvLyBUcmFjZSgoc3RkZXJyLFwiY29kZSAlZCBiaXRzICVkLT4lZFxcblwiLCBtLCB0cmVlW21dLkxlbiwgYml0cykpO1xuICAgICAgICBzLm9wdF9sZW4gKz0gKGJpdHMgLSB0cmVlW20gKiAyICsgMV0vKi5MZW4qLykgKiB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICAgICAgdHJlZVttICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgICAgfVxuICAgICAgbi0tO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogR2VuZXJhdGUgdGhlIGNvZGVzIGZvciBhIGdpdmVuIHRyZWUgYW5kIGJpdCBjb3VudHMgKHdoaWNoIG5lZWQgbm90IGJlXG4gKiBvcHRpbWFsKS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBiaXQgbGVuZ3RoIHN0YXRpc3RpY3MgZm9yXG4gKiB0aGUgZ2l2ZW4gdHJlZSBhbmQgdGhlIGZpZWxkIGxlbiBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbjogdGhlIGZpZWxkIGNvZGUgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cyBvZiBub25cbiAqICAgICB6ZXJvIGNvZGUgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIGJsX2NvdW50KVxuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAgICAgICAgICAgLyogdGhlIHRyZWUgdG8gZGVjb3JhdGUgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuLy8gICAgdXNoZiAqYmxfY291bnQ7ICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCAqL1xue1xuICB2YXIgbmV4dF9jb2RlID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7IC8qIG5leHQgY29kZSB2YWx1ZSBmb3IgZWFjaCBiaXQgbGVuZ3RoICovXG4gIHZhciBjb2RlID0gMDsgICAgICAgICAgICAgIC8qIHJ1bm5pbmcgY29kZSB2YWx1ZSAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAvKiBiaXQgaW5kZXggKi9cbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBpbmRleCAqL1xuXG4gIC8qIFRoZSBkaXN0cmlidXRpb24gY291bnRzIGFyZSBmaXJzdCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBjb2RlIHZhbHVlc1xuICAgKiB3aXRob3V0IGJpdCByZXZlcnNhbC5cbiAgICovXG4gIGZvciAoYml0cyA9IDE7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIG5leHRfY29kZVtiaXRzXSA9IGNvZGUgPSAoY29kZSArIGJsX2NvdW50W2JpdHMgLSAxXSkgPDwgMTtcbiAgfVxuICAvKiBDaGVjayB0aGF0IHRoZSBiaXQgY291bnRzIGluIGJsX2NvdW50IGFyZSBjb25zaXN0ZW50LiBUaGUgbGFzdCBjb2RlXG4gICAqIG11c3QgYmUgYWxsIG9uZXMuXG4gICAqL1xuICAvL0Fzc2VydCAoY29kZSArIGJsX2NvdW50W01BWF9CSVRTXS0xID09ICgxPDxNQVhfQklUUyktMSxcbiAgLy8gICAgICAgIFwiaW5jb25zaXN0ZW50IGJpdCBjb3VudHNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5nZW5fY29kZXM6IG1heF9jb2RlICVkIFwiLCBtYXhfY29kZSkpO1xuXG4gIGZvciAobiA9IDA7ICBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICB2YXIgbGVuID0gdHJlZVtuICogMiArIDFdLyouTGVuKi87XG4gICAgaWYgKGxlbiA9PT0gMCkgeyBjb250aW51ZTsgfVxuICAgIC8qIE5vdyByZXZlcnNlIHRoZSBiaXRzICovXG4gICAgdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG5leHRfY29kZVtsZW5dKyssIGxlbik7XG5cbiAgICAvL1RyYWNlY3YodHJlZSAhPSBzdGF0aWNfbHRyZWUsIChzdGRlcnIsXCJcXG5uICUzZCAlYyBsICUyZCBjICU0eCAoJXgpIFwiLFxuICAgIC8vICAgICBuLCAoaXNncmFwaChuKSA/IG4gOiAnICcpLCBsZW4sIHRyZWVbbl0uQ29kZSwgbmV4dF9jb2RlW2xlbl0tMSkpO1xuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB2YXJpb3VzICdjb25zdGFudCcgdGFibGVzLlxuICovXG5mdW5jdGlvbiB0cl9zdGF0aWNfaW5pdCgpIHtcbiAgdmFyIG47ICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIGJpdHM7ICAgICAvKiBiaXQgY291bnRlciAqL1xuICB2YXIgbGVuZ3RoOyAgIC8qIGxlbmd0aCB2YWx1ZSAqL1xuICB2YXIgY29kZTsgICAgIC8qIGNvZGUgdmFsdWUgKi9cbiAgdmFyIGRpc3Q7ICAgICAvKiBkaXN0YW5jZSBpbmRleCAqL1xuICB2YXIgYmxfY291bnQgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy8gZG8gY2hlY2sgaW4gX3RyX2luaXQoKVxuICAvL2lmIChzdGF0aWNfaW5pdF9kb25lKSByZXR1cm47XG5cbiAgLyogRm9yIHNvbWUgZW1iZWRkZWQgdGFyZ2V0cywgZ2xvYmFsIHZhcmlhYmxlcyBhcmUgbm90IGluaXRpYWxpemVkOiAqL1xuLyojaWZkZWYgTk9fSU5JVF9HTE9CQUxfUE9JTlRFUlNcbiAgc3RhdGljX2xfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19sdHJlZTtcbiAgc3RhdGljX2xfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfbGJpdHM7XG4gIHN0YXRpY19kX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfZHRyZWU7XG4gIHN0YXRpY19kX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2RiaXRzO1xuICBzdGF0aWNfYmxfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfYmxiaXRzO1xuI2VuZGlmKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGxlbmd0aCAoMC4uMjU1KSAtPiBsZW5ndGggY29kZSAoMC4uMjgpICovXG4gIGxlbmd0aCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCBMRU5HVEhfQ09ERVMgLSAxOyBjb2RlKyspIHtcbiAgICBiYXNlX2xlbmd0aFtjb2RlXSA9IGxlbmd0aDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfbGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9sZW5ndGhfY29kZVtsZW5ndGgrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAobGVuZ3RoID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogbGVuZ3RoICE9IDI1NlwiKTtcbiAgLyogTm90ZSB0aGF0IHRoZSBsZW5ndGggMjU1IChtYXRjaCBsZW5ndGggMjU4KSBjYW4gYmUgcmVwcmVzZW50ZWRcbiAgICogaW4gdHdvIGRpZmZlcmVudCB3YXlzOiBjb2RlIDI4NCArIDUgYml0cyBvciBjb2RlIDI4NSwgc28gd2VcbiAgICogb3ZlcndyaXRlIGxlbmd0aF9jb2RlWzI1NV0gdG8gdXNlIHRoZSBiZXN0IGVuY29kaW5nOlxuICAgKi9cbiAgX2xlbmd0aF9jb2RlW2xlbmd0aCAtIDFdID0gY29kZTtcblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGRpc3QgKDAuLjMySykgLT4gZGlzdCBjb2RlICgwLi4yOSkgKi9cbiAgZGlzdCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCAxNjsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfZGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogZGlzdCAhPSAyNTZcIik7XG4gIGRpc3QgPj49IDc7IC8qIGZyb20gbm93IG9uLCBhbGwgZGlzdGFuY2VzIGFyZSBkaXZpZGVkIGJ5IDEyOCAqL1xuICBmb3IgKDsgY29kZSA8IERfQ09ERVM7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3QgPDwgNztcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgKGV4dHJhX2RiaXRzW2NvZGVdIC0gNykpOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbMjU2ICsgZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogMjU2K2Rpc3QgIT0gNTEyXCIpO1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgY29kZXMgb2YgdGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUgKi9cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgbiA9IDA7XG4gIHdoaWxlIChuIDw9IDE0Mykge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI1NSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA5O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs5XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI3OSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA3O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs3XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI4Nykge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIC8qIENvZGVzIDI4NiBhbmQgMjg3IGRvIG5vdCBleGlzdCwgYnV0IHdlIG11c3QgaW5jbHVkZSB0aGVtIGluIHRoZVxuICAgKiB0cmVlIGNvbnN0cnVjdGlvbiB0byBnZXQgYSBjYW5vbmljYWwgSHVmZm1hbiB0cmVlIChsb25nZXN0IGNvZGVcbiAgICogYWxsIG9uZXMpXG4gICAqL1xuICBnZW5fY29kZXMoc3RhdGljX2x0cmVlLCBMX0NPREVTICsgMSwgYmxfY291bnQpO1xuXG4gIC8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZSBpcyB0cml2aWFsOiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgbisrKSB7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDU7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobiwgNSk7XG4gIH1cblxuICAvLyBOb3cgZGF0YSByZWFkeSBhbmQgd2UgY2FuIGluaXQgc3RhdGljIHRyZWVzXG4gIHN0YXRpY19sX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2x0cmVlLCBleHRyYV9sYml0cywgTElURVJBTFMgKyAxLCBMX0NPREVTLCBNQVhfQklUUyk7XG4gIHN0YXRpY19kX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2R0cmVlLCBleHRyYV9kYml0cywgMCwgICAgICAgICAgRF9DT0RFUywgTUFYX0JJVFMpO1xuICBzdGF0aWNfYmxfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhuZXcgQXJyYXkoMCksIGV4dHJhX2JsYml0cywgMCwgICAgICAgICBCTF9DT0RFUywgTUFYX0JMX0JJVFMpO1xuXG4gIC8vc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIGEgbmV3IGJsb2NrLlxuICovXG5mdW5jdGlvbiBpbml0X2Jsb2NrKHMpIHtcbiAgdmFyIG47IC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIHRyZWVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgTF9DT0RFUzsgIG4rKykgeyBzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyAgbisrKSB7IHMuZHluX2R0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IEJMX0NPREVTOyBuKyspIHsgcy5ibF90cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cblxuICBzLmR5bl9sdHJlZVtFTkRfQkxPQ0sgKiAyXS8qLkZyZXEqLyA9IDE7XG4gIHMub3B0X2xlbiA9IHMuc3RhdGljX2xlbiA9IDA7XG4gIHMubGFzdF9saXQgPSBzLm1hdGNoZXMgPSAwO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIgYW5kIGFsaWduIHRoZSBvdXRwdXQgb24gYSBieXRlIGJvdW5kYXJ5XG4gKi9cbmZ1bmN0aW9uIGJpX3dpbmR1cChzKVxue1xuICBpZiAocy5iaV92YWxpZCA+IDgpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPiAwKSB7XG4gICAgLy9wdXRfYnl0ZShzLCAoQnl0ZSlzLT5iaV9idWYpO1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWY7XG4gIH1cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IGEgc3RvcmVkIGJsb2NrLCBzdG9yaW5nIGZpcnN0IHRoZSBsZW5ndGggYW5kIGl0c1xuICogb25lJ3MgY29tcGxlbWVudCBpZiByZXF1ZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNvcHlfYmxvY2socywgYnVmLCBsZW4sIGhlYWRlcilcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAgICAqYnVmOyAgICAvKiB0aGUgaW5wdXQgZGF0YSAqL1xuLy91bnNpZ25lZCBsZW47ICAgICAvKiBpdHMgbGVuZ3RoICovXG4vL2ludCAgICAgIGhlYWRlcjsgIC8qIHRydWUgaWYgYmxvY2sgaGVhZGVyIG11c3QgYmUgd3JpdHRlbiAqL1xue1xuICBiaV93aW5kdXAocyk7ICAgICAgICAvKiBhbGlnbiBvbiBieXRlIGJvdW5kYXJ5ICovXG5cbiAgaWYgKGhlYWRlcikge1xuICAgIHB1dF9zaG9ydChzLCBsZW4pO1xuICAgIHB1dF9zaG9ydChzLCB+bGVuKTtcbiAgfVxuLy8gIHdoaWxlIChsZW4tLSkge1xuLy8gICAgcHV0X2J5dGUocywgKmJ1ZisrKTtcbi8vICB9XG4gIHV0aWxzLmFycmF5U2V0KHMucGVuZGluZ19idWYsIHMud2luZG93LCBidWYsIGxlbiwgcy5wZW5kaW5nKTtcbiAgcy5wZW5kaW5nICs9IGxlbjtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wYXJlcyB0byBzdWJ0cmVlcywgdXNpbmcgdGhlIHRyZWUgZGVwdGggYXMgdGllIGJyZWFrZXIgd2hlblxuICogdGhlIHN1YnRyZWVzIGhhdmUgZXF1YWwgZnJlcXVlbmN5LiBUaGlzIG1pbmltaXplcyB0aGUgd29yc3QgY2FzZSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIHNtYWxsZXIodHJlZSwgbiwgbSwgZGVwdGgpIHtcbiAgdmFyIF9uMiA9IG4gKiAyO1xuICB2YXIgX20yID0gbSAqIDI7XG4gIHJldHVybiAodHJlZVtfbjJdLyouRnJlcSovIDwgdHJlZVtfbTJdLyouRnJlcSovIHx8XG4gICAgICAgICAodHJlZVtfbjJdLyouRnJlcSovID09PSB0cmVlW19tMl0vKi5GcmVxKi8gJiYgZGVwdGhbbl0gPD0gZGVwdGhbbV0pKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXN0b3JlIHRoZSBoZWFwIHByb3BlcnR5IGJ5IG1vdmluZyBkb3duIHRoZSB0cmVlIHN0YXJ0aW5nIGF0IG5vZGUgayxcbiAqIGV4Y2hhbmdpbmcgYSBub2RlIHdpdGggdGhlIHNtYWxsZXN0IG9mIGl0cyB0d28gc29ucyBpZiBuZWNlc3NhcnksIHN0b3BwaW5nXG4gKiB3aGVuIHRoZSBoZWFwIHByb3BlcnR5IGlzIHJlLWVzdGFibGlzaGVkIChlYWNoIGZhdGhlciBzbWFsbGVyIHRoYW4gaXRzXG4gKiB0d28gc29ucykuXG4gKi9cbmZ1bmN0aW9uIHBxZG93bmhlYXAocywgdHJlZSwgaylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgLyogdGhlIHRyZWUgdG8gcmVzdG9yZSAqL1xuLy8gICAgaW50IGs7ICAgICAgICAgICAgICAgLyogbm9kZSB0byBtb3ZlIGRvd24gKi9cbntcbiAgdmFyIHYgPSBzLmhlYXBba107XG4gIHZhciBqID0gayA8PCAxOyAgLyogbGVmdCBzb24gb2YgayAqL1xuICB3aGlsZSAoaiA8PSBzLmhlYXBfbGVuKSB7XG4gICAgLyogU2V0IGogdG8gdGhlIHNtYWxsZXN0IG9mIHRoZSB0d28gc29uczogKi9cbiAgICBpZiAoaiA8IHMuaGVhcF9sZW4gJiZcbiAgICAgIHNtYWxsZXIodHJlZSwgcy5oZWFwW2ogKyAxXSwgcy5oZWFwW2pdLCBzLmRlcHRoKSkge1xuICAgICAgaisrO1xuICAgIH1cbiAgICAvKiBFeGl0IGlmIHYgaXMgc21hbGxlciB0aGFuIGJvdGggc29ucyAqL1xuICAgIGlmIChzbWFsbGVyKHRyZWUsIHYsIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHsgYnJlYWs7IH1cblxuICAgIC8qIEV4Y2hhbmdlIHYgd2l0aCB0aGUgc21hbGxlc3Qgc29uICovXG4gICAgcy5oZWFwW2tdID0gcy5oZWFwW2pdO1xuICAgIGsgPSBqO1xuXG4gICAgLyogQW5kIGNvbnRpbnVlIGRvd24gdGhlIHRyZWUsIHNldHRpbmcgaiB0byB0aGUgbGVmdCBzb24gb2YgayAqL1xuICAgIGogPDw9IDE7XG4gIH1cbiAgcy5oZWFwW2tdID0gdjtcbn1cblxuXG4vLyBpbmxpbmVkIG1hbnVhbGx5XG4vLyB2YXIgU01BTExFU1QgPSAxO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGJsb2NrIGRhdGEgY29tcHJlc3NlZCB1c2luZyB0aGUgZ2l2ZW4gSHVmZm1hbiB0cmVlc1xuICovXG5mdW5jdGlvbiBjb21wcmVzc19ibG9jayhzLCBsdHJlZSwgZHRyZWUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY29uc3QgY3RfZGF0YSAqbHRyZWU7IC8qIGxpdGVyYWwgdHJlZSAqL1xuLy8gICAgY29uc3QgY3RfZGF0YSAqZHRyZWU7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbntcbiAgdmFyIGRpc3Q7ICAgICAgICAgICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuICB2YXIgbGM7ICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdCA9PSAwKSAqL1xuICB2YXIgbHggPSAwOyAgICAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gbF9idWYgKi9cbiAgdmFyIGNvZGU7ICAgICAgICAgICAvKiB0aGUgY29kZSB0byBzZW5kICovXG4gIHZhciBleHRyYTsgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgdG8gc2VuZCAqL1xuXG4gIGlmIChzLmxhc3RfbGl0ICE9PSAwKSB7XG4gICAgZG8ge1xuICAgICAgZGlzdCA9IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDJdIDw8IDgpIHwgKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMiArIDFdKTtcbiAgICAgIGxjID0gcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgbHhdO1xuICAgICAgbHgrKztcblxuICAgICAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGxjLCBsdHJlZSk7IC8qIHNlbmQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgICAgLy9UcmFjZWN2KGlzZ3JhcGgobGMpLCAoc3RkZXJyLFwiICclYycgXCIsIGxjKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgICAgIGNvZGUgPSBfbGVuZ3RoX2NvZGVbbGNdO1xuICAgICAgICBzZW5kX2NvZGUocywgY29kZSArIExJVEVSQUxTICsgMSwgbHRyZWUpOyAvKiBzZW5kIHRoZSBsZW5ndGggY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2xiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBsYyAtPSBiYXNlX2xlbmd0aFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgbGMsIGV4dHJhKTsgICAgICAgLyogc2VuZCB0aGUgZXh0cmEgbGVuZ3RoIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgICBkaXN0LS07IC8qIGRpc3QgaXMgbm93IHRoZSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAgICAgY29kZSA9IGRfY29kZShkaXN0KTtcbiAgICAgICAgLy9Bc3NlcnQgKGNvZGUgPCBEX0NPREVTLCBcImJhZCBkX2NvZGVcIik7XG5cbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUsIGR0cmVlKTsgICAgICAgLyogc2VuZCB0aGUgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2RiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBkaXN0IC09IGJhc2VfZGlzdFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgZGlzdCwgZXh0cmEpOyAgIC8qIHNlbmQgdGhlIGV4dHJhIGRpc3RhbmNlIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgfSAvKiBsaXRlcmFsIG9yIG1hdGNoIHBhaXIgPyAqL1xuXG4gICAgICAvKiBDaGVjayB0aGF0IHRoZSBvdmVybGF5IGJldHdlZW4gcGVuZGluZ19idWYgYW5kIGRfYnVmK2xfYnVmIGlzIG9rOiAqL1xuICAgICAgLy9Bc3NlcnQoKHVJbnQpKHMtPnBlbmRpbmcpIDwgcy0+bGl0X2J1ZnNpemUgKyAyKmx4LFxuICAgICAgLy8gICAgICAgXCJwZW5kaW5nQnVmIG92ZXJmbG93XCIpO1xuXG4gICAgfSB3aGlsZSAobHggPCBzLmxhc3RfbGl0KTtcbiAgfVxuXG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIGx0cmVlKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCBvbmUgSHVmZm1hbiB0cmVlIGFuZCBhc3NpZ25zIHRoZSBjb2RlIGJpdCBzdHJpbmdzIGFuZCBsZW5ndGhzLlxuICogVXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkIGZyZXEgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGRzIGxlbiBhbmQgY29kZSBhcmUgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhcbiAqICAgICBhbmQgY29ycmVzcG9uZGluZyBjb2RlLiBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpc1xuICogICAgIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpcyBub3QgbnVsbC4gVGhlIGZpZWxkIG1heF9jb2RlIGlzIHNldC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRfdHJlZShzLCBkZXNjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICB2YXIgdHJlZSAgICAgPSBkZXNjLmR5bl90cmVlO1xuICB2YXIgc3RyZWUgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgdmFyIGhhc19zdHJlZSA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgdmFyIGVsZW1zICAgID0gZGVzYy5zdGF0X2Rlc2MuZWxlbXM7XG4gIHZhciBuLCBtOyAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgaGVhcCBlbGVtZW50cyAqL1xuICB2YXIgbWF4X2NvZGUgPSAtMTsgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHZhciBub2RlOyAgICAgICAgICAvKiBuZXcgbm9kZSBiZWluZyBjcmVhdGVkICovXG5cbiAgLyogQ29uc3RydWN0IHRoZSBpbml0aWFsIGhlYXAsIHdpdGggbGVhc3QgZnJlcXVlbnQgZWxlbWVudCBpblxuICAgKiBoZWFwW1NNQUxMRVNUXS4gVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS5cbiAgICogaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICovXG4gIHMuaGVhcF9sZW4gPSAwO1xuICBzLmhlYXBfbWF4ID0gSEVBUF9TSVpFO1xuXG4gIGZvciAobiA9IDA7IG4gPCBlbGVtczsgbisrKSB7XG4gICAgaWYgKHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IG1heF9jb2RlID0gbjtcbiAgICAgIHMuZGVwdGhbbl0gPSAwO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gMDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGUgcGt6aXAgZm9ybWF0IHJlcXVpcmVzIHRoYXQgYXQgbGVhc3Qgb25lIGRpc3RhbmNlIGNvZGUgZXhpc3RzLFxuICAgKiBhbmQgdGhhdCBhdCBsZWFzdCBvbmUgYml0IHNob3VsZCBiZSBzZW50IGV2ZW4gaWYgdGhlcmUgaXMgb25seSBvbmVcbiAgICogcG9zc2libGUgY29kZS4gU28gdG8gYXZvaWQgc3BlY2lhbCBjaGVja3MgbGF0ZXIgb24gd2UgZm9yY2UgYXQgbGVhc3RcbiAgICogdHdvIGNvZGVzIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeS5cbiAgICovXG4gIHdoaWxlIChzLmhlYXBfbGVuIDwgMikge1xuICAgIG5vZGUgPSBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IChtYXhfY29kZSA8IDIgPyArK21heF9jb2RlIDogMCk7XG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSAxO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAwO1xuICAgIHMub3B0X2xlbi0tO1xuXG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuIC09IHN0cmVlW25vZGUgKiAyICsgMV0vKi5MZW4qLztcbiAgICB9XG4gICAgLyogbm9kZSBpcyAwIG9yIDEgc28gaXQgZG9lcyBub3QgaGF2ZSBleHRyYSBiaXRzICovXG4gIH1cbiAgZGVzYy5tYXhfY29kZSA9IG1heF9jb2RlO1xuXG4gIC8qIFRoZSBlbGVtZW50cyBoZWFwW2hlYXBfbGVuLzIrMSAuLiBoZWFwX2xlbl0gYXJlIGxlYXZlcyBvZiB0aGUgdHJlZSxcbiAgICogZXN0YWJsaXNoIHN1Yi1oZWFwcyBvZiBpbmNyZWFzaW5nIGxlbmd0aHM6XG4gICAqL1xuICBmb3IgKG4gPSAocy5oZWFwX2xlbiA+PiAxLyppbnQgLzIqLyk7IG4gPj0gMTsgbi0tKSB7IHBxZG93bmhlYXAocywgdHJlZSwgbik7IH1cblxuICAvKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBieSByZXBlYXRlZGx5IGNvbWJpbmluZyB0aGUgbGVhc3QgdHdvXG4gICAqIGZyZXF1ZW50IG5vZGVzLlxuICAgKi9cbiAgbm9kZSA9IGVsZW1zOyAgICAgICAgICAgICAgLyogbmV4dCBpbnRlcm5hbCBub2RlIG9mIHRoZSB0cmVlICovXG4gIGRvIHtcbiAgICAvL3BxcmVtb3ZlKHMsIHRyZWUsIG4pOyAgLyogbiA9IG5vZGUgb2YgbGVhc3QgZnJlcXVlbmN5ICovXG4gICAgLyoqKiBwcXJlbW92ZSAqKiovXG4gICAgbiA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBzLmhlYXBbcy5oZWFwX2xlbi0tXTtcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuICAgIC8qKiovXG5cbiAgICBtID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dOyAvKiBtID0gbm9kZSBvZiBuZXh0IGxlYXN0IGZyZXF1ZW5jeSAqL1xuXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBuOyAvKiBrZWVwIHRoZSBub2RlcyBzb3J0ZWQgYnkgZnJlcXVlbmN5ICovXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBtO1xuXG4gICAgLyogQ3JlYXRlIGEgbmV3IG5vZGUgZmF0aGVyIG9mIG4gYW5kIG0gKi9cbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IHRyZWVbbiAqIDJdLyouRnJlcSovICsgdHJlZVttICogMl0vKi5GcmVxKi87XG4gICAgcy5kZXB0aFtub2RlXSA9IChzLmRlcHRoW25dID49IHMuZGVwdGhbbV0gPyBzLmRlcHRoW25dIDogcy5kZXB0aFttXSkgKyAxO1xuICAgIHRyZWVbbiAqIDIgKyAxXS8qLkRhZCovID0gdHJlZVttICogMiArIDFdLyouRGFkKi8gPSBub2RlO1xuXG4gICAgLyogYW5kIGluc2VydCB0aGUgbmV3IG5vZGUgaW4gdGhlIGhlYXAgKi9cbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBub2RlKys7XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcblxuICB9IHdoaWxlIChzLmhlYXBfbGVuID49IDIpO1xuXG4gIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuXG4gIC8qIEF0IHRoaXMgcG9pbnQsIHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQuIFdlIGNhbiBub3dcbiAgICogZ2VuZXJhdGUgdGhlIGJpdCBsZW5ndGhzLlxuICAgKi9cbiAgZ2VuX2JpdGxlbihzLCBkZXNjKTtcblxuICAvKiBUaGUgZmllbGQgbGVuIGlzIG5vdyBzZXQsIHdlIGNhbiBnZW5lcmF0ZSB0aGUgYml0IGNvZGVzICovXG4gIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgcy5ibF9jb3VudCk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTY2FuIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIHRvIGRldGVybWluZSB0aGUgZnJlcXVlbmNpZXMgb2YgdGhlIGNvZGVzXG4gKiBpbiB0aGUgYml0IGxlbmd0aCB0cmVlLlxuICovXG5mdW5jdGlvbiBzY2FuX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgdmFyIGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICB2YXIgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICB2YXIgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIHZhciBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG4gIHRyZWVbKG1heF9jb2RlICsgMSkgKiAyICsgMV0vKi5MZW4qLyA9IDB4ZmZmZjsgLyogZ3VhcmQgKi9cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8gKz0gY291bnQ7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuXG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7IHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLysrOyB9XG4gICAgICBzLmJsX3RyZWVbUkVQXzNfNiAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8zXzEwICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8xMV8xMzggKiAyXS8qLkZyZXEqLysrO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuXG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIGluIGNvbXByZXNzZWQgZm9ybSwgdXNpbmcgdGhlIGNvZGVzIGluXG4gKiBibF90cmVlLlxuICovXG5mdW5jdGlvbiBzZW5kX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIHZhciBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgdmFyIGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgdmFyIG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICB2YXIgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgLyogdHJlZVttYXhfY29kZSsxXS5MZW4gPSAtMTsgKi8gIC8qIGd1YXJkIGFscmVhZHkgc2V0ICovXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBkbyB7IHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7IH0gd2hpbGUgKC0tY291bnQgIT09IDApO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTtcbiAgICAgICAgY291bnQtLTtcbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KGNvdW50ID49IDMgJiYgY291bnQgPD0gNiwgXCIgM182P1wiKTtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBfM182LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMik7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8zXzEwLCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfMTFfMTM4LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMTEsIDcpO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgZm9yIHRoZSBiaXQgbGVuZ3RocyBhbmQgcmV0dXJuIHRoZSBpbmRleCBpblxuICogYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkX2JsX3RyZWUocykge1xuICB2YXIgbWF4X2JsaW5kZXg7ICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBiaXQgbGVuZ3RoIGZyZXF1ZW5jaWVzIGZvciBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICBzY2FuX3RyZWUocywgcy5keW5fbHRyZWUsIHMubF9kZXNjLm1heF9jb2RlKTtcbiAgc2Nhbl90cmVlKHMsIHMuZHluX2R0cmVlLCBzLmRfZGVzYy5tYXhfY29kZSk7XG5cbiAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZTogKi9cbiAgYnVpbGRfdHJlZShzLCBzLmJsX2Rlc2MpO1xuICAvKiBvcHRfbGVuIG5vdyBpbmNsdWRlcyB0aGUgbGVuZ3RoIG9mIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucywgZXhjZXB0XG4gICAqIHRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RocyBjb2RlcyBhbmQgdGhlIDUrNSs0IGJpdHMgZm9yIHRoZSBjb3VudHMuXG4gICAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJpdCBsZW5ndGggY29kZXMgdG8gc2VuZC4gVGhlIHBremlwIGZvcm1hdFxuICAgKiByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IDQgYml0IGxlbmd0aCBjb2RlcyBiZSBzZW50LiAoYXBwbm90ZS50eHQgc2F5c1xuICAgKiAzIGJ1dCB0aGUgYWN0dWFsIHZhbHVlIHVzZWQgaXMgNC4pXG4gICAqL1xuICBmb3IgKG1heF9ibGluZGV4ID0gQkxfQ09ERVMgLSAxOyBtYXhfYmxpbmRleCA+PSAzOyBtYXhfYmxpbmRleC0tKSB7XG4gICAgaWYgKHMuYmxfdHJlZVtibF9vcmRlclttYXhfYmxpbmRleF0gKiAyICsgMV0vKi5MZW4qLyAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8qIFVwZGF0ZSBvcHRfbGVuIHRvIGluY2x1ZGUgdGhlIGJpdCBsZW5ndGggdHJlZSBhbmQgY291bnRzICovXG4gIHMub3B0X2xlbiArPSAzICogKG1heF9ibGluZGV4ICsgMSkgKyA1ICsgNSArIDQ7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZHluIHRyZWVzOiBkeW4gJWxkLCBzdGF0ICVsZFwiLFxuICAvLyAgICAgICAgcy0+b3B0X2xlbiwgcy0+c3RhdGljX2xlbikpO1xuXG4gIHJldHVybiBtYXhfYmxpbmRleDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGhlYWRlciBmb3IgYSBibG9jayB1c2luZyBkeW5hbWljIEh1ZmZtYW4gdHJlZXM6IHRoZSBjb3VudHMsIHRoZVxuICogbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcywgdGhlIGxpdGVyYWwgdHJlZSBhbmQgdGhlIGRpc3RhbmNlIHRyZWUuXG4gKiBJTiBhc3NlcnRpb246IGxjb2RlcyA+PSAyNTcsIGRjb2RlcyA+PSAxLCBibGNvZGVzID49IDQuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfYWxsX3RyZWVzKHMsIGxjb2RlcywgZGNvZGVzLCBibGNvZGVzKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGludCBsY29kZXMsIGRjb2RlcywgYmxjb2RlczsgLyogbnVtYmVyIG9mIGNvZGVzIGZvciBlYWNoIHRyZWUgKi9cbntcbiAgdmFyIHJhbms7ICAgICAgICAgICAgICAgICAgICAvKiBpbmRleCBpbiBibF9vcmRlciAqL1xuXG4gIC8vQXNzZXJ0IChsY29kZXMgPj0gMjU3ICYmIGRjb2RlcyA+PSAxICYmIGJsY29kZXMgPj0gNCwgXCJub3QgZW5vdWdoIGNvZGVzXCIpO1xuICAvL0Fzc2VydCAobGNvZGVzIDw9IExfQ09ERVMgJiYgZGNvZGVzIDw9IERfQ09ERVMgJiYgYmxjb2RlcyA8PSBCTF9DT0RFUyxcbiAgLy8gICAgICAgIFwidG9vIG1hbnkgY29kZXNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY291bnRzOiBcIikpO1xuICBzZW5kX2JpdHMocywgbGNvZGVzIC0gMjU3LCA1KTsgLyogbm90ICsyNTUgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIHNlbmRfYml0cyhzLCBkY29kZXMgLSAxLCAgIDUpO1xuICBzZW5kX2JpdHMocywgYmxjb2RlcyAtIDQsICA0KTsgLyogbm90IC0zIGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBmb3IgKHJhbmsgPSAwOyByYW5rIDwgYmxjb2RlczsgcmFuaysrKSB7XG4gICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb2RlICUyZCBcIiwgYmxfb3JkZXJbcmFua10pKTtcbiAgICBzZW5kX2JpdHMocywgcy5ibF90cmVlW2JsX29yZGVyW3JhbmtdICogMiArIDFdLyouTGVuKi8sIDMpO1xuICB9XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2x0cmVlLCBsY29kZXMgLSAxKTsgLyogbGl0ZXJhbCB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9kdHJlZSwgZGNvZGVzIC0gMSk7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ2hlY2sgaWYgdGhlIGRhdGEgdHlwZSBpcyBURVhUIG9yIEJJTkFSWSwgdXNpbmcgdGhlIGZvbGxvd2luZyBhbGdvcml0aG06XG4gKiAtIFRFWFQgaWYgdGhlIHR3byBjb25kaXRpb25zIGJlbG93IGFyZSBzYXRpc2ZpZWQ6XG4gKiAgICBhKSBUaGVyZSBhcmUgbm8gbm9uLXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcImJsYWNrIGxpc3RcIiAoMC4uNiwgMTQuLjI1LCAyOC4uMzEpLlxuICogICAgYikgVGhlcmUgaXMgYXQgbGVhc3Qgb25lIHByaW50YWJsZSBjaGFyYWN0ZXIgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJ3aGl0ZSBsaXN0XCIgKDkge1RBQn0sIDEwIHtMRn0sIDEzIHtDUn0sIDMyLi4yNTUpLlxuICogLSBCSU5BUlkgb3RoZXJ3aXNlLlxuICogLSBUaGUgZm9sbG93aW5nIHBhcnRpYWxseS1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgZm9ybSBhXG4gKiAgIFwiZ3JheSBsaXN0XCIgdGhhdCBpcyBpZ25vcmVkIGluIHRoaXMgZGV0ZWN0aW9uIGFsZ29yaXRobTpcbiAqICAgKDcge0JFTH0sIDgge0JTfSwgMTEge1ZUfSwgMTIge0ZGfSwgMjYge1NVQn0sIDI3IHtFU0N9KS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBGcmVxIG9mIGR5bl9sdHJlZSBhcmUgc2V0LlxuICovXG5mdW5jdGlvbiBkZXRlY3RfZGF0YV90eXBlKHMpIHtcbiAgLyogYmxhY2tfbWFzayBpcyB0aGUgYml0IG1hc2sgb2YgYmxhY2stbGlzdGVkIGJ5dGVzXG4gICAqIHNldCBiaXRzIDAuLjYsIDE0Li4yNSwgYW5kIDI4Li4zMVxuICAgKiAweGYzZmZjMDdmID0gYmluYXJ5IDExMTEwMDExMTExMTExMTExMTAwMDAwMDAxMTExMTExXG4gICAqL1xuICB2YXIgYmxhY2tfbWFzayA9IDB4ZjNmZmMwN2Y7XG4gIHZhciBuO1xuXG4gIC8qIENoZWNrIGZvciBub24tdGV4dHVhbCAoXCJibGFjay1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGZvciAobiA9IDA7IG4gPD0gMzE7IG4rKywgYmxhY2tfbWFzayA+Pj49IDEpIHtcbiAgICBpZiAoKGJsYWNrX21hc2sgJiAxKSAmJiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSkge1xuICAgICAgcmV0dXJuIFpfQklOQVJZO1xuICAgIH1cbiAgfVxuXG4gIC8qIENoZWNrIGZvciB0ZXh0dWFsIChcIndoaXRlLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgaWYgKHMuZHluX2x0cmVlWzkgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fCBzLmR5bl9sdHJlZVsxMCAqIDJdLyouRnJlcSovICE9PSAwIHx8XG4gICAgICBzLmR5bl9sdHJlZVsxMyAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgcmV0dXJuIFpfVEVYVDtcbiAgfVxuICBmb3IgKG4gPSAzMjsgbiA8IExJVEVSQUxTOyBuKyspIHtcbiAgICBpZiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICByZXR1cm4gWl9URVhUO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZXJlIGFyZSBubyBcImJsYWNrLWxpc3RlZFwiIG9yIFwid2hpdGUtbGlzdGVkXCIgYnl0ZXM6XG4gICAqIHRoaXMgc3RyZWFtIGVpdGhlciBpcyBlbXB0eSBvciBoYXMgdG9sZXJhdGVkIChcImdyYXktbGlzdGVkXCIpIGJ5dGVzIG9ubHkuXG4gICAqL1xuICByZXR1cm4gWl9CSU5BUlk7XG59XG5cblxudmFyIHN0YXRpY19pbml0X2RvbmUgPSBmYWxzZTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB0cmVlIGRhdGEgc3RydWN0dXJlcyBmb3IgYSBuZXcgemxpYiBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIF90cl9pbml0KHMpXG57XG5cbiAgaWYgKCFzdGF0aWNfaW5pdF9kb25lKSB7XG4gICAgdHJfc3RhdGljX2luaXQoKTtcbiAgICBzdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbiAgfVxuXG4gIHMubF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9sdHJlZSwgc3RhdGljX2xfZGVzYyk7XG4gIHMuZF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9kdHJlZSwgc3RhdGljX2RfZGVzYyk7XG4gIHMuYmxfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmJsX3RyZWUsIHN0YXRpY19ibF9kZXNjKTtcblxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIGZpcnN0IGJsb2NrIG9mIHRoZSBmaXJzdCBmaWxlOiAqL1xuICBpbml0X2Jsb2NrKHMpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHN0b3JlZCBibG9ja1xuICovXG5mdW5jdGlvbiBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdClcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jayAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICBzZW5kX2JpdHMocywgKFNUT1JFRF9CTE9DSyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTsgICAgLyogc2VuZCBibG9jayB0eXBlICovXG4gIGNvcHlfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCB0cnVlKTsgLyogd2l0aCBoZWFkZXIgKi9cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgb25lIGVtcHR5IHN0YXRpYyBibG9jayB0byBnaXZlIGVub3VnaCBsb29rYWhlYWQgZm9yIGluZmxhdGUuXG4gKiBUaGlzIHRha2VzIDEwIGJpdHMsIG9mIHdoaWNoIDcgbWF5IHJlbWFpbiBpbiB0aGUgYml0IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gX3RyX2FsaWduKHMpIHtcbiAgc2VuZF9iaXRzKHMsIFNUQVRJQ19UUkVFUyA8PCAxLCAzKTtcbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgc3RhdGljX2x0cmVlKTtcbiAgYmlfZmx1c2gocyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcgZm9yIHRoZSBjdXJyZW50IGJsb2NrOiBkeW5hbWljIHRyZWVzLCBzdGF0aWNcbiAqIHRyZWVzIG9yIHN0b3JlLCBhbmQgb3V0cHV0IHRoZSBlbmNvZGVkIGJsb2NrIHRvIHRoZSB6aXAgZmlsZS5cbiAqL1xuZnVuY3Rpb24gX3RyX2ZsdXNoX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdClcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jaywgb3IgTlVMTCBpZiB0b28gb2xkICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIHZhciBvcHRfbGVuYiwgc3RhdGljX2xlbmI7ICAvKiBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGluIGJ5dGVzICovXG4gIHZhciBtYXhfYmxpbmRleCA9IDA7ICAgICAgICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogQnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgdW5sZXNzIGEgc3RvcmVkIGJsb2NrIGlzIGZvcmNlZCAqL1xuICBpZiAocy5sZXZlbCA+IDApIHtcblxuICAgIC8qIENoZWNrIGlmIHRoZSBmaWxlIGlzIGJpbmFyeSBvciB0ZXh0ICovXG4gICAgaWYgKHMuc3RybS5kYXRhX3R5cGUgPT09IFpfVU5LTk9XTikge1xuICAgICAgcy5zdHJtLmRhdGFfdHlwZSA9IGRldGVjdF9kYXRhX3R5cGUocyk7XG4gICAgfVxuXG4gICAgLyogQ29uc3RydWN0IHRoZSBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICAgIGJ1aWxkX3RyZWUocywgcy5sX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmxpdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgICBidWlsZF90cmVlKHMsIHMuZF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcbiAgICAvKiBBdCB0aGlzIHBvaW50LCBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGFyZSB0aGUgdG90YWwgYml0IGxlbmd0aHMgb2ZcbiAgICAgKiB0aGUgY29tcHJlc3NlZCBibG9jayBkYXRhLCBleGNsdWRpbmcgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuXG4gICAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZSBmb3IgdGhlIGFib3ZlIHR3byB0cmVlcywgYW5kIGdldCB0aGUgaW5kZXhcbiAgICAgKiBpbiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAgICAgKi9cbiAgICBtYXhfYmxpbmRleCA9IGJ1aWxkX2JsX3RyZWUocyk7XG5cbiAgICAvKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcuIENvbXB1dGUgdGhlIGJsb2NrIGxlbmd0aHMgaW4gYnl0ZXMuICovXG4gICAgb3B0X2xlbmIgPSAocy5vcHRfbGVuICsgMyArIDcpID4+PiAzO1xuICAgIHN0YXRpY19sZW5iID0gKHMuc3RhdGljX2xlbiArIDMgKyA3KSA+Pj4gMztcblxuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbm9wdCAlbHUoJWx1KSBzdGF0ICVsdSglbHUpIHN0b3JlZCAlbHUgbGl0ICV1IFwiLFxuICAgIC8vICAgICAgICBvcHRfbGVuYiwgcy0+b3B0X2xlbiwgc3RhdGljX2xlbmIsIHMtPnN0YXRpY19sZW4sIHN0b3JlZF9sZW4sXG4gICAgLy8gICAgICAgIHMtPmxhc3RfbGl0KSk7XG5cbiAgICBpZiAoc3RhdGljX2xlbmIgPD0gb3B0X2xlbmIpIHsgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYjsgfVxuXG4gIH0gZWxzZSB7XG4gICAgLy8gQXNzZXJ0KGJ1ZiAhPSAoY2hhciopMCwgXCJsb3N0IGJ1ZlwiKTtcbiAgICBvcHRfbGVuYiA9IHN0YXRpY19sZW5iID0gc3RvcmVkX2xlbiArIDU7IC8qIGZvcmNlIGEgc3RvcmVkIGJsb2NrICovXG4gIH1cblxuICBpZiAoKHN0b3JlZF9sZW4gKyA0IDw9IG9wdF9sZW5iKSAmJiAoYnVmICE9PSAtMSkpIHtcbiAgICAvKiA0OiB0d28gd29yZHMgZm9yIHRoZSBsZW5ndGhzICovXG5cbiAgICAvKiBUaGUgdGVzdCBidWYgIT0gTlVMTCBpcyBvbmx5IG5lY2Vzc2FyeSBpZiBMSVRfQlVGU0laRSA+IFdTSVpFLlxuICAgICAqIE90aGVyd2lzZSB3ZSBjYW4ndCBoYXZlIHByb2Nlc3NlZCBtb3JlIHRoYW4gV1NJWkUgaW5wdXQgYnl0ZXMgc2luY2VcbiAgICAgKiB0aGUgbGFzdCBibG9jayBmbHVzaCwgYmVjYXVzZSBjb21wcmVzc2lvbiB3b3VsZCBoYXZlIGJlZW5cbiAgICAgKiBzdWNjZXNzZnVsLiBJZiBMSVRfQlVGU0laRSA8PSBXU0laRSwgaXQgaXMgbmV2ZXIgdG9vIGxhdGUgdG9cbiAgICAgKiB0cmFuc2Zvcm0gYSBibG9jayBpbnRvIGEgc3RvcmVkIGJsb2NrLlxuICAgICAqL1xuICAgIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KTtcblxuICB9IGVsc2UgaWYgKHMuc3RyYXRlZ3kgPT09IFpfRklYRUQgfHwgc3RhdGljX2xlbmIgPT09IG9wdF9sZW5iKSB7XG5cbiAgICBzZW5kX2JpdHMocywgKFNUQVRJQ19UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzdGF0aWNfbHRyZWUsIHN0YXRpY19kdHJlZSk7XG5cbiAgfSBlbHNlIHtcbiAgICBzZW5kX2JpdHMocywgKERZTl9UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBzZW5kX2FsbF90cmVlcyhzLCBzLmxfZGVzYy5tYXhfY29kZSArIDEsIHMuZF9kZXNjLm1heF9jb2RlICsgMSwgbWF4X2JsaW5kZXggKyAxKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzLmR5bl9sdHJlZSwgcy5keW5fZHRyZWUpO1xuICB9XG4gIC8vIEFzc2VydCAocy0+Y29tcHJlc3NlZF9sZW4gPT0gcy0+Yml0c19zZW50LCBcImJhZCBjb21wcmVzc2VkIHNpemVcIik7XG4gIC8qIFRoZSBhYm92ZSBjaGVjayBpcyBtYWRlIG1vZCAyXjMyLCBmb3IgZmlsZXMgbGFyZ2VyIHRoYW4gNTEyIE1CXG4gICAqIGFuZCB1TG9uZyBpbXBsZW1lbnRlZCBvbiAzMiBiaXRzLlxuICAgKi9cbiAgaW5pdF9ibG9jayhzKTtcblxuICBpZiAobGFzdCkge1xuICAgIGJpX3dpbmR1cChzKTtcbiAgfVxuICAvLyBUcmFjZXYoKHN0ZGVycixcIlxcbmNvbXBybGVuICVsdSglbHUpIFwiLCBzLT5jb21wcmVzc2VkX2xlbj4+MyxcbiAgLy8gICAgICAgcy0+Y29tcHJlc3NlZF9sZW4tNypsYXN0KSk7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2F2ZSB0aGUgbWF0Y2ggaW5mbyBhbmQgdGFsbHkgdGhlIGZyZXF1ZW5jeSBjb3VudHMuIFJldHVybiB0cnVlIGlmXG4gKiB0aGUgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIF90cl90YWxseShzLCBkaXN0LCBsYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB1bnNpZ25lZCBkaXN0OyAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbi8vICAgIHVuc2lnbmVkIGxjOyAgICAvKiBtYXRjaCBsZW5ndGgtTUlOX01BVENIIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0PT0wKSAqL1xue1xuICAvL3ZhciBvdXRfbGVuZ3RoLCBpbl9sZW5ndGgsIGRjb2RlO1xuXG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyXSAgICAgPSAoZGlzdCA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMiArIDFdID0gZGlzdCAmIDB4ZmY7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgcy5sYXN0X2xpdF0gPSBsYyAmIDB4ZmY7XG4gIHMubGFzdF9saXQrKztcblxuICBpZiAoZGlzdCA9PT0gMCkge1xuICAgIC8qIGxjIGlzIHRoZSB1bm1hdGNoZWQgY2hhciAqL1xuICAgIHMuZHluX2x0cmVlW2xjICogMl0vKi5GcmVxKi8rKztcbiAgfSBlbHNlIHtcbiAgICBzLm1hdGNoZXMrKztcbiAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgZGlzdC0tOyAgICAgICAgICAgICAvKiBkaXN0ID0gbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgLy9Bc3NlcnQoKHVzaClkaXN0IDwgKHVzaClNQVhfRElTVChzKSAmJlxuICAgIC8vICAgICAgICh1c2gpbGMgPD0gKHVzaCkoTUFYX01BVENILU1JTl9NQVRDSCkgJiZcbiAgICAvLyAgICAgICAodXNoKWRfY29kZShkaXN0KSA8ICh1c2gpRF9DT0RFUywgIFwiX3RyX3RhbGx5OiBiYWQgbWF0Y2hcIik7XG5cbiAgICBzLmR5bl9sdHJlZVsoX2xlbmd0aF9jb2RlW2xjXSArIExJVEVSQUxTICsgMSkgKiAyXS8qLkZyZXEqLysrO1xuICAgIHMuZHluX2R0cmVlW2RfY29kZShkaXN0KSAqIDJdLyouRnJlcSovKys7XG4gIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcblxuLy8jaWZkZWYgVFJVTkNBVEVfQkxPQ0tcbi8vICAvKiBUcnkgdG8gZ3Vlc3MgaWYgaXQgaXMgcHJvZml0YWJsZSB0byBzdG9wIHRoZSBjdXJyZW50IGJsb2NrIGhlcmUgKi9cbi8vICBpZiAoKHMubGFzdF9saXQgJiAweDFmZmYpID09PSAwICYmIHMubGV2ZWwgPiAyKSB7XG4vLyAgICAvKiBDb21wdXRlIGFuIHVwcGVyIGJvdW5kIGZvciB0aGUgY29tcHJlc3NlZCBsZW5ndGggKi9cbi8vICAgIG91dF9sZW5ndGggPSBzLmxhc3RfbGl0Kjg7XG4vLyAgICBpbl9sZW5ndGggPSBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydDtcbi8vXG4vLyAgICBmb3IgKGRjb2RlID0gMDsgZGNvZGUgPCBEX0NPREVTOyBkY29kZSsrKSB7XG4vLyAgICAgIG91dF9sZW5ndGggKz0gcy5keW5fZHRyZWVbZGNvZGUqMl0vKi5GcmVxKi8gKiAoNSArIGV4dHJhX2RiaXRzW2Rjb2RlXSk7XG4vLyAgICB9XG4vLyAgICBvdXRfbGVuZ3RoID4+Pj0gMztcbi8vICAgIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5sYXN0X2xpdCAldSwgaW4gJWxkLCBvdXQgfiVsZCglbGQlJSkgXCIsXG4vLyAgICAvLyAgICAgICBzLT5sYXN0X2xpdCwgaW5fbGVuZ3RoLCBvdXRfbGVuZ3RoLFxuLy8gICAgLy8gICAgICAgMTAwTCAtIG91dF9sZW5ndGgqMTAwTC9pbl9sZW5ndGgpKTtcbi8vICAgIGlmIChzLm1hdGNoZXMgPCAocy5sYXN0X2xpdD4+MSkvKmludCAvMiovICYmIG91dF9sZW5ndGggPCAoaW5fbGVuZ3RoPj4xKS8qaW50IC8yKi8pIHtcbi8vICAgICAgcmV0dXJuIHRydWU7XG4vLyAgICB9XG4vLyAgfVxuLy8jZW5kaWZcblxuICByZXR1cm4gKHMubGFzdF9saXQgPT09IHMubGl0X2J1ZnNpemUgLSAxKTtcbiAgLyogV2UgYXZvaWQgZXF1YWxpdHkgd2l0aCBsaXRfYnVmc2l6ZSBiZWNhdXNlIG9mIHdyYXBhcm91bmQgYXQgNjRLXG4gICAqIG9uIDE2IGJpdCBtYWNoaW5lcyBhbmQgYmVjYXVzZSBzdG9yZWQgYmxvY2tzIGFyZSByZXN0cmljdGVkIHRvXG4gICAqIDY0Sy0xIGJ5dGVzLlxuICAgKi9cbn1cblxuZXhwb3J0cy5fdHJfaW5pdCAgPSBfdHJfaW5pdDtcbmV4cG9ydHMuX3RyX3N0b3JlZF9ibG9jayA9IF90cl9zdG9yZWRfYmxvY2s7XG5leHBvcnRzLl90cl9mbHVzaF9ibG9jayAgPSBfdHJfZmx1c2hfYmxvY2s7XG5leHBvcnRzLl90cl90YWxseSA9IF90cl90YWxseTtcbmV4cG9ydHMuX3RyX2FsaWduID0gX3RyX2FsaWduO1xuXG59LHtcIi4uL3V0aWxzL2NvbW1vblwiOjV9XSwxMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gWlN0cmVhbSgpIHtcbiAgLyogbmV4dCBpbnB1dCBieXRlICovXG4gIHRoaXMuaW5wdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9pbiA9IDA7XG4gIC8qIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUgYXQgaW5wdXQgKi9cbiAgdGhpcy5hdmFpbF9pbiA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBpbnB1dCBieXRlcyByZWFkIHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX2luID0gMDtcbiAgLyogbmV4dCBvdXRwdXQgYnl0ZSBzaG91bGQgYmUgcHV0IHRoZXJlICovXG4gIHRoaXMub3V0cHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfb3V0ID0gMDtcbiAgLyogcmVtYWluaW5nIGZyZWUgc3BhY2UgYXQgb3V0cHV0ICovXG4gIHRoaXMuYXZhaWxfb3V0ID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGJ5dGVzIG91dHB1dCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9vdXQgPSAwO1xuICAvKiBsYXN0IGVycm9yIG1lc3NhZ2UsIE5VTEwgaWYgbm8gZXJyb3IgKi9cbiAgdGhpcy5tc2cgPSAnJy8qWl9OVUxMKi87XG4gIC8qIG5vdCB2aXNpYmxlIGJ5IGFwcGxpY2F0aW9ucyAqL1xuICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgLyogYmVzdCBndWVzcyBhYm91dCB0aGUgZGF0YSB0eXBlOiBiaW5hcnkgb3IgdGV4dCAqL1xuICB0aGlzLmRhdGFfdHlwZSA9IDIvKlpfVU5LTk9XTiovO1xuICAvKiBhZGxlcjMyIHZhbHVlIG9mIHRoZSB1bmNvbXByZXNzZWQgZGF0YSAqL1xuICB0aGlzLmFkbGVyID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBaU3RyZWFtO1xuXG59LHt9XX0se30sWzNdKSgzKVxufSk7XG4iLCAiKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcucGxhbnR1bWxFbmNvZGVyID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCdcblxudmFyIHBha28gPSByZXF1aXJlKCdwYWtvL2xpYi9pbmZsYXRlLmpzJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGF0YSkge1xuICByZXR1cm4gcGFrby5pbmZsYXRlUmF3KGRhdGEsIHsgdG86ICdzdHJpbmcnIH0pXG59XG5cbn0se1wicGFrby9saWIvaW5mbGF0ZS5qc1wiOjR9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0J1xuXG4vLyBSZXZlcnNlIG9mXG4vLyBodHRwOi8vcGxhbnR1bWwuc291cmNlZm9yZ2UubmV0L2NvZGVqYXZhc2NyaXB0Mi5odG1sXG5cbi8vIEl0IGlzIGRlc2NyaWJlZCBhcyBiZWluZyBcImEgdHJhbnNmb3JtYXRpb24gY2xvc2UgdG8gYmFzZTY0XCJcbi8vIFRoZSBjb2RlIGhhcyBiZWVuIHNsaWdodGx5IG1vZGlmaWVkIHRvIHBhc3MgbGludGVyc1xuXG5mdW5jdGlvbiBkZWNvZGU2Yml0IChjYykge1xuICB2YXIgYyA9IGNjLmNoYXJDb2RlQXQoMClcbiAgaWYgKGNjID09PSAnXycpIHJldHVybiA2M1xuICBpZiAoY2MgPT09ICctJykgcmV0dXJuIDYyXG4gIGlmIChjID49IDk3KSByZXR1cm4gYyAtIDYxIC8vIC0gOTcgKyAyNiArIDEwXG4gIGlmIChjID49IDY1KSByZXR1cm4gYyAtIDU1IC8vIC0gNjUgKyAxMFxuICBpZiAoYyA+PSA0OCkgcmV0dXJuIGMgLSA0OFxuICByZXR1cm4gJz8nXG59XG5cbmZ1bmN0aW9uIGV4dHJhY3QzYnl0ZXMgKGRhdGEpIHtcbiAgdmFyIGMxID0gZGVjb2RlNmJpdChkYXRhWzBdKVxuICB2YXIgYzIgPSBkZWNvZGU2Yml0KGRhdGFbMV0pXG4gIHZhciBjMyA9IGRlY29kZTZiaXQoZGF0YVsyXSlcbiAgdmFyIGM0ID0gZGVjb2RlNmJpdChkYXRhWzNdKVxuICB2YXIgYjEgPSBjMSA8PCAyIHwgKGMyID4+IDQpICYgMHgzRlxuICB2YXIgYjIgPSAoYzIgPDwgNCkgJiAweEYwIHwgKGMzID4+IDIpICYgMHhGXG4gIHZhciBiMyA9IChjMyA8PCA2KSAmIDB4QzAgfCBjNCAmIDB4M0ZcblxuICByZXR1cm4gW2IxLCBiMiwgYjNdXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdmFyIHIgPSAnJ1xuICB2YXIgaSA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICB2YXIgdCA9IGV4dHJhY3QzYnl0ZXMoZGF0YS5zdWJzdHJpbmcoaSwgaSArIDQpKVxuICAgIHIgPSByICsgU3RyaW5nLmZyb21DaGFyQ29kZSh0WzBdKVxuICAgIHIgPSByICsgU3RyaW5nLmZyb21DaGFyQ29kZSh0WzFdKVxuICAgIHIgPSByICsgU3RyaW5nLmZyb21DaGFyQ29kZSh0WzJdKVxuICB9XG4gIHJldHVybiByXG59XG5cbn0se31dLDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnXG5cbnZhciBpbmZsYXRlID0gcmVxdWlyZSgnLi9pbmZsYXRlJylcbnZhciBkZWNvZGU2NCA9IHJlcXVpcmUoJy4vZGVjb2RlNjQnKVxuXG5tb2R1bGUuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiAoZW5jb2RlZCkge1xuICB2YXIgZGVmbGF0ZWQgPSBkZWNvZGU2NChlbmNvZGVkKVxuICByZXR1cm4gaW5mbGF0ZShkZWZsYXRlZClcbn1cblxufSx7XCIuL2RlY29kZTY0XCI6MixcIi4vaW5mbGF0ZVwiOjF9XSw0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuXG52YXIgemxpYl9pbmZsYXRlID0gcmVxdWlyZSgnLi96bGliL2luZmxhdGUnKTtcbnZhciB1dGlscyAgICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL2NvbW1vbicpO1xudmFyIHN0cmluZ3MgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvc3RyaW5ncycpO1xudmFyIGMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vemxpYi9jb25zdGFudHMnKTtcbnZhciBtc2cgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvbWVzc2FnZXMnKTtcbnZhciBaU3RyZWFtICAgICAgPSByZXF1aXJlKCcuL3psaWIvenN0cmVhbScpO1xudmFyIEdaaGVhZGVyICAgICA9IHJlcXVpcmUoJy4vemxpYi9nemhlYWRlcicpO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIGNsYXNzIEluZmxhdGVcbiAqXG4gKiBHZW5lcmljIEpTLXN0eWxlIHdyYXBwZXIgZm9yIHpsaWIgY2FsbHMuIElmIHlvdSBkb24ndCBuZWVkXG4gKiBzdHJlYW1pbmcgYmVoYXZpb3VyIC0gdXNlIG1vcmUgc2ltcGxlIGZ1bmN0aW9uczogW1tpbmZsYXRlXV1cbiAqIGFuZCBbW2luZmxhdGVSYXddXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIGluZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0luZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRkZW4uXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqXG4gKiBVbmNvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0luZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0luZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbSW5mbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKSBvciBpZiB5b3VcbiAqIHB1c2ggYSBjaHVuayB3aXRoIGV4cGxpY2l0IGZsdXNoIChjYWxsIFtbSW5mbGF0ZSNwdXNoXV0gd2l0aFxuICogYFpfU1lOQ19GTFVTSGAgcGFyYW0pLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUuZXJyIC0+IE51bWJlclxuICpcbiAqIEVycm9yIGNvZGUgYWZ0ZXIgaW5mbGF0ZSBmaW5pc2hlZC4gMCAoWl9PSykgb24gc3VjY2Vzcy5cbiAqIFNob3VsZCBiZSBjaGVja2VkIGlmIGJyb2tlbiBkYXRhIHBvc3NpYmxlLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbSW5mbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgSW5mbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBpbmZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYHdpbmRvd0JpdHNgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBpbmZsYXRlXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqICAgZnJvbSB1dGY4IHRvIHV0ZjE2IChqYXZhc2NyaXB0KSBzdHJpbmcuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsXG4gKiAgIGNodW5rIGxlbmd0aCBjYW4gZGlmZmVyIGZyb20gYGNodW5rU2l6ZWAsIGRlcGVuZGluZyBvbiBjb250ZW50LlxuICpcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gbm8gb3B0aW9ucyBzZXQsIGF1dG9kZXRlY3QgZGVmbGF0ZS9nemlwIGRhdGEgZm9ybWF0IHZpYVxuICogd3JhcHBlciBoZWFkZXIuXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGNodW5rMSA9IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqICAgLCBjaHVuazIgPSBVaW50OEFycmF5KFsxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOV0pO1xuICpcbiAqIHZhciBpbmZsYXRlID0gbmV3IHBha28uSW5mbGF0ZSh7IGxldmVsOiAzfSk7XG4gKlxuICogaW5mbGF0ZS5wdXNoKGNodW5rMSwgZmFsc2UpO1xuICogaW5mbGF0ZS5wdXNoKGNodW5rMiwgdHJ1ZSk7ICAvLyB0cnVlIC0+IGxhc3QgY2h1bmtcbiAqXG4gKiBpZiAoaW5mbGF0ZS5lcnIpIHsgdGhyb3cgbmV3IEVycm9yKGluZmxhdGUuZXJyKTsgfVxuICpcbiAqIGNvbnNvbGUubG9nKGluZmxhdGUucmVzdWx0KTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gSW5mbGF0ZShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbmZsYXRlKSkgcmV0dXJuIG5ldyBJbmZsYXRlKG9wdGlvbnMpO1xuXG4gIHRoaXMub3B0aW9ucyA9IHV0aWxzLmFzc2lnbih7XG4gICAgY2h1bmtTaXplOiAxNjM4NCxcbiAgICB3aW5kb3dCaXRzOiAwLFxuICAgIHRvOiAnJ1xuICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICB2YXIgb3B0ID0gdGhpcy5vcHRpb25zO1xuXG4gIC8vIEZvcmNlIHdpbmRvdyBzaXplIGZvciBgcmF3YCBkYXRhLCBpZiBub3Qgc2V0IGRpcmVjdGx5LFxuICAvLyBiZWNhdXNlIHdlIGhhdmUgbm8gaGVhZGVyIGZvciBhdXRvZGV0ZWN0LlxuICBpZiAob3B0LnJhdyAmJiAob3B0LndpbmRvd0JpdHMgPj0gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7XG4gICAgaWYgKG9wdC53aW5kb3dCaXRzID09PSAwKSB7IG9wdC53aW5kb3dCaXRzID0gLTE1OyB9XG4gIH1cblxuICAvLyBJZiBgd2luZG93Qml0c2Agbm90IGRlZmluZWQgKGFuZCBtb2RlIG5vdCByYXcpIC0gc2V0IGF1dG9kZXRlY3QgZmxhZyBmb3IgZ3ppcC9kZWZsYXRlXG4gIGlmICgob3B0LndpbmRvd0JpdHMgPj0gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpICYmXG4gICAgICAhKG9wdGlvbnMgJiYgb3B0aW9ucy53aW5kb3dCaXRzKSkge1xuICAgIG9wdC53aW5kb3dCaXRzICs9IDMyO1xuICB9XG5cbiAgLy8gR3ppcCBoZWFkZXIgaGFzIG5vIGluZm8gYWJvdXQgd2luZG93cyBzaXplLCB3ZSBjYW4gZG8gYXV0b2RldGVjdCBvbmx5XG4gIC8vIGZvciBkZWZsYXRlLiBTbywgaWYgd2luZG93IHNpemUgbm90IHNldCwgZm9yY2UgaXQgdG8gbWF4IHdoZW4gZ3ppcCBwb3NzaWJsZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID4gMTUpICYmIChvcHQud2luZG93Qml0cyA8IDQ4KSkge1xuICAgIC8vIGJpdCAzICgxNikgLT4gZ3ppcHBlZCBkYXRhXG4gICAgLy8gYml0IDQgKDMyKSAtPiBhdXRvZGV0ZWN0IGd6aXAvZGVmbGF0ZVxuICAgIGlmICgob3B0LndpbmRvd0JpdHMgJiAxNSkgPT09IDApIHtcbiAgICAgIG9wdC53aW5kb3dCaXRzIHw9IDE1O1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuZXJyICAgID0gMDsgICAgICAvLyBlcnJvciBjb2RlLCBpZiBoYXBwZW5zICgwID0gWl9PSylcbiAgdGhpcy5tc2cgICAgPSAnJzsgICAgIC8vIGVycm9yIG1lc3NhZ2VcbiAgdGhpcy5lbmRlZCAgPSBmYWxzZTsgIC8vIHVzZWQgdG8gYXZvaWQgbXVsdGlwbGUgb25FbmQoKSBjYWxsc1xuICB0aGlzLmNodW5rcyA9IFtdOyAgICAgLy8gY2h1bmtzIG9mIGNvbXByZXNzZWQgZGF0YVxuXG4gIHRoaXMuc3RybSAgID0gbmV3IFpTdHJlYW0oKTtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7XG5cbiAgdmFyIHN0YXR1cyAgPSB6bGliX2luZmxhdGUuaW5mbGF0ZUluaXQyKFxuICAgIHRoaXMuc3RybSxcbiAgICBvcHQud2luZG93Qml0c1xuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IGMuWl9PSykge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gIH1cblxuICB0aGlzLmhlYWRlciA9IG5ldyBHWmhlYWRlcigpO1xuXG4gIHpsaWJfaW5mbGF0ZS5pbmZsYXRlR2V0SGVhZGVyKHRoaXMuc3RybSwgdGhpcy5oZWFkZXIpO1xuXG4gIC8vIFNldHVwIGRpY3Rpb25hcnlcbiAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7XG4gICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHQuZGljdGlvbmFyeSA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKG9wdC5kaWN0aW9uYXJ5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgb3B0LmRpY3Rpb25hcnkgPSBuZXcgVWludDhBcnJheShvcHQuZGljdGlvbmFyeSk7XG4gICAgfVxuICAgIGlmIChvcHQucmF3KSB7IC8vSW4gcmF3IG1vZGUgd2UgbmVlZCB0byBzZXQgdGhlIGRpY3Rpb25hcnkgZWFybHlcbiAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIG9wdC5kaWN0aW9uYXJ5KTtcbiAgICAgIGlmIChzdGF0dXMgIT09IGMuWl9PSykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEluZmxhdGUjcHVzaChkYXRhWywgbW9kZV0pIC0+IEJvb2xlYW5cbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxBcnJheUJ1ZmZlcnxTdHJpbmcpOiBpbnB1dCBkYXRhXG4gKiAtIG1vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUUgbW9kZXMuXG4gKiAgIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILCBgdHJ1ZWAgbWVhbnMgWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBpbmZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tJbmZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBvdXRwdXQgY2h1bmtzLiBSZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzLiBUaGUgbGFzdCBkYXRhIGJsb2NrIG11c3QgaGF2ZVxuICogbW9kZSBaX0ZJTklTSCAob3IgYHRydWVgKS4gVGhhdCB3aWxsIGZsdXNoIGludGVybmFsIHBlbmRpbmcgYnVmZmVycyBhbmQgY2FsbFxuICogW1tJbmZsYXRlI29uRW5kXV0uIEZvciBpbnRlcmltIGV4cGxpY2l0IGZsdXNoZXMgKHdpdGhvdXQgZW5kaW5nIHRoZSBzdHJlYW0pIHlvdVxuICogY2FuIHVzZSBtb2RlIFpfU1lOQ19GTFVTSCwga2VlcGluZyB0aGUgZGVjb21wcmVzc2lvbiBjb250ZXh0LlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0luZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiBXZSBzdHJvbmdseSByZWNvbW1lbmQgdG8gdXNlIGBVaW50OEFycmF5YCBvbiBpbnB1dCBmb3IgYmVzdCBzcGVlZCAob3V0cHV0XG4gKiBmb3JtYXQgaXMgZGV0ZWN0ZWQgYXV0b21hdGljYWxseSkuIEFsc28sIGRvbid0IHNraXAgbGFzdCBwYXJhbSBhbmQgYWx3YXlzXG4gKiB1c2UgdGhlIHNhbWUgdHlwZSBpbiB5b3VyIGNvZGUgKGJvb2xlYW4gb3IgbnVtYmVyKS4gVGhhdCB3aWxsIGltcHJvdmUgSlMgc3BlZWQuXG4gKlxuICogRm9yIHJlZ3VsYXIgYEFycmF5YC1zIG1ha2Ugc3VyZSBhbGwgZWxlbWVudHMgYXJlIFswLi4yNTVdLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBwdXNoKGNodW5rLCBmYWxzZSk7IC8vIHB1c2ggb25lIG9mIGRhdGEgY2h1bmtzXG4gKiAuLi5cbiAqIHB1c2goY2h1bmssIHRydWUpOyAgLy8gcHVzaCBsYXN0IGNodW5rXG4gKiBgYGBcbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgbW9kZSkge1xuICB2YXIgc3RybSA9IHRoaXMuc3RybTtcbiAgdmFyIGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7XG4gIHZhciBkaWN0aW9uYXJ5ID0gdGhpcy5vcHRpb25zLmRpY3Rpb25hcnk7XG4gIHZhciBzdGF0dXMsIF9tb2RlO1xuICB2YXIgbmV4dF9vdXRfdXRmOCwgdGFpbCwgdXRmOHN0cjtcblxuICAvLyBGbGFnIHRvIHByb3Blcmx5IHByb2Nlc3MgWl9CVUZfRVJST1Igb24gdGVzdGluZyBpbmZsYXRlIGNhbGxcbiAgLy8gd2hlbiB3ZSBjaGVjayB0aGF0IGFsbCBvdXRwdXQgZGF0YSB3YXMgZmx1c2hlZC5cbiAgdmFyIGFsbG93QnVmRXJyb3IgPSBmYWxzZTtcblxuICBpZiAodGhpcy5lbmRlZCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgX21vZGUgPSAobW9kZSA9PT0gfn5tb2RlKSA/IG1vZGUgOiAoKG1vZGUgPT09IHRydWUpID8gYy5aX0ZJTklTSCA6IGMuWl9OT19GTFVTSCk7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gT25seSBiaW5hcnkgc3RyaW5ncyBjYW4gYmUgZGVjb21wcmVzc2VkIG9uIHByYWN0aWNlXG4gICAgc3RybS5pbnB1dCA9IHN0cmluZ3MuYmluc3RyaW5nMmJ1ZihkYXRhKTtcbiAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKGRhdGEpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgc3RybS5pbnB1dCA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHN0cm0uaW5wdXQgPSBkYXRhO1xuICB9XG5cbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5hdmFpbF9pbiA9IHN0cm0uaW5wdXQubGVuZ3RoO1xuXG4gIGRvIHtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHN0cm0ub3V0cHV0ID0gbmV3IHV0aWxzLkJ1ZjgoY2h1bmtTaXplKTtcbiAgICAgIHN0cm0ubmV4dF9vdXQgPSAwO1xuICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemU7XG4gICAgfVxuXG4gICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGUoc3RybSwgYy5aX05PX0ZMVVNIKTsgICAgLyogbm8gYmFkIHJldHVybiB2YWx1ZSAqL1xuXG4gICAgaWYgKHN0YXR1cyA9PT0gYy5aX05FRURfRElDVCAmJiBkaWN0aW9uYXJ5KSB7XG4gICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBkaWN0aW9uYXJ5KTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID09PSBjLlpfQlVGX0VSUk9SICYmIGFsbG93QnVmRXJyb3IgPT09IHRydWUpIHtcbiAgICAgIHN0YXR1cyA9IGMuWl9PSztcbiAgICAgIGFsbG93QnVmRXJyb3IgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzICE9PSBjLlpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IGMuWl9PSykge1xuICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHN0cm0ubmV4dF9vdXQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCB8fCBzdGF0dXMgPT09IGMuWl9TVFJFQU1fRU5EIHx8IChzdHJtLmF2YWlsX2luID09PSAwICYmIChfbW9kZSA9PT0gYy5aX0ZJTklTSCB8fCBfbW9kZSA9PT0gYy5aX1NZTkNfRkxVU0gpKSkge1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICBuZXh0X291dF91dGY4ID0gc3RyaW5ncy51dGY4Ym9yZGVyKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KTtcblxuICAgICAgICAgIHRhaWwgPSBzdHJtLm5leHRfb3V0IC0gbmV4dF9vdXRfdXRmODtcbiAgICAgICAgICB1dGY4c3RyID0gc3RyaW5ncy5idWYyc3RyaW5nKHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4KTtcblxuICAgICAgICAgIC8vIG1vdmUgdGFpbFxuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSB0YWlsO1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplIC0gdGFpbDtcbiAgICAgICAgICBpZiAodGFpbCkgeyB1dGlscy5hcnJheVNldChzdHJtLm91dHB1dCwgc3RybS5vdXRwdXQsIG5leHRfb3V0X3V0ZjgsIHRhaWwsIDApOyB9XG5cbiAgICAgICAgICB0aGlzLm9uRGF0YSh1dGY4c3RyKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub25EYXRhKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2hlbiBubyBtb3JlIGlucHV0IGRhdGEsIHdlIHNob3VsZCBjaGVjayB0aGF0IGludGVybmFsIGluZmxhdGUgYnVmZmVyc1xuICAgIC8vIGFyZSBmbHVzaGVkLiBUaGUgb25seSB3YXkgdG8gZG8gaXQgd2hlbiBhdmFpbF9vdXQgPSAwIC0gcnVuIG9uZSBtb3JlXG4gICAgLy8gaW5mbGF0ZSBwYXNzLiBCdXQgaWYgb3V0cHV0IGRhdGEgbm90IGV4aXN0cywgaW5mbGF0ZSByZXR1cm4gWl9CVUZfRVJST1IuXG4gICAgLy8gSGVyZSB3ZSBzZXQgZmxhZyB0byBwcm9jZXNzIHRoaXMgZXJyb3IgcHJvcGVybHkuXG4gICAgLy9cbiAgICAvLyBOT1RFLiBEZWZsYXRlIGRvZXMgbm90IHJldHVybiBlcnJvciBpbiB0aGlzIGNhc2UgYW5kIGRvZXMgbm90IG5lZWRzIHN1Y2hcbiAgICAvLyBsb2dpYy5cbiAgICBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiBzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgYWxsb3dCdWZFcnJvciA9IHRydWU7XG4gICAgfVxuXG4gIH0gd2hpbGUgKChzdHJtLmF2YWlsX2luID4gMCB8fCBzdHJtLmF2YWlsX291dCA9PT0gMCkgJiYgc3RhdHVzICE9PSBjLlpfU1RSRUFNX0VORCk7XG5cbiAgaWYgKHN0YXR1cyA9PT0gYy5aX1NUUkVBTV9FTkQpIHtcbiAgICBfbW9kZSA9IGMuWl9GSU5JU0g7XG4gIH1cblxuICAvLyBGaW5hbGl6ZSBvbiB0aGUgbGFzdCBjaHVuay5cbiAgaWYgKF9tb2RlID09PSBjLlpfRklOSVNIKSB7XG4gICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gYy5aX09LO1xuICB9XG5cbiAgLy8gY2FsbGJhY2sgaW50ZXJpbSByZXN1bHRzIGlmIFpfU1lOQ19GTFVTSC5cbiAgaWYgKF9tb2RlID09PSBjLlpfU1lOQ19GTFVTSCkge1xuICAgIHRoaXMub25FbmQoYy5aX09LKTtcbiAgICBzdHJtLmF2YWlsX291dCA9IDA7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBJbmZsYXRlI29uRGF0YShjaHVuaykgLT4gVm9pZFxuICogLSBjaHVuayAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBvdXRwdXQgZGF0YS4gVHlwZSBvZiBhcnJheSBkZXBlbmRzXG4gKiAgIG9uIGpzIGVuZ2luZSBzdXBwb3J0LiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLCBlYWNoIGNodW5rXG4gKiAgIHdpbGwgYmUgc3RyaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIEluZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogaW5mbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgZWl0aGVyIGFmdGVyIHlvdSB0ZWxsIGluZmxhdGUgdGhhdCB0aGUgaW5wdXQgc3RyZWFtIGlzXG4gKiBjb21wbGV0ZSAoWl9GSU5JU0gpIG9yIHNob3VsZCBiZSBmbHVzaGVkIChaX1NZTkNfRkxVU0gpXG4gKiBvciBpZiBhbiBlcnJvciBoYXBwZW5lZC4gQnkgZGVmYXVsdCAtIGpvaW4gY29sbGVjdGVkIGNodW5rcyxcbiAqIGZyZWUgbWVtb3J5IGFuZCBmaWxsIGByZXN1bHRzYCAvIGBlcnJgIHByb3BlcnRpZXMuXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgLy8gT24gc3VjY2VzcyAtIGpvaW5cbiAgaWYgKHN0YXR1cyA9PT0gYy5aX09LKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIEdsdWUgJiBjb252ZXJ0IGhlcmUsIHVudGlsIHdlIHRlYWNoIHBha28gdG8gc2VuZFxuICAgICAgLy8gdXRmOCBhbGlnbmVkIHN0cmluZ3MgdG8gb25EYXRhXG4gICAgICB0aGlzLnJlc3VsdCA9IHRoaXMuY2h1bmtzLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IHV0aWxzLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpO1xuICAgIH1cbiAgfVxuICB0aGlzLmNodW5rcyA9IFtdO1xuICB0aGlzLmVyciA9IHN0YXR1cztcbiAgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnO1xufTtcblxuXG4vKipcbiAqIGluZmxhdGUoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogRGVjb21wcmVzcyBgZGF0YWAgd2l0aCBpbmZsYXRlL3VuZ3ppcCBhbmQgYG9wdGlvbnNgLiBBdXRvZGV0ZWN0XG4gKiBmb3JtYXQgdmlhIHdyYXBwZXIgaGVhZGVyIGJ5IGRlZmF1bHQuIFRoYXQncyB3aHkgd2UgZG9uJ3QgcHJvdmlkZVxuICogc2VwYXJhdGUgYHVuZ3ppcGAgbWV0aG9kLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIHdpbmRvd0JpdHNcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBTdWdhciAob3B0aW9ucyk6XG4gKlxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBzYXkgdGhhdCB3ZSB3b3JrIHdpdGggcmF3IHN0cmVhbSwgaWYgeW91IGRvbid0IHdpc2ggdG8gc3BlY2lmeVxuICogICBuZWdhdGl2ZSB3aW5kb3dCaXRzIGltcGxpY2l0bHkuXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqICAgZnJvbSB1dGY4IHRvIHV0ZjE2IChqYXZhc2NyaXB0KSBzdHJpbmcuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsXG4gKiAgIGNodW5rIGxlbmd0aCBjYW4gZGlmZmVyIGZyb20gYGNodW5rU2l6ZWAsIGRlcGVuZGluZyBvbiBjb250ZW50LlxuICpcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgaW5wdXQgPSBwYWtvLmRlZmxhdGUoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqICAgLCBvdXRwdXQ7XG4gKlxuICogdHJ5IHtcbiAqICAgb3V0cHV0ID0gcGFrby5pbmZsYXRlKGlucHV0KTtcbiAqIH0gY2F0Y2ggKGVycilcbiAqICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH1cbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gaW5mbGF0ZShpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgaW5mbGF0b3IgPSBuZXcgSW5mbGF0ZShvcHRpb25zKTtcblxuICBpbmZsYXRvci5wdXNoKGlucHV0LCB0cnVlKTtcblxuICAvLyBUaGF0IHdpbGwgbmV2ZXIgaGFwcGVucywgaWYgeW91IGRvbid0IGNoZWF0IHdpdGggb3B0aW9ucyA6KVxuICBpZiAoaW5mbGF0b3IuZXJyKSB7IHRocm93IGluZmxhdG9yLm1zZyB8fCBtc2dbaW5mbGF0b3IuZXJyXTsgfVxuXG4gIHJldHVybiBpbmZsYXRvci5yZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBpbmZsYXRlUmF3KGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbaW5mbGF0ZV1dLCBidXQgY3JlYXRlcyByYXcgZGF0YSwgd2l0aG91dCB3cmFwcGVyXG4gKiAoaGVhZGVyIGFuZCBhZGxlcjMyIGNyYykuXG4gKiovXG5mdW5jdGlvbiBpbmZsYXRlUmF3KGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnJhdyA9IHRydWU7XG4gIHJldHVybiBpbmZsYXRlKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIHVuZ3ppcChkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBKdXN0IHNob3J0Y3V0IHRvIFtbaW5mbGF0ZV1dLCBiZWNhdXNlIGl0IGF1dG9kZXRlY3RzIGZvcm1hdFxuICogYnkgaGVhZGVyLmNvbnRlbnQuIERvbmUgZm9yIGNvbnZlbmllbmNlLlxuICoqL1xuXG5cbmV4cG9ydHMuSW5mbGF0ZSA9IEluZmxhdGU7XG5leHBvcnRzLmluZmxhdGUgPSBpbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlUmF3ID0gaW5mbGF0ZVJhdztcbmV4cG9ydHMudW5nemlwICA9IGluZmxhdGU7XG5cbn0se1wiLi91dGlscy9jb21tb25cIjo1LFwiLi91dGlscy9zdHJpbmdzXCI6NixcIi4vemxpYi9jb25zdGFudHNcIjo4LFwiLi96bGliL2d6aGVhZGVyXCI6MTAsXCIuL3psaWIvaW5mbGF0ZVwiOjEyLFwiLi96bGliL21lc3NhZ2VzXCI6MTQsXCIuL3psaWIvenN0cmVhbVwiOjE1fV0sNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFRZUEVEX09LID0gICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBVaW50MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBJbnQzMkFycmF5ICE9PSAndW5kZWZpbmVkJyk7XG5cbmZ1bmN0aW9uIF9oYXMob2JqLCBrZXkpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG5cbmV4cG9ydHMuYXNzaWduID0gZnVuY3Rpb24gKG9iaiAvKmZyb20xLCBmcm9tMiwgZnJvbTMsIC4uLiovKSB7XG4gIHZhciBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgd2hpbGUgKHNvdXJjZXMubGVuZ3RoKSB7XG4gICAgdmFyIHNvdXJjZSA9IHNvdXJjZXMuc2hpZnQoKTtcbiAgICBpZiAoIXNvdXJjZSkgeyBjb250aW51ZTsgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHNvdXJjZSArICdtdXN0IGJlIG5vbi1vYmplY3QnKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBwIGluIHNvdXJjZSkge1xuICAgICAgaWYgKF9oYXMoc291cmNlLCBwKSkge1xuICAgICAgICBvYmpbcF0gPSBzb3VyY2VbcF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cblxuLy8gcmVkdWNlIGJ1ZmZlciBzaXplLCBhdm9pZGluZyBtZW0gY29weVxuZXhwb3J0cy5zaHJpbmtCdWYgPSBmdW5jdGlvbiAoYnVmLCBzaXplKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSBzaXplKSB7IHJldHVybiBidWY7IH1cbiAgaWYgKGJ1Zi5zdWJhcnJheSkgeyByZXR1cm4gYnVmLnN1YmFycmF5KDAsIHNpemUpOyB9XG4gIGJ1Zi5sZW5ndGggPSBzaXplO1xuICByZXR1cm4gYnVmO1xufTtcblxuXG52YXIgZm5UeXBlZCA9IHtcbiAgYXJyYXlTZXQ6IGZ1bmN0aW9uIChkZXN0LCBzcmMsIHNyY19vZmZzLCBsZW4sIGRlc3Rfb2Zmcykge1xuICAgIGlmIChzcmMuc3ViYXJyYXkgJiYgZGVzdC5zdWJhcnJheSkge1xuICAgICAgZGVzdC5zZXQoc3JjLnN1YmFycmF5KHNyY19vZmZzLCBzcmNfb2ZmcyArIGxlbiksIGRlc3Rfb2Zmcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrIHRvIG9yZGluYXJ5IGFycmF5XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldO1xuICAgIH1cbiAgfSxcbiAgLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LlxuICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbiAoY2h1bmtzKSB7XG4gICAgdmFyIGksIGwsIGxlbiwgcG9zLCBjaHVuaywgcmVzdWx0O1xuXG4gICAgLy8gY2FsY3VsYXRlIGRhdGEgbGVuZ3RoXG4gICAgbGVuID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbGVuICs9IGNodW5rc1tpXS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gam9pbiBjaHVua3NcbiAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgIHBvcyA9IDA7XG4gICAgZm9yIChpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNodW5rID0gY2h1bmtzW2ldO1xuICAgICAgcmVzdWx0LnNldChjaHVuaywgcG9zKTtcbiAgICAgIHBvcyArPSBjaHVuay5sZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxudmFyIGZuVW50eXBlZCA9IHtcbiAgYXJyYXlTZXQ6IGZ1bmN0aW9uIChkZXN0LCBzcmMsIHNyY19vZmZzLCBsZW4sIGRlc3Rfb2Zmcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTtcbiAgICB9XG4gIH0sXG4gIC8vIEpvaW4gYXJyYXkgb2YgY2h1bmtzIHRvIHNpbmdsZSBhcnJheS5cbiAgZmxhdHRlbkNodW5rczogZnVuY3Rpb24gKGNodW5rcykge1xuICAgIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIGNodW5rcyk7XG4gIH1cbn07XG5cblxuLy8gRW5hYmxlL0Rpc2FibGUgdHlwZWQgYXJyYXlzIHVzZSwgZm9yIHRlc3Rpbmdcbi8vXG5leHBvcnRzLnNldFR5cGVkID0gZnVuY3Rpb24gKG9uKSB7XG4gIGlmIChvbikge1xuICAgIGV4cG9ydHMuQnVmOCAgPSBVaW50OEFycmF5O1xuICAgIGV4cG9ydHMuQnVmMTYgPSBVaW50MTZBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjMyID0gSW50MzJBcnJheTtcbiAgICBleHBvcnRzLmFzc2lnbihleHBvcnRzLCBmblR5cGVkKTtcbiAgfSBlbHNlIHtcbiAgICBleHBvcnRzLkJ1ZjggID0gQXJyYXk7XG4gICAgZXhwb3J0cy5CdWYxNiA9IEFycmF5O1xuICAgIGV4cG9ydHMuQnVmMzIgPSBBcnJheTtcbiAgICBleHBvcnRzLmFzc2lnbihleHBvcnRzLCBmblVudHlwZWQpO1xuICB9XG59O1xuXG5leHBvcnRzLnNldFR5cGVkKFRZUEVEX09LKTtcblxufSx7fV0sNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBTdHJpbmcgZW5jb2RlL2RlY29kZSBoZWxwZXJzXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuXG4vLyBRdWljayBjaGVjayBpZiB3ZSBjYW4gdXNlIGZhc3QgYXJyYXkgdG8gYmluIHN0cmluZyBjb252ZXJzaW9uXG4vL1xuLy8gLSBhcHBseShBcnJheSkgY2FuIGZhaWwgb24gQW5kcm9pZCAyLjJcbi8vIC0gYXBwbHkoVWludDhBcnJheSkgY2FuIGZhaWwgb24gaU9TIDUuMSBTYWZhcmlcbi8vXG52YXIgU1RSX0FQUExZX09LID0gdHJ1ZTtcbnZhciBTVFJfQVBQTFlfVUlBX09LID0gdHJ1ZTtcblxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBbIDAgXSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9PSyA9IGZhbHNlOyB9XG50cnkgeyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KDEpKTsgfSBjYXRjaCAoX18pIHsgU1RSX0FQUExZX1VJQV9PSyA9IGZhbHNlOyB9XG5cblxuLy8gVGFibGUgd2l0aCB1dGY4IGxlbmd0aHMgKGNhbGN1bGF0ZWQgYnkgZmlyc3QgYnl0ZSBvZiBzZXF1ZW5jZSlcbi8vIE5vdGUsIHRoYXQgNSAmIDYtYnl0ZSB2YWx1ZXMgYW5kIHNvbWUgNC1ieXRlIHZhbHVlcyBjYW4gbm90IGJlIHJlcHJlc2VudGVkIGluIEpTLFxuLy8gYmVjYXVzZSBtYXggcG9zc2libGUgY29kZXBvaW50IGlzIDB4MTBmZmZmXG52YXIgX3V0ZjhsZW4gPSBuZXcgdXRpbHMuQnVmOCgyNTYpO1xuZm9yICh2YXIgcSA9IDA7IHEgPCAyNTY7IHErKykge1xuICBfdXRmOGxlbltxXSA9IChxID49IDI1MiA/IDYgOiBxID49IDI0OCA/IDUgOiBxID49IDI0MCA/IDQgOiBxID49IDIyNCA/IDMgOiBxID49IDE5MiA/IDIgOiAxKTtcbn1cbl91dGY4bGVuWzI1NF0gPSBfdXRmOGxlblsyNTRdID0gMTsgLy8gSW52YWxpZCBzZXF1ZW5jZSBzdGFydFxuXG5cbi8vIGNvbnZlcnQgc3RyaW5nIHRvIGFycmF5ICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbmV4cG9ydHMuc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGJ1ZiwgYywgYzIsIG1fcG9zLCBpLCBzdHJfbGVuID0gc3RyLmxlbmd0aCwgYnVmX2xlbiA9IDA7XG5cbiAgLy8gY291bnQgYmluYXJ5IHNpemVcbiAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcyArIDEgPCBzdHJfbGVuKSkge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbV9wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgYnVmX2xlbiArPSBjIDwgMHg4MCA/IDEgOiBjIDwgMHg4MDAgPyAyIDogYyA8IDB4MTAwMDAgPyAzIDogNDtcbiAgfVxuXG4gIC8vIGFsbG9jYXRlIGJ1ZmZlclxuICBidWYgPSBuZXcgdXRpbHMuQnVmOChidWZfbGVuKTtcblxuICAvLyBjb252ZXJ0XG4gIGZvciAoaSA9IDAsIG1fcG9zID0gMDsgaSA8IGJ1Zl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgLyogb25lIGJ5dGUgKi9cbiAgICAgIGJ1ZltpKytdID0gYztcbiAgICB9IGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgLyogdHdvIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4QzAgfCAoYyA+Pj4gNik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIC8qIHRocmVlIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4RTAgfCAoYyA+Pj4gMTIpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGZvdXIgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhmMCB8IChjID4+PiAxOCk7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gMTIgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWY7XG59O1xuXG4vLyBIZWxwZXIgKHVzZWQgaW4gMiBwbGFjZXMpXG5mdW5jdGlvbiBidWYyYmluc3RyaW5nKGJ1ZiwgbGVuKSB7XG4gIC8vIE9uIENocm9tZSwgdGhlIGFyZ3VtZW50cyBpbiBhIGZ1bmN0aW9uIGNhbGwgdGhhdCBhcmUgYWxsb3dlZCBpcyBgNjU1MzRgLlxuICAvLyBJZiB0aGUgbGVuZ3RoIG9mIHRoZSBidWZmZXIgaXMgc21hbGxlciB0aGFuIHRoYXQsIHdlIGNhbiB1c2UgdGhpcyBvcHRpbWl6YXRpb24sXG4gIC8vIG90aGVyd2lzZSB3ZSB3aWxsIHRha2UgYSBzbG93ZXIgcGF0aC5cbiAgaWYgKGxlbiA8IDY1NTM0KSB7XG4gICAgaWYgKChidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX1VJQV9PSykgfHwgKCFidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX09LKSkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdXRpbHMuc2hyaW5rQnVmKGJ1ZiwgbGVuKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8vIENvbnZlcnQgYnl0ZSBhcnJheSB0byBiaW5hcnkgc3RyaW5nXG5leHBvcnRzLmJ1ZjJiaW5zdHJpbmcgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHJldHVybiBidWYyYmluc3RyaW5nKGJ1ZiwgYnVmLmxlbmd0aCk7XG59O1xuXG5cbi8vIENvbnZlcnQgYmluYXJ5IHN0cmluZyAodHlwZWQsIHdoZW4gcG9zc2libGUpXG5leHBvcnRzLmJpbnN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYgPSBuZXcgdXRpbHMuQnVmOChzdHIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGJ1ZltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBidWY7XG59O1xuXG5cbi8vIGNvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG5leHBvcnRzLmJ1ZjJzdHJpbmcgPSBmdW5jdGlvbiAoYnVmLCBtYXgpIHtcbiAgdmFyIGksIG91dCwgYywgY19sZW47XG4gIHZhciBsZW4gPSBtYXggfHwgYnVmLmxlbmd0aDtcblxuICAvLyBSZXNlcnZlIG1heCBwb3NzaWJsZSBsZW5ndGggKDIgd29yZHMgcGVyIGNoYXIpXG4gIC8vIE5COiBieSB1bmtub3duIHJlYXNvbnMsIEFycmF5IGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIGZvclxuICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LlxuICB2YXIgdXRmMTZidWYgPSBuZXcgQXJyYXkobGVuICogMik7XG5cbiAgZm9yIChvdXQgPSAwLCBpID0gMDsgaSA8IGxlbjspIHtcbiAgICBjID0gYnVmW2krK107XG4gICAgLy8gcXVpY2sgcHJvY2VzcyBhc2NpaVxuICAgIGlmIChjIDwgMHg4MCkgeyB1dGYxNmJ1ZltvdXQrK10gPSBjOyBjb250aW51ZTsgfVxuXG4gICAgY19sZW4gPSBfdXRmOGxlbltjXTtcbiAgICAvLyBza2lwIDUgJiA2IGJ5dGUgY29kZXNcbiAgICBpZiAoY19sZW4gPiA0KSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgaSArPSBjX2xlbiAtIDE7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBhcHBseSBtYXNrIG9uIGZpcnN0IGJ5dGVcbiAgICBjICY9IGNfbGVuID09PSAyID8gMHgxZiA6IGNfbGVuID09PSAzID8gMHgwZiA6IDB4MDc7XG4gICAgLy8gam9pbiB0aGUgcmVzdFxuICAgIHdoaWxlIChjX2xlbiA+IDEgJiYgaSA8IGxlbikge1xuICAgICAgYyA9IChjIDw8IDYpIHwgKGJ1ZltpKytdICYgMHgzZik7XG4gICAgICBjX2xlbi0tO1xuICAgIH1cblxuICAgIC8vIHRlcm1pbmF0ZWQgYnkgZW5kIG9mIHN0cmluZz9cbiAgICBpZiAoY19sZW4gPiAxKSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgY29udGludWU7IH1cblxuICAgIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gYztcbiAgICB9IGVsc2Uge1xuICAgICAgYyAtPSAweDEwMDAwO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkODAwIHwgKChjID4+IDEwKSAmIDB4M2ZmKTtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZGMwMCB8IChjICYgMHgzZmYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYyYmluc3RyaW5nKHV0ZjE2YnVmLCBvdXQpO1xufTtcblxuXG4vLyBDYWxjdWxhdGUgbWF4IHBvc3NpYmxlIHBvc2l0aW9uIGluIHV0ZjggYnVmZmVyLFxuLy8gdGhhdCB3aWxsIG5vdCBicmVhayBzZXF1ZW5jZS4gSWYgdGhhdCdzIG5vdCBwb3NzaWJsZVxuLy8gLSAodmVyeSBzbWFsbCBsaW1pdHMpIHJldHVybiBtYXggc2l6ZSBhcyBpcy5cbi8vXG4vLyBidWZbXSAtIHV0ZjggYnl0ZXMgYXJyYXlcbi8vIG1heCAgIC0gbGVuZ3RoIGxpbWl0IChtYW5kYXRvcnkpO1xuZXhwb3J0cy51dGY4Ym9yZGVyID0gZnVuY3Rpb24gKGJ1ZiwgbWF4KSB7XG4gIHZhciBwb3M7XG5cbiAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH1cblxuICAvLyBnbyBiYWNrIGZyb20gbGFzdCBwb3NpdGlvbiwgdW50aWwgc3RhcnQgb2Ygc2VxdWVuY2UgZm91bmRcbiAgcG9zID0gbWF4IC0gMTtcbiAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDB4QzApID09PSAweDgwKSB7IHBvcy0tOyB9XG5cbiAgLy8gVmVyeSBzbWFsbCBhbmQgYnJva2VuIHNlcXVlbmNlLFxuICAvLyByZXR1cm4gbWF4LCBiZWNhdXNlIHdlIHNob3VsZCByZXR1cm4gc29tZXRoaW5nIGFueXdheS5cbiAgaWYgKHBvcyA8IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIC8vIElmIHdlIGNhbWUgdG8gc3RhcnQgb2YgYnVmZmVyIC0gdGhhdCBtZWFucyBidWZmZXIgaXMgdG9vIHNtYWxsLFxuICAvLyByZXR1cm4gbWF4IHRvby5cbiAgaWYgKHBvcyA9PT0gMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgcmV0dXJuIChwb3MgKyBfdXRmOGxlbltidWZbcG9zXV0gPiBtYXgpID8gcG9zIDogbWF4O1xufTtcblxufSx7XCIuL2NvbW1vblwiOjV9XSw3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogYWRsZXIzMiB0YWtlcyAxMiUgZm9yIGxldmVsIDAgYW5kIDIlIGZvciBsZXZlbCA2LlxuLy8gSXQgaXNuJ3Qgd29ydGggaXQgdG8gbWFrZSBhZGRpdGlvbmFsIG9wdGltaXphdGlvbnMgYXMgaW4gb3JpZ2luYWwuXG4vLyBTbWFsbCBzaXplIGlzIHByZWZlcmFibGUuXG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gYWRsZXIzMihhZGxlciwgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgczEgPSAoYWRsZXIgJiAweGZmZmYpIHwwLFxuICAgICAgczIgPSAoKGFkbGVyID4+PiAxNikgJiAweGZmZmYpIHwwLFxuICAgICAgbiA9IDA7XG5cbiAgd2hpbGUgKGxlbiAhPT0gMCkge1xuICAgIC8vIFNldCBsaW1pdCB+IHR3aWNlIGxlc3MgdGhhbiA1NTUyLCB0byBrZWVwXG4gICAgLy8gczIgaW4gMzEtYml0cywgYmVjYXVzZSB3ZSBmb3JjZSBzaWduZWQgaW50cy5cbiAgICAvLyBpbiBvdGhlciBjYXNlICU9IHdpbGwgZmFpbC5cbiAgICBuID0gbGVuID4gMjAwMCA/IDIwMDAgOiBsZW47XG4gICAgbGVuIC09IG47XG5cbiAgICBkbyB7XG4gICAgICBzMSA9IChzMSArIGJ1Zltwb3MrK10pIHwwO1xuICAgICAgczIgPSAoczIgKyBzMSkgfDA7XG4gICAgfSB3aGlsZSAoLS1uKTtcblxuICAgIHMxICU9IDY1NTIxO1xuICAgIHMyICU9IDY1NTIxO1xuICB9XG5cbiAgcmV0dXJuIChzMSB8IChzMiA8PCAxNikpIHwwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjtcblxufSx7fV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuICBaX05PX0ZMVVNIOiAgICAgICAgIDAsXG4gIFpfUEFSVElBTF9GTFVTSDogICAgMSxcbiAgWl9TWU5DX0ZMVVNIOiAgICAgICAyLFxuICBaX0ZVTExfRkxVU0g6ICAgICAgIDMsXG4gIFpfRklOSVNIOiAgICAgICAgICAgNCxcbiAgWl9CTE9DSzogICAgICAgICAgICA1LFxuICBaX1RSRUVTOiAgICAgICAgICAgIDYsXG5cbiAgLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAgKi9cbiAgWl9PSzogICAgICAgICAgICAgICAwLFxuICBaX1NUUkVBTV9FTkQ6ICAgICAgIDEsXG4gIFpfTkVFRF9ESUNUOiAgICAgICAgMixcbiAgWl9FUlJOTzogICAgICAgICAgIC0xLFxuICBaX1NUUkVBTV9FUlJPUjogICAgLTIsXG4gIFpfREFUQV9FUlJPUjogICAgICAtMyxcbiAgLy9aX01FTV9FUlJPUjogICAgIC00LFxuICBaX0JVRl9FUlJPUjogICAgICAgLTUsXG4gIC8vWl9WRVJTSU9OX0VSUk9SOiAtNixcblxuICAvKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbiAgWl9OT19DT01QUkVTU0lPTjogICAgICAgICAwLFxuICBaX0JFU1RfU1BFRUQ6ICAgICAgICAgICAgIDEsXG4gIFpfQkVTVF9DT01QUkVTU0lPTjogICAgICAgOSxcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiAgIC0xLFxuXG5cbiAgWl9GSUxURVJFRDogICAgICAgICAgICAgICAxLFxuICBaX0hVRkZNQU5fT05MWTogICAgICAgICAgIDIsXG4gIFpfUkxFOiAgICAgICAgICAgICAgICAgICAgMyxcbiAgWl9GSVhFRDogICAgICAgICAgICAgICAgICA0LFxuICBaX0RFRkFVTFRfU1RSQVRFR1k6ICAgICAgIDAsXG5cbiAgLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuICBaX0JJTkFSWTogICAgICAgICAgICAgICAgIDAsXG4gIFpfVEVYVDogICAgICAgICAgICAgICAgICAgMSxcbiAgLy9aX0FTQ0lJOiAgICAgICAgICAgICAgICAxLCAvLyA9IFpfVEVYVCAoZGVwcmVjYXRlZClcbiAgWl9VTktOT1dOOiAgICAgICAgICAgICAgICAyLFxuXG4gIC8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xuICBaX0RFRkxBVEVEOiAgICAgICAgICAgICAgIDhcbiAgLy9aX05VTEw6ICAgICAgICAgICAgICAgICBudWxsIC8vIFVzZSAtMSBvciBudWxsIGlubGluZSwgZGVwZW5kaW5nIG9uIHZhciB0eXBlXG59O1xuXG59LHt9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogd2UgY2FuJ3QgZ2V0IHNpZ25pZmljYW50IHNwZWVkIGJvb3N0IGhlcmUuXG4vLyBTbyB3cml0ZSBjb2RlIHRvIG1pbmltaXplIHNpemUgLSBubyBwcmVnZW5lcmF0ZWQgdGFibGVzXG4vLyBhbmQgYXJyYXkgdG9vbHMgZGVwZW5kZW5jaWVzLlxuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8vIFVzZSBvcmRpbmFyeSBhcnJheSwgc2luY2UgdW50eXBlZCBtYWtlcyBubyBib29zdCBoZXJlXG5mdW5jdGlvbiBtYWtlVGFibGUoKSB7XG4gIHZhciBjLCB0YWJsZSA9IFtdO1xuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgMjU2OyBuKyspIHtcbiAgICBjID0gbjtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IDg7IGsrKykge1xuICAgICAgYyA9ICgoYyAmIDEpID8gKDB4RURCODgzMjAgXiAoYyA+Pj4gMSkpIDogKGMgPj4+IDEpKTtcbiAgICB9XG4gICAgdGFibGVbbl0gPSBjO1xuICB9XG5cbiAgcmV0dXJuIHRhYmxlO1xufVxuXG4vLyBDcmVhdGUgdGFibGUgb24gbG9hZC4gSnVzdCAyNTUgc2lnbmVkIGxvbmdzLiBOb3QgYSBwcm9ibGVtLlxudmFyIGNyY1RhYmxlID0gbWFrZVRhYmxlKCk7XG5cblxuZnVuY3Rpb24gY3JjMzIoY3JjLCBidWYsIGxlbiwgcG9zKSB7XG4gIHZhciB0ID0gY3JjVGFibGUsXG4gICAgICBlbmQgPSBwb3MgKyBsZW47XG5cbiAgY3JjIF49IC0xO1xuXG4gIGZvciAodmFyIGkgPSBwb3M7IGkgPCBlbmQ7IGkrKykge1xuICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdFsoY3JjIF4gYnVmW2ldKSAmIDB4RkZdO1xuICB9XG5cbiAgcmV0dXJuIChjcmMgXiAoLTEpKTsgLy8gPj4+IDA7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBjcmMzMjtcblxufSx7fV0sMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIEdaaGVhZGVyKCkge1xuICAvKiB0cnVlIGlmIGNvbXByZXNzZWQgZGF0YSBiZWxpZXZlZCB0byBiZSB0ZXh0ICovXG4gIHRoaXMudGV4dCAgICAgICA9IDA7XG4gIC8qIG1vZGlmaWNhdGlvbiB0aW1lICovXG4gIHRoaXMudGltZSAgICAgICA9IDA7XG4gIC8qIGV4dHJhIGZsYWdzIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovXG4gIHRoaXMueGZsYWdzICAgICA9IDA7XG4gIC8qIG9wZXJhdGluZyBzeXN0ZW0gKi9cbiAgdGhpcy5vcyAgICAgICAgID0gMDtcbiAgLyogcG9pbnRlciB0byBleHRyYSBmaWVsZCBvciBaX05VTEwgaWYgbm9uZSAqL1xuICB0aGlzLmV4dHJhICAgICAgPSBudWxsO1xuICAvKiBleHRyYSBmaWVsZCBsZW5ndGggKHZhbGlkIGlmIGV4dHJhICE9IFpfTlVMTCkgKi9cbiAgdGhpcy5leHRyYV9sZW4gID0gMDsgLy8gQWN0dWFsbHksIHdlIGRvbid0IG5lZWQgaXQgaW4gSlMsXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBsZWF2ZSBmb3IgZmV3IGNvZGUgbW9kaWZpY2F0aW9uc1xuXG4gIC8vXG4gIC8vIFNldHVwIGxpbWl0cyBpcyBub3QgbmVjZXNzYXJ5IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnlcbiAgLy8gZm9yIGluZmxhdGUgdXNlIGNvbnN0YW50IGxpbWl0IGluIDY1NTM2IGJ5dGVzXG4gIC8vXG5cbiAgLyogc3BhY2UgYXQgZXh0cmEgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5leHRyYV9tYXggID0gMDtcbiAgLyogcG9pbnRlciB0byB6ZXJvLXRlcm1pbmF0ZWQgZmlsZSBuYW1lIG9yIFpfTlVMTCAqL1xuICB0aGlzLm5hbWUgICAgICAgPSAnJztcbiAgLyogc3BhY2UgYXQgbmFtZSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLm5hbWVfbWF4ICAgPSAwO1xuICAvKiBwb2ludGVyIHRvIHplcm8tdGVybWluYXRlZCBjb21tZW50IG9yIFpfTlVMTCAqL1xuICB0aGlzLmNvbW1lbnQgICAgPSAnJztcbiAgLyogc3BhY2UgYXQgY29tbWVudCAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLmNvbW1fbWF4ICAgPSAwO1xuICAvKiB0cnVlIGlmIHRoZXJlIHdhcyBvciB3aWxsIGJlIGEgaGVhZGVyIGNyYyAqL1xuICB0aGlzLmhjcmMgICAgICAgPSAwO1xuICAvKiB0cnVlIHdoZW4gZG9uZSByZWFkaW5nIGd6aXAgaGVhZGVyIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovXG4gIHRoaXMuZG9uZSAgICAgICA9IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdaaGVhZGVyO1xuXG59LHt9XSwxMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLy8gU2VlIHN0YXRlIGRlZnMgZnJvbSBpbmZsYXRlLmpzXG52YXIgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xuXG4vKlxuICAgRGVjb2RlIGxpdGVyYWwsIGxlbmd0aCwgYW5kIGRpc3RhbmNlIGNvZGVzIGFuZCB3cml0ZSBvdXQgdGhlIHJlc3VsdGluZ1xuICAgbGl0ZXJhbCBhbmQgbWF0Y2ggYnl0ZXMgdW50aWwgZWl0aGVyIG5vdCBlbm91Z2ggaW5wdXQgb3Igb3V0cHV0IGlzXG4gICBhdmFpbGFibGUsIGFuIGVuZC1vZi1ibG9jayBpcyBlbmNvdW50ZXJlZCwgb3IgYSBkYXRhIGVycm9yIGlzIGVuY291bnRlcmVkLlxuICAgV2hlbiBsYXJnZSBlbm91Z2ggaW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIGFyZSBzdXBwbGllZCB0byBpbmZsYXRlKCksIGZvclxuICAgZXhhbXBsZSwgYSAxNksgaW5wdXQgYnVmZmVyIGFuZCBhIDY0SyBvdXRwdXQgYnVmZmVyLCBtb3JlIHRoYW4gOTUlIG9mIHRoZVxuICAgaW5mbGF0ZSBleGVjdXRpb24gdGltZSBpcyBzcGVudCBpbiB0aGlzIHJvdXRpbmUuXG5cbiAgIEVudHJ5IGFzc3VtcHRpb25zOlxuXG4gICAgICAgIHN0YXRlLm1vZGUgPT09IExFTlxuICAgICAgICBzdHJtLmF2YWlsX2luID49IDZcbiAgICAgICAgc3RybS5hdmFpbF9vdXQgPj0gMjU4XG4gICAgICAgIHN0YXJ0ID49IHN0cm0uYXZhaWxfb3V0XG4gICAgICAgIHN0YXRlLmJpdHMgPCA4XG5cbiAgIE9uIHJldHVybiwgc3RhdGUubW9kZSBpcyBvbmUgb2Y6XG5cbiAgICAgICAgTEVOIC0tIHJhbiBvdXQgb2YgZW5vdWdoIG91dHB1dCBzcGFjZSBvciBlbm91Z2ggYXZhaWxhYmxlIGlucHV0XG4gICAgICAgIFRZUEUgLS0gcmVhY2hlZCBlbmQgb2YgYmxvY2sgY29kZSwgaW5mbGF0ZSgpIHRvIGludGVycHJldCBuZXh0IGJsb2NrXG4gICAgICAgIEJBRCAtLSBlcnJvciBpbiBibG9jayBkYXRhXG5cbiAgIE5vdGVzOlxuXG4gICAgLSBUaGUgbWF4aW11bSBpbnB1dCBiaXRzIHVzZWQgYnkgYSBsZW5ndGgvZGlzdGFuY2UgcGFpciBpcyAxNSBiaXRzIGZvciB0aGVcbiAgICAgIGxlbmd0aCBjb2RlLCA1IGJpdHMgZm9yIHRoZSBsZW5ndGggZXh0cmEsIDE1IGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBjb2RlLFxuICAgICAgYW5kIDEzIGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBleHRyYS4gIFRoaXMgdG90YWxzIDQ4IGJpdHMsIG9yIHNpeCBieXRlcy5cbiAgICAgIFRoZXJlZm9yZSBpZiBzdHJtLmF2YWlsX2luID49IDYsIHRoZW4gdGhlcmUgaXMgZW5vdWdoIGlucHV0IHRvIGF2b2lkXG4gICAgICBjaGVja2luZyBmb3IgYXZhaWxhYmxlIGlucHV0IHdoaWxlIGRlY29kaW5nLlxuXG4gICAgLSBUaGUgbWF4aW11bSBieXRlcyB0aGF0IGEgc2luZ2xlIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGNhbiBvdXRwdXQgaXMgMjU4XG4gICAgICBieXRlcywgd2hpY2ggaXMgdGhlIG1heGltdW0gbGVuZ3RoIHRoYXQgY2FuIGJlIGNvZGVkLiAgaW5mbGF0ZV9mYXN0KClcbiAgICAgIHJlcXVpcmVzIHN0cm0uYXZhaWxfb3V0ID49IDI1OCBmb3IgZWFjaCBsb29wIHRvIGF2b2lkIGNoZWNraW5nIGZvclxuICAgICAgb3V0cHV0IHNwYWNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfZmFzdChzdHJtLCBzdGFydCkge1xuICB2YXIgc3RhdGU7XG4gIHZhciBfaW47ICAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmlucHV0ICovXG4gIHZhciBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBoYXZlIGVub3VnaCBpbnB1dCB3aGlsZSBpbiA8IGxhc3QgKi9cbiAgdmFyIF9vdXQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ub3V0cHV0ICovXG4gIHZhciBiZWc7ICAgICAgICAgICAgICAgICAgICAvKiBpbmZsYXRlKCkncyBpbml0aWFsIHN0cm0ub3V0cHV0ICovXG4gIHZhciBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB3aGlsZSBvdXQgPCBlbmQsIGVub3VnaCBzcGFjZSBhdmFpbGFibGUgKi9cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIHZhciBkbWF4OyAgICAgICAgICAgICAgICAgICAvKiBtYXhpbXVtIGRpc3RhbmNlIGZyb20gemxpYiBoZWFkZXIgKi9cbi8vI2VuZGlmXG4gIHZhciB3c2l6ZTsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdmFyIHdoYXZlOyAgICAgICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdmFyIHduZXh0OyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICAvLyBVc2UgYHNfd2luZG93YCBpbnN0ZWFkIGB3aW5kb3dgLCBhdm9pZCBjb25mbGljdCB3aXRoIGluc3RydW1lbnRhdGlvbiB0b29sc1xuICB2YXIgc193aW5kb3c7ICAgICAgICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiB3c2l6ZSAhPSAwICovXG4gIHZhciBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmhvbGQgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uYml0cyAqL1xuICB2YXIgbGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5sZW5jb2RlICovXG4gIHZhciBkY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmRpc3Rjb2RlICovXG4gIHZhciBsbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBsZW5ndGggY29kZXMgKi9cbiAgdmFyIGRtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGRpc3RhbmNlIGNvZGVzICovXG4gIHZhciBoZXJlOyAgICAgICAgICAgICAgICAgICAvKiByZXRyaWV2ZWQgdGFibGUgZW50cnkgKi9cbiAgdmFyIG9wOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgYml0cywgb3BlcmF0aW9uLCBleHRyYSBiaXRzLCBvciAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIHdpbmRvdyBwb3NpdGlvbiwgd2luZG93IGJ5dGVzIHRvIGNvcHkgKi9cbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCwgdW51c2VkIGJ5dGVzICovXG4gIHZhciBkaXN0OyAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBkaXN0YW5jZSAqL1xuICB2YXIgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBmcm9tICovXG4gIHZhciBmcm9tX3NvdXJjZTtcblxuXG4gIHZhciBpbnB1dCwgb3V0cHV0OyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG5cbiAgLyogY29weSBzdGF0ZSB0byBsb2NhbCB2YXJpYWJsZXMgKi9cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICAvL2hlcmUgPSBzdGF0ZS5oZXJlO1xuICBfaW4gPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgbGFzdCA9IF9pbiArIChzdHJtLmF2YWlsX2luIC0gNSk7XG4gIF9vdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgYmVnID0gX291dCAtIChzdGFydCAtIHN0cm0uYXZhaWxfb3V0KTtcbiAgZW5kID0gX291dCArIChzdHJtLmF2YWlsX291dCAtIDI1Nyk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICBkbWF4ID0gc3RhdGUuZG1heDtcbi8vI2VuZGlmXG4gIHdzaXplID0gc3RhdGUud3NpemU7XG4gIHdoYXZlID0gc3RhdGUud2hhdmU7XG4gIHduZXh0ID0gc3RhdGUud25leHQ7XG4gIHNfd2luZG93ID0gc3RhdGUud2luZG93O1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIGxjb2RlID0gc3RhdGUubGVuY29kZTtcbiAgZGNvZGUgPSBzdGF0ZS5kaXN0Y29kZTtcbiAgbG1hc2sgPSAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDE7XG4gIGRtYXNrID0gKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMTtcblxuXG4gIC8qIGRlY29kZSBsaXRlcmFscyBhbmQgbGVuZ3RoL2Rpc3RhbmNlcyB1bnRpbCBlbmQtb2YtYmxvY2sgb3Igbm90IGVub3VnaFxuICAgICBpbnB1dCBkYXRhIG9yIG91dHB1dCBzcGFjZSAqL1xuXG4gIHRvcDpcbiAgZG8ge1xuICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgIH1cblxuICAgIGhlcmUgPSBsY29kZVtob2xkICYgbG1hc2tdO1xuXG4gICAgZG9sZW46XG4gICAgZm9yICg7OykgeyAvLyBHb3RvIGVtdWxhdGlvblxuICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICBob2xkID4+Pj0gb3A7XG4gICAgICBiaXRzIC09IG9wO1xuICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuICAgICAgaWYgKG9wID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsaXRlcmFsICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgIG91dHB1dFtfb3V0KytdID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggYmFzZSAqL1xuICAgICAgICBsZW4gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICBpZiAob3ApIHtcbiAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW4gKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBsZW4pKTtcbiAgICAgICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIGhlcmUgPSBkY29kZVtob2xkICYgZG1hc2tdO1xuXG4gICAgICAgIGRvZGlzdDpcbiAgICAgICAgZm9yICg7OykgeyAvLyBnb3RvIGVtdWxhdGlvblxuICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcblxuICAgICAgICAgIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhc2UgKi9cbiAgICAgICAgICAgIGRpc3QgPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzdCArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgICAgIGlmIChkaXN0ID4gZG1heCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBkaXN0KSk7XG4gICAgICAgICAgICBvcCA9IF9vdXQgLSBiZWc7ICAgICAgICAgICAgICAgIC8qIG1heCBkaXN0YW5jZSBpbiBvdXRwdXQgKi9cbiAgICAgICAgICAgIGlmIChkaXN0ID4gb3ApIHsgICAgICAgICAgICAgICAgLyogc2VlIGlmIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgb3AgPSBkaXN0IC0gb3A7ICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgaWYgKG9wID4gd2hhdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgICAgICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgICAgICAgIGlmIChsZW4gPD0gb3AgLSB3aGF2ZSkge1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgIGxlbiAtPSBvcCAtIHdoYXZlO1xuLy8gICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wID4gd2hhdmUpO1xuLy8gICAgICAgICAgICAgICAgaWYgKG9wID09PSAwKSB7XG4vLyAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmcm9tID0gMDsgLy8gd2luZG93IGluZGV4XG4gICAgICAgICAgICAgIGZyb21fc291cmNlID0gc193aW5kb3c7XG4gICAgICAgICAgICAgIGlmICh3bmV4dCA9PT0gMCkgeyAgICAgICAgICAgLyogdmVyeSBjb21tb24gY2FzZSAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHduZXh0IDwgb3ApIHsgICAgICAvKiB3cmFwIGFyb3VuZCB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplICsgd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBvcCAtPSB3bmV4dDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gZW5kIG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSAwO1xuICAgICAgICAgICAgICAgICAgaWYgKHduZXh0IDwgbGVuKSB7ICAvKiBzb21lIGZyb20gc3RhcnQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICAgIG9wID0gd25leHQ7XG4gICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgLyogY29udGlndW91cyBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3aGlsZSAobGVuID4gMikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgICAgIC8qIGNvcHkgZGlyZWN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgIGRvIHsgICAgICAgICAgICAgICAgICAgICAgICAvKiBtaW5pbXVtIGxlbmd0aCBpcyB0aHJlZSAqL1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gPiAyKTtcbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAvKiAybmQgbGV2ZWwgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICAgICAgaGVyZSA9IGRjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgICAgICBjb250aW51ZSBkb2Rpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgICAgICAvKiAybmQgbGV2ZWwgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgaGVyZSA9IGxjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgIGNvbnRpbnVlIGRvbGVuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAzMikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGVuZC1vZi1ibG9jayAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuXG4gICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgIH1cbiAgfSB3aGlsZSAoX2luIDwgbGFzdCAmJiBfb3V0IDwgZW5kKTtcblxuICAvKiByZXR1cm4gdW51c2VkIGJ5dGVzIChvbiBlbnRyeSwgYml0cyA8IDgsIHNvIGluIHdvbid0IGdvIHRvbyBmYXIgYmFjaykgKi9cbiAgbGVuID0gYml0cyA+PiAzO1xuICBfaW4gLT0gbGVuO1xuICBiaXRzIC09IGxlbiA8PCAzO1xuICBob2xkICY9ICgxIDw8IGJpdHMpIC0gMTtcblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJldHVybiAqL1xuICBzdHJtLm5leHRfaW4gPSBfaW47XG4gIHN0cm0ubmV4dF9vdXQgPSBfb3V0O1xuICBzdHJtLmF2YWlsX2luID0gKF9pbiA8IGxhc3QgPyA1ICsgKGxhc3QgLSBfaW4pIDogNSAtIChfaW4gLSBsYXN0KSk7XG4gIHN0cm0uYXZhaWxfb3V0ID0gKF9vdXQgPCBlbmQgPyAyNTcgKyAoZW5kIC0gX291dCkgOiAyNTcgLSAoX291dCAtIGVuZCkpO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIHJldHVybjtcbn07XG5cbn0se31dLDEyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgdXRpbHMgICAgICAgICA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xudmFyIGFkbGVyMzIgICAgICAgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbnZhciBjcmMzMiAgICAgICAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xudmFyIGluZmxhdGVfZmFzdCAgPSByZXF1aXJlKCcuL2luZmZhc3QnKTtcbnZhciBpbmZsYXRlX3RhYmxlID0gcmVxdWlyZSgnLi9pbmZ0cmVlcycpO1xuXG52YXIgQ09ERVMgPSAwO1xudmFyIExFTlMgPSAxO1xudmFyIERJU1RTID0gMjtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuLy92YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbi8vdmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7XG4vL3ZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xuLy92YXIgWl9GVUxMX0ZMVVNIICAgID0gMztcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xudmFyIFpfQkxPQ0sgICAgICAgICA9IDU7XG52YXIgWl9UUkVFUyAgICAgICAgID0gNjtcblxuXG4vKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gKi9cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG52YXIgWl9ORUVEX0RJQ1QgICAgID0gMjtcbi8vdmFyIFpfRVJSTk8gICAgICAgICA9IC0xO1xudmFyIFpfU1RSRUFNX0VSUk9SICA9IC0yO1xudmFyIFpfREFUQV9FUlJPUiAgICA9IC0zO1xudmFyIFpfTUVNX0VSUk9SICAgICA9IC00O1xudmFyIFpfQlVGX0VSUk9SICAgICA9IC01O1xuLy92YXIgWl9WRVJTSU9OX0VSUk9SID0gLTY7XG5cbi8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xudmFyIFpfREVGTEFURUQgID0gODtcblxuXG4vKiBTVEFURVMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG52YXIgICAgSEVBRCA9IDE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1hZ2ljIGhlYWRlciAqL1xudmFyICAgIEZMQUdTID0gMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtZXRob2QgYW5kIGZsYWdzIChnemlwKSAqL1xudmFyICAgIFRJTUUgPSAzOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtb2RpZmljYXRpb24gdGltZSAoZ3ppcCkgKi9cbnZhciAgICBPUyA9IDQ7ICAgICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgZmxhZ3MgYW5kIG9wZXJhdGluZyBzeXN0ZW0gKGd6aXApICovXG52YXIgICAgRVhMRU4gPSA1OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGxlbmd0aCAoZ3ppcCkgKi9cbnZhciAgICBFWFRSQSA9IDY7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgYnl0ZXMgKGd6aXApICovXG52YXIgICAgTkFNRSA9IDc7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBmaWxlIG5hbWUgKGd6aXApICovXG52YXIgICAgQ09NTUVOVCA9IDg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBjb21tZW50IChnemlwKSAqL1xudmFyICAgIEhDUkMgPSA5OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBoZWFkZXIgY3JjIChnemlwKSAqL1xudmFyICAgIERJQ1RJRCA9IDEwOyAgICAvKiBpOiB3YWl0aW5nIGZvciBkaWN0aW9uYXJ5IGNoZWNrIHZhbHVlICovXG52YXIgICAgRElDVCA9IDExOyAgICAgIC8qIHdhaXRpbmcgZm9yIGluZmxhdGVTZXREaWN0aW9uYXJ5KCkgY2FsbCAqL1xudmFyICAgICAgICBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xudmFyICAgICAgICBUWVBFRE8gPSAxMzsgICAgLyogaTogc2FtZSwgYnV0IHNraXAgY2hlY2sgdG8gZXhpdCBpbmZsYXRlIG9uIG5ldyBibG9jayAqL1xudmFyICAgICAgICBTVE9SRUQgPSAxNDsgICAgLyogaTogd2FpdGluZyBmb3Igc3RvcmVkIHNpemUgKGxlbmd0aCBhbmQgY29tcGxlbWVudCkgKi9cbnZhciAgICAgICAgQ09QWV8gPSAxNTsgICAgIC8qIGkvbzogc2FtZSBhcyBDT1BZIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG52YXIgICAgICAgIENPUFkgPSAxNjsgICAgICAvKiBpL286IHdhaXRpbmcgZm9yIGlucHV0IG9yIG91dHB1dCB0byBjb3B5IHN0b3JlZCBibG9jayAqL1xudmFyICAgICAgICBUQUJMRSA9IDE3OyAgICAgLyogaTogd2FpdGluZyBmb3IgZHluYW1pYyBibG9jayB0YWJsZSBsZW5ndGhzICovXG52YXIgICAgICAgIExFTkxFTlMgPSAxODsgICAvKiBpOiB3YWl0aW5nIGZvciBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgQ09ERUxFTlMgPSAxOTsgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQgYW5kIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqL1xudmFyICAgICAgICAgICAgTEVOXyA9IDIwOyAgICAgIC8qIGk6IHNhbWUgYXMgTEVOIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG52YXIgICAgICAgICAgICBMRU4gPSAyMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdC9lb2IgY29kZSAqL1xudmFyICAgICAgICAgICAgTEVORVhUID0gMjI7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aCBleHRyYSBiaXRzICovXG52YXIgICAgICAgICAgICBESVNUID0gMjM7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgY29kZSAqL1xudmFyICAgICAgICAgICAgRElTVEVYVCA9IDI0OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGV4dHJhIGJpdHMgKi9cbnZhciAgICAgICAgICAgIE1BVENIID0gMjU7ICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gY29weSBzdHJpbmcgKi9cbnZhciAgICAgICAgICAgIExJVCA9IDI2OyAgICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gd3JpdGUgbGl0ZXJhbCAqL1xudmFyICAgIENIRUNLID0gMjc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgY2hlY2sgdmFsdWUgKi9cbnZhciAgICBMRU5HVEggPSAyODsgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGxlbmd0aCAoZ3ppcCkgKi9cbnZhciAgICBET05FID0gMjk7ICAgICAgLyogZmluaXNoZWQgY2hlY2ssIGRvbmUgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBCQUQgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIE1FTSA9IDMxOyAgICAgICAvKiBnb3QgYW4gaW5mbGF0ZSgpIG1lbW9yeSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIFNZTkMgPSAzMjsgICAgICAvKiBsb29raW5nIGZvciBzeW5jaHJvbml6YXRpb24gYnl0ZXMgdG8gcmVzdGFydCBpbmZsYXRlKCkgKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5cbnZhciBFTk9VR0hfTEVOUyA9IDg1MjtcbnZhciBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL3ZhciBFTk9VR0ggPSAgKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbnZhciBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xudmFyIERFRl9XQklUUyA9IE1BWF9XQklUUztcblxuXG5mdW5jdGlvbiB6c3dhcDMyKHEpIHtcbiAgcmV0dXJuICAoKChxID4+PiAyNCkgJiAweGZmKSArXG4gICAgICAgICAgKChxID4+PiA4KSAmIDB4ZmYwMCkgK1xuICAgICAgICAgICgocSAmIDB4ZmYwMCkgPDwgOCkgK1xuICAgICAgICAgICgocSAmIDB4ZmYpIDw8IDI0KSk7XG59XG5cblxuZnVuY3Rpb24gSW5mbGF0ZVN0YXRlKCkge1xuICB0aGlzLm1vZGUgPSAwOyAgICAgICAgICAgICAvKiBjdXJyZW50IGluZmxhdGUgbW9kZSAqL1xuICB0aGlzLmxhc3QgPSBmYWxzZTsgICAgICAgICAgLyogdHJ1ZSBpZiBwcm9jZXNzaW5nIGxhc3QgYmxvY2sgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5oYXZlZGljdCA9IGZhbHNlOyAgICAgIC8qIHRydWUgaWYgZGljdGlvbmFyeSBwcm92aWRlZCAqL1xuICB0aGlzLmZsYWdzID0gMDsgICAgICAgICAgICAgLyogZ3ppcCBoZWFkZXIgbWV0aG9kIGFuZCBmbGFncyAoMCBpZiB6bGliKSAqL1xuICB0aGlzLmRtYXggPSAwOyAgICAgICAgICAgICAgLyogemxpYiBoZWFkZXIgbWF4IGRpc3RhbmNlIChJTkZMQVRFX1NUUklDVCkgKi9cbiAgdGhpcy5jaGVjayA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIGNoZWNrIHZhbHVlICovXG4gIHRoaXMudG90YWwgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBvdXRwdXQgY291bnQgKi9cbiAgLy8gVE9ETzogbWF5IGJlIHt9XG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgICAgICAgICAvKiB3aGVyZSB0byBzYXZlIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uICovXG5cbiAgLyogc2xpZGluZyB3aW5kb3cgKi9cbiAgdGhpcy53Yml0cyA9IDA7ICAgICAgICAgICAgIC8qIGxvZyBiYXNlIDIgb2YgcmVxdWVzdGVkIHdpbmRvdyBzaXplICovXG4gIHRoaXMud3NpemUgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdGhpcy53aGF2ZSA9IDA7ICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdGhpcy53bmV4dCA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICB0aGlzLndpbmRvdyA9IG51bGw7ICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiBuZWVkZWQgKi9cblxuICAvKiBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5ob2xkID0gMDsgICAgICAgICAgICAgIC8qIGlucHV0IGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmJpdHMgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGJpdHMgaW4gXCJpblwiICovXG5cbiAgLyogZm9yIHN0cmluZyBhbmQgc3RvcmVkIGJsb2NrIGNvcHlpbmcgKi9cbiAgdGhpcy5sZW5ndGggPSAwOyAgICAgICAgICAgIC8qIGxpdGVyYWwgb3IgbGVuZ3RoIG9mIGRhdGEgdG8gY29weSAqL1xuICB0aGlzLm9mZnNldCA9IDA7ICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayB0byBjb3B5IHN0cmluZyBmcm9tICovXG5cbiAgLyogZm9yIHRhYmxlIGFuZCBjb2RlIGRlY29kaW5nICovXG4gIHRoaXMuZXh0cmEgPSAwOyAgICAgICAgICAgICAvKiBleHRyYSBiaXRzIG5lZWRlZCAqL1xuXG4gIC8qIGZpeGVkIGFuZCBkeW5hbWljIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuY29kZSA9IG51bGw7ICAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAqL1xuICB0aGlzLmRpc3Rjb2RlID0gbnVsbDsgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKi9cbiAgdGhpcy5sZW5iaXRzID0gMDsgICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGxlbmNvZGUgKi9cbiAgdGhpcy5kaXN0Yml0cyA9IDA7ICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGRpc3Rjb2RlICovXG5cbiAgLyogZHluYW1pYyB0YWJsZSBidWlsZGluZyAqL1xuICB0aGlzLm5jb2RlID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5sZW4gPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5uZGlzdCA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5oYXZlID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aHMgaW4gbGVuc1tdICovXG4gIHRoaXMubmV4dCA9IG51bGw7ICAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiBjb2Rlc1tdICovXG5cbiAgdGhpcy5sZW5zID0gbmV3IHV0aWxzLkJ1ZjE2KDMyMCk7IC8qIHRlbXBvcmFyeSBzdG9yYWdlIGZvciBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy53b3JrID0gbmV3IHV0aWxzLkJ1ZjE2KDI4OCk7IC8qIHdvcmsgYXJlYSBmb3IgY29kZSB0YWJsZSBidWlsZGluZyAqL1xuXG4gIC8qXG4gICBiZWNhdXNlIHdlIGRvbid0IGhhdmUgcG9pbnRlcnMgaW4ganMsIHdlIHVzZSBsZW5jb2RlIGFuZCBkaXN0Y29kZSBkaXJlY3RseVxuICAgYXMgYnVmZmVycyBzbyB3ZSBkb24ndCBuZWVkIGNvZGVzXG4gICovXG4gIC8vdGhpcy5jb2RlcyA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0gpOyAgICAgICAvKiBzcGFjZSBmb3IgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5keW4gPSBudWxsOyAgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLmRpc3RkeW4gPSBudWxsOyAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuc2FuZSA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGlmIGZhbHNlLCBhbGxvdyBpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgKi9cbiAgdGhpcy5iYWNrID0gMDsgICAgICAgICAgICAgICAgICAgLyogYml0cyBiYWNrIG9mIGxhc3QgdW5wcm9jZXNzZWQgbGVuZ3RoL2xpdCAqL1xuICB0aGlzLndhcyA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBpbml0aWFsIGxlbmd0aCBvZiBtYXRjaCAqL1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSBzdGF0ZS50b3RhbCA9IDA7XG4gIHN0cm0ubXNnID0gJyc7IC8qWl9OVUxMKi9cbiAgaWYgKHN0YXRlLndyYXApIHsgICAgICAgLyogdG8gc3VwcG9ydCBpbGwtY29uY2VpdmVkIEphdmEgdGVzdCBzdWl0ZSAqL1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS53cmFwICYgMTtcbiAgfVxuICBzdGF0ZS5tb2RlID0gSEVBRDtcbiAgc3RhdGUubGFzdCA9IDA7XG4gIHN0YXRlLmhhdmVkaWN0ID0gMDtcbiAgc3RhdGUuZG1heCA9IDMyNzY4O1xuICBzdGF0ZS5oZWFkID0gbnVsbC8qWl9OVUxMKi87XG4gIHN0YXRlLmhvbGQgPSAwO1xuICBzdGF0ZS5iaXRzID0gMDtcbiAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0xFTlMpO1xuICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0RJU1RTKTtcblxuICBzdGF0ZS5zYW5lID0gMTtcbiAgc3RhdGUuYmFjayA9IC0xO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IHJlc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldChzdHJtKSB7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RhdGUud3NpemUgPSAwO1xuICBzdGF0ZS53aGF2ZSA9IDA7XG4gIHN0YXRlLnduZXh0ID0gMDtcbiAgcmV0dXJuIGluZmxhdGVSZXNldEtlZXAoc3RybSk7XG5cbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKSB7XG4gIHZhciB3cmFwO1xuICB2YXIgc3RhdGU7XG5cbiAgLyogZ2V0IHRoZSBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBleHRyYWN0IHdyYXAgcmVxdWVzdCBmcm9tIHdpbmRvd0JpdHMgcGFyYW1ldGVyICovXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkge1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuICBlbHNlIHtcbiAgICB3cmFwID0gKHdpbmRvd0JpdHMgPj4gNCkgKyAxO1xuICAgIGlmICh3aW5kb3dCaXRzIDwgNDgpIHtcbiAgICAgIHdpbmRvd0JpdHMgJj0gMTU7XG4gICAgfVxuICB9XG5cbiAgLyogc2V0IG51bWJlciBvZiB3aW5kb3cgYml0cywgZnJlZSB3aW5kb3cgaWYgZGlmZmVyZW50ICovXG4gIGlmICh3aW5kb3dCaXRzICYmICh3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUpKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG4gIGlmIChzdGF0ZS53aW5kb3cgIT09IG51bGwgJiYgc3RhdGUud2JpdHMgIT09IHdpbmRvd0JpdHMpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXNldCB0aGUgcmVzdCBvZiBpdCAqL1xuICBzdGF0ZS53cmFwID0gd3JhcDtcbiAgc3RhdGUud2JpdHMgPSB3aW5kb3dCaXRzO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0KHN0cm0pO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlSW5pdDIoc3RybSwgd2luZG93Qml0cykge1xuICB2YXIgcmV0O1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICAvL3N0cm0ubXNnID0gWl9OVUxMOyAgICAgICAgICAgICAgICAgLyogaW4gY2FzZSB3ZSByZXR1cm4gYW4gZXJyb3IgKi9cblxuICBzdGF0ZSA9IG5ldyBJbmZsYXRlU3RhdGUoKTtcblxuICAvL2lmIChzdGF0ZSA9PT0gWl9OVUxMKSByZXR1cm4gWl9NRU1fRVJST1I7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogYWxsb2NhdGVkXFxuXCIpKTtcbiAgc3RybS5zdGF0ZSA9IHN0YXRlO1xuICBzdGF0ZS53aW5kb3cgPSBudWxsLypaX05VTEwqLztcbiAgcmV0ID0gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKTtcbiAgaWYgKHJldCAhPT0gWl9PSykge1xuICAgIHN0cm0uc3RhdGUgPSBudWxsLypaX05VTEwqLztcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlSW5pdChzdHJtKSB7XG4gIHJldHVybiBpbmZsYXRlSW5pdDIoc3RybSwgREVGX1dCSVRTKTtcbn1cblxuXG4vKlxuIFJldHVybiBzdGF0ZSB3aXRoIGxlbmd0aCBhbmQgZGlzdGFuY2UgZGVjb2RpbmcgdGFibGVzIGFuZCBpbmRleCBzaXplcyBzZXQgdG9cbiBmaXhlZCBjb2RlIGRlY29kaW5nLiAgTm9ybWFsbHkgdGhpcyByZXR1cm5zIGZpeGVkIHRhYmxlcyBmcm9tIGluZmZpeGVkLmguXG4gSWYgQlVJTERGSVhFRCBpcyBkZWZpbmVkLCB0aGVuIGluc3RlYWQgdGhpcyByb3V0aW5lIGJ1aWxkcyB0aGUgdGFibGVzIHRoZVxuIGZpcnN0IHRpbWUgaXQncyBjYWxsZWQsIGFuZCByZXR1cm5zIHRob3NlIHRhYmxlcyB0aGUgZmlyc3QgdGltZSBhbmRcbiB0aGVyZWFmdGVyLiAgVGhpcyByZWR1Y2VzIHRoZSBzaXplIG9mIHRoZSBjb2RlIGJ5IGFib3V0IDJLIGJ5dGVzLCBpblxuIGV4Y2hhbmdlIGZvciBhIGxpdHRsZSBleGVjdXRpb24gdGltZS4gIEhvd2V2ZXIsIEJVSUxERklYRUQgc2hvdWxkIG5vdCBiZVxuIHVzZWQgZm9yIHRocmVhZGVkIGFwcGxpY2F0aW9ucywgc2luY2UgdGhlIHJld3JpdGluZyBvZiB0aGUgdGFibGVzIGFuZCB2aXJnaW5cbiBtYXkgbm90IGJlIHRocmVhZC1zYWZlLlxuICovXG52YXIgdmlyZ2luID0gdHJ1ZTtcblxudmFyIGxlbmZpeCwgZGlzdGZpeDsgLy8gV2UgaGF2ZSBubyBwb2ludGVycyBpbiBKUywgc28ga2VlcCB0YWJsZXMgc2VwYXJhdGVcblxuZnVuY3Rpb24gZml4ZWR0YWJsZXMoc3RhdGUpIHtcbiAgLyogYnVpbGQgZml4ZWQgaHVmZm1hbiB0YWJsZXMgaWYgZmlyc3QgY2FsbCAobWF5IG5vdCBiZSB0aHJlYWQgc2FmZSkgKi9cbiAgaWYgKHZpcmdpbikge1xuICAgIHZhciBzeW07XG5cbiAgICBsZW5maXggPSBuZXcgdXRpbHMuQnVmMzIoNTEyKTtcbiAgICBkaXN0Zml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDMyKTtcblxuICAgIC8qIGxpdGVyYWwvbGVuZ3RoIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMTQ0KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gODsgfVxuICAgIHdoaWxlIChzeW0gPCAyNTYpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA5OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4MCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDc7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjg4KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gODsgfVxuXG4gICAgaW5mbGF0ZV90YWJsZShMRU5TLCAgc3RhdGUubGVucywgMCwgMjg4LCBsZW5maXgsICAgMCwgc3RhdGUud29yaywgeyBiaXRzOiA5IH0pO1xuXG4gICAgLyogZGlzdGFuY2UgdGFibGUgKi9cbiAgICBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAzMikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDU7IH1cblxuICAgIGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIDAsIDMyLCAgIGRpc3RmaXgsIDAsIHN0YXRlLndvcmssIHsgYml0czogNSB9KTtcblxuICAgIC8qIGRvIHRoaXMganVzdCBvbmNlICovXG4gICAgdmlyZ2luID0gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5sZW5jb2RlID0gbGVuZml4O1xuICBzdGF0ZS5sZW5iaXRzID0gOTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBkaXN0Zml4O1xuICBzdGF0ZS5kaXN0Yml0cyA9IDU7XG59XG5cblxuLypcbiBVcGRhdGUgdGhlIHdpbmRvdyB3aXRoIHRoZSBsYXN0IHdzaXplIChub3JtYWxseSAzMkspIGJ5dGVzIHdyaXR0ZW4gYmVmb3JlXG4gcmV0dXJuaW5nLiAgSWYgd2luZG93IGRvZXMgbm90IGV4aXN0IHlldCwgY3JlYXRlIGl0LiAgVGhpcyBpcyBvbmx5IGNhbGxlZFxuIHdoZW4gYSB3aW5kb3cgaXMgYWxyZWFkeSBpbiB1c2UsIG9yIHdoZW4gb3V0cHV0IGhhcyBiZWVuIHdyaXR0ZW4gZHVyaW5nIHRoaXNcbiBpbmZsYXRlIGNhbGwsIGJ1dCB0aGUgZW5kIG9mIHRoZSBkZWZsYXRlIHN0cmVhbSBoYXMgbm90IGJlZW4gcmVhY2hlZCB5ZXQuXG4gSXQgaXMgYWxzbyBjYWxsZWQgdG8gY3JlYXRlIGEgd2luZG93IGZvciBkaWN0aW9uYXJ5IGRhdGEgd2hlbiBhIGRpY3Rpb25hcnlcbiBpcyBsb2FkZWQuXG5cbiBQcm92aWRpbmcgb3V0cHV0IGJ1ZmZlcnMgbGFyZ2VyIHRoYW4gMzJLIHRvIGluZmxhdGUoKSBzaG91bGQgcHJvdmlkZSBhIHNwZWVkXG4gYWR2YW50YWdlLCBzaW5jZSBvbmx5IHRoZSBsYXN0IDMySyBvZiBvdXRwdXQgaXMgY29waWVkIHRvIHRoZSBzbGlkaW5nIHdpbmRvd1xuIHVwb24gcmV0dXJuIGZyb20gaW5mbGF0ZSgpLCBhbmQgc2luY2UgYWxsIGRpc3RhbmNlcyBhZnRlciB0aGUgZmlyc3QgMzJLIG9mXG4gb3V0cHV0IHdpbGwgZmFsbCBpbiB0aGUgb3V0cHV0IGRhdGEsIG1ha2luZyBtYXRjaCBjb3BpZXMgc2ltcGxlciBhbmQgZmFzdGVyLlxuIFRoZSBhZHZhbnRhZ2UgbWF5IGJlIGRlcGVuZGVudCBvbiB0aGUgc2l6ZSBvZiB0aGUgcHJvY2Vzc29yJ3MgZGF0YSBjYWNoZXMuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZXdpbmRvdyhzdHJtLCBzcmMsIGVuZCwgY29weSkge1xuICB2YXIgZGlzdDtcbiAgdmFyIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBpZiBpdCBoYXNuJ3QgYmVlbiBkb25lIGFscmVhZHksIGFsbG9jYXRlIHNwYWNlIGZvciB0aGUgd2luZG93ICovXG4gIGlmIChzdGF0ZS53aW5kb3cgPT09IG51bGwpIHtcbiAgICBzdGF0ZS53c2l6ZSA9IDEgPDwgc3RhdGUud2JpdHM7XG4gICAgc3RhdGUud25leHQgPSAwO1xuICAgIHN0YXRlLndoYXZlID0gMDtcblxuICAgIHN0YXRlLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHN0YXRlLndzaXplKTtcbiAgfVxuXG4gIC8qIGNvcHkgc3RhdGUtPndzaXplIG9yIGxlc3Mgb3V0cHV0IGJ5dGVzIGludG8gdGhlIGNpcmN1bGFyIHdpbmRvdyAqL1xuICBpZiAoY29weSA+PSBzdGF0ZS53c2l6ZSkge1xuICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBzdGF0ZS53c2l6ZSwgc3RhdGUud3NpemUsIDApO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICB9XG4gIGVsc2Uge1xuICAgIGRpc3QgPSBzdGF0ZS53c2l6ZSAtIHN0YXRlLnduZXh0O1xuICAgIGlmIChkaXN0ID4gY29weSkge1xuICAgICAgZGlzdCA9IGNvcHk7XG4gICAgfVxuICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93ICsgc3RhdGUtPnduZXh0LCBlbmQgLSBjb3B5LCBkaXN0KTtcbiAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgZGlzdCwgc3RhdGUud25leHQpO1xuICAgIGNvcHkgLT0gZGlzdDtcbiAgICBpZiAoY29weSkge1xuICAgICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3csIGVuZCAtIGNvcHksIGNvcHkpO1xuICAgICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGNvcHksIDApO1xuICAgICAgc3RhdGUud25leHQgPSBjb3B5O1xuICAgICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzdGF0ZS53bmV4dCArPSBkaXN0O1xuICAgICAgaWYgKHN0YXRlLnduZXh0ID09PSBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53bmV4dCA9IDA7IH1cbiAgICAgIGlmIChzdGF0ZS53aGF2ZSA8IHN0YXRlLndzaXplKSB7IHN0YXRlLndoYXZlICs9IGRpc3Q7IH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGUoc3RybSwgZmx1c2gpIHtcbiAgdmFyIHN0YXRlO1xuICB2YXIgaW5wdXQsIG91dHB1dDsgICAgICAgICAgLy8gaW5wdXQvb3V0cHV0IGJ1ZmZlcnNcbiAgdmFyIG5leHQ7ICAgICAgICAgICAgICAgICAgIC8qIG5leHQgaW5wdXQgSU5ERVggKi9cbiAgdmFyIHB1dDsgICAgICAgICAgICAgICAgICAgIC8qIG5leHQgb3V0cHV0IElOREVYICovXG4gIHZhciBoYXZlLCBsZWZ0OyAgICAgICAgICAgICAvKiBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICB2YXIgaG9sZDsgICAgICAgICAgICAgICAgICAgLyogYml0IGJ1ZmZlciAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAgLyogYml0cyBpbiBiaXQgYnVmZmVyICovXG4gIHZhciBfaW4sIF9vdXQ7ICAgICAgICAgICAgICAvKiBzYXZlIHN0YXJ0aW5nIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0ICovXG4gIHZhciBjb3B5OyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2Ygc3RvcmVkIG9yIG1hdGNoIGJ5dGVzIHRvIGNvcHkgKi9cbiAgdmFyIGZyb207ICAgICAgICAgICAgICAgICAgIC8qIHdoZXJlIHRvIGNvcHkgbWF0Y2ggYnl0ZXMgZnJvbSAqL1xuICB2YXIgZnJvbV9zb3VyY2U7XG4gIHZhciBoZXJlID0gMDsgICAgICAgICAgICAgICAvKiBjdXJyZW50IGRlY29kaW5nIHRhYmxlIGVudHJ5ICovXG4gIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsOyAvLyBwYWtlZCBcImhlcmVcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICAvL3ZhciBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBwYXJlbnQgdGFibGUgZW50cnkgKi9cbiAgdmFyIGxhc3RfYml0cywgbGFzdF9vcCwgbGFzdF92YWw7IC8vIHBha2VkIFwibGFzdFwiIGRlbm9ybWFsaXplZCAoSlMgc3BlY2lmaWMpXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggdG8gY29weSBmb3IgcmVwZWF0cywgYml0cyB0byBkcm9wICovXG4gIHZhciByZXQ7ICAgICAgICAgICAgICAgICAgICAvKiByZXR1cm4gY29kZSAqL1xuICB2YXIgaGJ1ZiA9IG5ldyB1dGlscy5CdWY4KDQpOyAgICAvKiBidWZmZXIgZm9yIGd6aXAgaGVhZGVyIGNyYyBjYWxjdWxhdGlvbiAqL1xuICB2YXIgb3B0cztcblxuICB2YXIgbjsgLy8gdGVtcG9yYXJ5IHZhciBmb3IgTkVFRF9CSVRTXG5cbiAgdmFyIG9yZGVyID0gLyogcGVybXV0YXRpb24gb2YgY29kZSBsZW5ndGhzICovXG4gICAgWyAxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1IF07XG5cblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHwgIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7IHN0YXRlLm1vZGUgPSBUWVBFRE87IH0gICAgLyogc2tpcCBjaGVjayAqL1xuXG5cbiAgLy8tLS0gTE9BRCgpIC0tLVxuICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIC8vLS0tXG5cbiAgX2luID0gaGF2ZTtcbiAgX291dCA9IGxlZnQ7XG4gIHJldCA9IFpfT0s7XG5cbiAgaW5mX2xlYXZlOiAvLyBnb3RvIGVtdWxhdGlvblxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChzdGF0ZS5tb2RlKSB7XG4gICAgICBjYXNlIEhFQUQ6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEVETztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKChzdGF0ZS53cmFwICYgMikgJiYgaG9sZCA9PT0gMHg4YjFmKSB7ICAvKiBnemlwIGhlYWRlciAqL1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gMC8qY3JjMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuXG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubW9kZSA9IEZMQUdTO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmZsYWdzID0gMDsgICAgICAgICAgIC8qIGV4cGVjdCB6bGliIGhlYWRlciAqL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHN0YXRlLndyYXAgJiAxKSB8fCAgIC8qIGNoZWNrIGlmIHpsaWIgaGVhZGVyIGFsbG93ZWQgKi9cbiAgICAgICAgICAoKChob2xkICYgMHhmZikvKkJJVFMoOCkqLyA8PCA4KSArIChob2xkID4+IDgpKSAlIDMxKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGhlYWRlciBjaGVjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICAgIGJpdHMgLT0gNDtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBsZW4gPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA4O1xuICAgICAgICBpZiAoc3RhdGUud2JpdHMgPT09IDApIHtcbiAgICAgICAgICBzdGF0ZS53Yml0cyA9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW4gPiBzdGF0ZS53Yml0cykge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgd2luZG93IHNpemUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZG1heCA9IDEgPDwgbGVuO1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgemxpYiBoZWFkZXIgb2tcXG5cIikpO1xuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxLyphZGxlcjMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgIHN0YXRlLm1vZGUgPSBob2xkICYgMHgyMDAgPyBESUNUSUQgOiBUWVBFO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZMQUdTOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUuZmxhZ3MgPSBob2xkO1xuICAgICAgICBpZiAoKHN0YXRlLmZsYWdzICYgMHhmZikgIT09IFpfREVGTEFURUQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweGUwMDApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGhlYWRlciBmbGFncyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnRleHQgPSAoKGhvbGQgPj4gOCkgJiAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gVElNRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUSU1FOlxuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnRpbWUgPSBob2xkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzQoc3RhdGUuY2hlY2ssIGhvbGQpXG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIGhidWZbMl0gPSAoaG9sZCA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzNdID0gKGhvbGQgPj4+IDI0KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgNCwgMCk7XG4gICAgICAgICAgLy89PT1cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IE9TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE9TOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnhmbGFncyA9IChob2xkICYgMHhmZik7XG4gICAgICAgICAgc3RhdGUuaGVhZC5vcyA9IChob2xkID4+IDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBFWExFTjtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBFWExFTjpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkO1xuICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX2xlbiA9IGhvbGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG51bGwvKlpfTlVMTCovO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBFWFRSQTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBFWFRSQTpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICAgICAgbGVuID0gc3RhdGUuaGVhZC5leHRyYV9sZW4gLSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgICAgIGlmICghc3RhdGUuaGVhZC5leHRyYSkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSB1bnR5cGVkIGFycmF5IGZvciBtb3JlIGNvbnZlbmllbnQgcHJvY2Vzc2luZyBsYXRlclxuICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBuZXcgQXJyYXkoc3RhdGUuaGVhZC5leHRyYV9sZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KFxuICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICAgICAgICAvLyBleHRyYSBmaWVsZCBpcyBsaW1pdGVkIHRvIDY1NTM2IGJ5dGVzXG4gICAgICAgICAgICAgICAgLy8gLSBubyBuZWVkIGZvciBhZGRpdGlvbmFsIHNpemUgY2hlY2tcbiAgICAgICAgICAgICAgICBjb3B5LFxuICAgICAgICAgICAgICAgIC8qbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuID8gc3RhdGUuaGVhZC5leHRyYV9tYXggOiBjb3B5LCovXG4gICAgICAgICAgICAgICAgbGVuXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIC8vem1lbWNweShzdGF0ZS5oZWFkLmV4dHJhICsgbGVuLCBuZXh0LFxuICAgICAgICAgICAgICAvLyAgICAgICAgbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4ID9cbiAgICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuIDogY29weSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IE5BTUU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTkFNRTpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwODAwKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgY29weSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgLy8gVE9ETzogMiBvciAxIGJ5dGVzP1xuICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5uYW1lX21heCovKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG5cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT01NRU5UO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPTU1FTlQ6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MTAwMCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGNvcHkgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQuY29tbV9tYXgqLykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IEhDUkM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgSENSQzpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLmNoZWNrICYgMHhmZmZmKSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaGVhZGVyIGNyYyBtaXNtYXRjaCc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5oY3JjID0gKChzdGF0ZS5mbGFncyA+PiA5KSAmIDEpO1xuICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUNUSUQ6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSB6c3dhcDMyKGhvbGQpO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IERJQ1Q7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElDVDpcbiAgICAgICAgaWYgKHN0YXRlLmhhdmVkaWN0ID09PSAwKSB7XG4gICAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gICAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gICAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgICAgLy8tLS1cbiAgICAgICAgICByZXR1cm4gWl9ORUVEX0RJQ1Q7XG4gICAgICAgIH1cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUWVBFOlxuICAgICAgICBpZiAoZmx1c2ggPT09IFpfQkxPQ0sgfHwgZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVFlQRURPOlxuICAgICAgICBpZiAoc3RhdGUubGFzdCkge1xuICAgICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUubW9kZSA9IENIRUNLO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubGFzdCA9IChob2xkICYgMHgwMSkvKkJJVFMoMSkqLztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoMSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDE7XG4gICAgICAgIGJpdHMgLT0gMTtcbiAgICAgICAgLy8tLS0vL1xuXG4gICAgICAgIHN3aXRjaCAoKGhvbGQgJiAweDAzKS8qQklUUygyKSovKSB7XG4gICAgICAgICAgY2FzZSAwOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogc3RvcmVkIGJsb2NrICovXG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBzdG9yZWQgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBTVE9SRUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBmaXhlZCBibG9jayAqL1xuICAgICAgICAgICAgZml4ZWR0YWJsZXMoc3RhdGUpO1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZml4ZWQgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fOyAgICAgICAgICAgICAvKiBkZWNvZGUgY29kZXMgKi9cbiAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykge1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGR5bmFtaWMgYmxvY2sgKi9cbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGR5bmFtaWMgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUQUJMRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYmxvY2sgdHlwZSc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNUT1JFRDpcbiAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vLyAvKiBnbyB0byBieXRlIGJvdW5kYXJ5ICovXG4gICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKChob2xkICYgMHhmZmZmKSAhPT0gKChob2xkID4+PiAxNikgXiAweGZmZmYpKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3Rocyc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkICYgMHhmZmZmO1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBsZW5ndGggJXVcXG5cIixcbiAgICAgICAgLy8gICAgICAgIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IENPUFlfO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09QWV86XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPUFk6XG4gICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgICAgaWYgKGNvcHkgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgLy8tLS0gem1lbWNweShwdXQsIG5leHQsIGNvcHkpOyAtLS1cbiAgICAgICAgICB1dGlscy5hcnJheVNldChvdXRwdXQsIGlucHV0LCBuZXh0LCBjb3B5LCBwdXQpO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgICAgICBwdXQgKz0gY29weTtcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBlbmRcXG5cIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRBQkxFOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNCk7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTQpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubmxlbiA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDI1NztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDU7XG4gICAgICAgIGJpdHMgLT0gNTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5uZGlzdCA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDE7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgICBiaXRzIC09IDU7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubmNvZGUgPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA0O1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNDtcbiAgICAgICAgYml0cyAtPSA0O1xuICAgICAgICAvLy0tLS8vXG4vLyNpZm5kZWYgUEtaSVBfQlVHX1dPUktBUk9VTkRcbiAgICAgICAgaWYgKHN0YXRlLm5sZW4gPiAyODYgfHwgc3RhdGUubmRpc3QgPiAzMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3RvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHRhYmxlIHNpemVzIG9rXFxuXCIpKTtcbiAgICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5MRU5TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkxFTlM6XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmNvZGUpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgMTkpIHtcbiAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvL3N0YXRlLm5leHQgPSBzdGF0ZS5jb2RlcztcbiAgICAgICAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICAgIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW47XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSA3O1xuXG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShDT0RFUywgc3RhdGUubGVucywgMCwgMTksIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgbGVuZ3RocyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBjb2RlIGxlbmd0aHMgb2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IENPREVMRU5TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPREVMRU5TOlxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07LypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhlcmVfdmFsIDwgMTYpIHtcbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGhlcmVfdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoZXJlX3ZhbCA9PT0gMTYpIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgMik7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAyO1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGVuID0gc3RhdGUubGVuc1tzdGF0ZS5oYXZlIC0gMV07XG4gICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDAzKTsvL0JJVFMoMik7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhlcmVfdmFsID09PSAxNykge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAzKTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDM7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyA3KTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDc7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgIGNvcHkgPSAxMSArIChob2xkICYgMHg3Zik7Ly9CSVRTKDcpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyg3KSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gNztcbiAgICAgICAgICAgICAgYml0cyAtPSA3O1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSArIGNvcHkgPiBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNvcHktLSkge1xuICAgICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyogaGFuZGxlIGVycm9yIGJyZWFrcyBpbiB3aGlsZSAqL1xuICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gQkFEKSB7IGJyZWFrOyB9XG5cbiAgICAgICAgLyogY2hlY2sgZm9yIGVuZC1vZi1ibG9jayBjb2RlIChiZXR0ZXIgaGF2ZSBvbmUpICovXG4gICAgICAgIGlmIChzdGF0ZS5sZW5zWzI1Nl0gPT09IDApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgLS0gbWlzc2luZyBlbmQtb2YtYmxvY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBidWlsZCBjb2RlIHRhYmxlcyAtLSBub3RlOiBkbyBub3QgY2hhbmdlIHRoZSBsZW5iaXRzIG9yIGRpc3RiaXRzXG4gICAgICAgICAgIHZhbHVlcyBoZXJlICg5IGFuZCA2KSB3aXRob3V0IHJlYWRpbmcgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgICAgICAgICAgY29uY2VybmluZyB0aGUgRU5PVUdIIGNvbnN0YW50cywgd2hpY2ggZGVwZW5kIG9uIHRob3NlIHZhbHVlcyAqL1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gOTtcblxuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoTEVOUywgc3RhdGUubGVucywgMCwgc3RhdGUubmxlbiwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aHMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSA2O1xuICAgICAgICAvL3N0YXRlLmRpc3Rjb2RlLmNvcHkoc3RhdGUuY29kZXMpO1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgICAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluO1xuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5kaXN0Yml0cyB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCBzdGF0ZS5ubGVuLCBzdGF0ZS5uZGlzdCwgc3RhdGUuZGlzdGNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAgIC8vIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZXMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsICdpbmZsYXRlOiAgICAgICBjb2RlcyBva1xcbicpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTl87XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5fOlxuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTjpcbiAgICAgICAgaWYgKGhhdmUgPj0gNiAmJiBsZWZ0ID49IDI1OCkge1xuICAgICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgaW5mbGF0ZV9mYXN0KHN0cm0sIF9vdXQpO1xuICAgICAgICAgIC8vLS0tIExPQUQoKSAtLS1cbiAgICAgICAgICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICAgICAgICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICAgICAgICAgIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICAgICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgICAgICAgICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgICAgICAgICBob2xkID0gc3RhdGUuaG9sZDtcbiAgICAgICAgICBiaXRzID0gc3RhdGUuYml0cztcbiAgICAgICAgICAvLy0tLVxuXG4gICAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHtcbiAgICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuYmFjayA9IDA7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOyAgLypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKGhlcmVfYml0cyA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYmIChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgICBzdGF0ZS5sZW5ndGggPSBoZXJlX3ZhbDtcbiAgICAgICAgaWYgKGhlcmVfb3AgPT09IDApIHtcbiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gTElUO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYgMzIpIHtcbiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZXh0cmEgPSBoZXJlX29wICYgMTU7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5FWFQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVORVhUOlxuICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgICBzdGF0ZS53YXMgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBESVNUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJU1Q6XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxKV07LypCSVRTKHN0YXRlLmRpc3RiaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLSAxKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTtcbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUub2Zmc2V0ID0gaGVyZV92YWw7XG4gICAgICAgIHN0YXRlLmV4dHJhID0gKGhlcmVfb3ApICYgMTU7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBESVNURVhUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJU1RFWFQ6XG4gICAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUub2Zmc2V0ICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICAgIH1cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBzdGF0ZS5kbWF4KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcXG5cIiwgc3RhdGUub2Zmc2V0KSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBNQVRDSDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBNQVRDSDpcbiAgICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGNvcHkgPSBfb3V0IC0gbGVmdDtcbiAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IGNvcHkpIHsgICAgICAgICAvKiBjb3B5IGZyb20gd2luZG93ICovXG4gICAgICAgICAgY29weSA9IHN0YXRlLm9mZnNldCAtIGNvcHk7XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53aGF2ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgIFRyYWNlKChzdGRlcnIsIFwiaW5mbGF0ZS5jIHRvbyBmYXJcXG5cIikpO1xuLy8gICAgICAgICAgY29weSAtPSBzdGF0ZS53aGF2ZTtcbi8vICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbi8vICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuLy8gICAgICAgICAgbGVmdCAtPSBjb3B5O1xuLy8gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4vLyAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgIG91dHB1dFtwdXQrK10gPSAwO1xuLy8gICAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbi8vICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuLy8gICAgICAgICAgYnJlYWs7XG4vLyNlbmRpZlxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLnduZXh0KSB7XG4gICAgICAgICAgICBjb3B5IC09IHN0YXRlLnduZXh0O1xuICAgICAgICAgICAgZnJvbSA9IHN0YXRlLndzaXplIC0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcm9tID0gc3RhdGUud25leHQgLSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4gICAgICAgICAgZnJvbV9zb3VyY2UgPSBzdGF0ZS53aW5kb3c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogY29weSBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgIGZyb20gPSBwdXQgLSBzdGF0ZS5vZmZzZXQ7XG4gICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbiAgICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG91dHB1dFtwdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7IHN0YXRlLm1vZGUgPSBMRU47IH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIExJVDpcbiAgICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIG91dHB1dFtwdXQrK10gPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGxlZnQtLTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENIRUNLOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIC8vIFVzZSAnfCcgaW5zdGVhZCBvZiAnKycgdG8gbWFrZSBzdXJlIHRoYXQgcmVzdWx0IGlzIHNpZ25lZFxuICAgICAgICAgICAgaG9sZCB8PSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBfb3V0IC09IGxlZnQ7XG4gICAgICAgICAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgICAgICAgICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICAgICAgICAgIGlmIChfb3V0KSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPVxuICAgICAgICAgICAgICAgIC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBwdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgICAgICAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSk7XG5cbiAgICAgICAgICB9XG4gICAgICAgICAgX291dCA9IGxlZnQ7XG4gICAgICAgICAgLy8gTkI6IGNyYzMyIHN0b3JlZCBhcyBzaWduZWQgMzItYml0IGludCwgenN3YXAzMiByZXR1cm5zIHNpZ25lZCB0b29cbiAgICAgICAgICBpZiAoKHN0YXRlLmZsYWdzID8gaG9sZCA6IHpzd2FwMzIoaG9sZCkpICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGRhdGEgY2hlY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgY2hlY2sgbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOR1RIO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkdUSDpcbiAgICAgICAgaWYgKHN0YXRlLndyYXAgJiYgc3RhdGUuZmxhZ3MpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUudG90YWwgJiAweGZmZmZmZmZmKSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGxlbmd0aCBjaGVjayc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBsZW5ndGggbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gRE9ORTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBET05FOlxuICAgICAgICByZXQgPSBaX1NUUkVBTV9FTkQ7XG4gICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgIGNhc2UgQkFEOlxuICAgICAgICByZXQgPSBaX0RBVEFfRVJST1I7XG4gICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgIGNhc2UgTUVNOlxuICAgICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgICBjYXNlIFNZTkM6XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICB9XG4gIH1cblxuICAvLyBpbmZfbGVhdmUgPC0gaGVyZSBpcyByZWFsIHBsYWNlIGZvciBcImdvdG8gaW5mX2xlYXZlXCIsIGVtdWxhdGVkIHZpYSBcImJyZWFrIGluZl9sZWF2ZVwiXG5cbiAgLypcbiAgICAgUmV0dXJuIGZyb20gaW5mbGF0ZSgpLCB1cGRhdGluZyB0aGUgdG90YWwgY291bnRzIGFuZCB0aGUgY2hlY2sgdmFsdWUuXG4gICAgIElmIHRoZXJlIHdhcyBubyBwcm9ncmVzcyBkdXJpbmcgdGhlIGluZmxhdGUoKSBjYWxsLCByZXR1cm4gYSBidWZmZXJcbiAgICAgZXJyb3IuICBDYWxsIHVwZGF0ZXdpbmRvdygpIHRvIGNyZWF0ZSBhbmQvb3IgdXBkYXRlIHRoZSB3aW5kb3cgc3RhdGUuXG4gICAgIE5vdGU6IGEgbWVtb3J5IGVycm9yIGZyb20gaW5mbGF0ZSgpIGlzIG5vbi1yZWNvdmVyYWJsZS5cbiAgICovXG5cbiAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIC8vLS0tXG5cbiAgaWYgKHN0YXRlLndzaXplIHx8IChfb3V0ICE9PSBzdHJtLmF2YWlsX291dCAmJiBzdGF0ZS5tb2RlIDwgQkFEICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPCBDSEVDSyB8fCBmbHVzaCAhPT0gWl9GSU5JU0gpKSkge1xuICAgIGlmICh1cGRhdGV3aW5kb3coc3RybSwgc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQsIF9vdXQgLSBzdHJtLmF2YWlsX291dCkpIHtcbiAgICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgfVxuICB9XG4gIF9pbiAtPSBzdHJtLmF2YWlsX2luO1xuICBfb3V0IC09IHN0cm0uYXZhaWxfb3V0O1xuICBzdHJtLnRvdGFsX2luICs9IF9pbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgaWYgKHN0YXRlLndyYXAgJiYgX291dCkge1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBzdHJtLm5leHRfb3V0IC0gX291dCwgX291dCk7Ki9cbiAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpKTtcbiAgfVxuICBzdHJtLmRhdGFfdHlwZSA9IHN0YXRlLmJpdHMgKyAoc3RhdGUubGFzdCA/IDY0IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gVFlQRSA/IDEyOCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IExFTl8gfHwgc3RhdGUubW9kZSA9PT0gQ09QWV8gPyAyNTYgOiAwKTtcbiAgaWYgKCgoX2luID09PSAwICYmIF9vdXQgPT09IDApIHx8IGZsdXNoID09PSBaX0ZJTklTSCkgJiYgcmV0ID09PSBaX09LKSB7XG4gICAgcmV0ID0gWl9CVUZfRVJST1I7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUVuZChzdHJtKSB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIC8qfHwgc3RybS0+emZyZWUgPT0gKGZyZWVfZnVuYykwKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUud2luZG93KSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuICBzdHJtLnN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVHZXRIZWFkZXIoc3RybSwgaGVhZCkge1xuICB2YXIgc3RhdGU7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmICgoc3RhdGUud3JhcCAmIDIpID09PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuXG4gIC8qIHNhdmUgaGVhZGVyIHN0cnVjdHVyZSAqL1xuICBzdGF0ZS5oZWFkID0gaGVhZDtcbiAgaGVhZC5kb25lID0gZmFsc2U7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7XG4gIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgdmFyIHN0YXRlO1xuICB2YXIgZGljdGlkO1xuICB2YXIgcmV0O1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSAvKiA9PSBaX05VTEwgKi8gfHwgIXN0cm0uc3RhdGUgLyogPT0gWl9OVUxMICovKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKHN0YXRlLndyYXAgIT09IDAgJiYgc3RhdGUubW9kZSAhPT0gRElDVCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBjb3JyZWN0IGRpY3Rpb25hcnkgaWRlbnRpZmllciAqL1xuICBpZiAoc3RhdGUubW9kZSA9PT0gRElDVCkge1xuICAgIGRpY3RpZCA9IDE7IC8qIGFkbGVyMzIoMCwgbnVsbCwgMCkqL1xuICAgIC8qIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gICAgaWYgKGRpY3RpZCAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7XG4gICAgfVxuICB9XG4gIC8qIGNvcHkgZGljdGlvbmFyeSB0byB3aW5kb3cgdXNpbmcgdXBkYXRld2luZG93KCksIHdoaWNoIHdpbGwgYW1lbmQgdGhlXG4gICBleGlzdGluZyBkaWN0aW9uYXJ5IGlmIGFwcHJvcHJpYXRlICovXG4gIHJldCA9IHVwZGF0ZXdpbmRvdyhzdHJtLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCBkaWN0TGVuZ3RoKTtcbiAgaWYgKHJldCkge1xuICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICB9XG4gIHN0YXRlLmhhdmVkaWN0ID0gMTtcbiAgLy8gVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBkaWN0aW9uYXJ5IHNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufVxuXG5leHBvcnRzLmluZmxhdGVSZXNldCA9IGluZmxhdGVSZXNldDtcbmV4cG9ydHMuaW5mbGF0ZVJlc2V0MiA9IGluZmxhdGVSZXNldDI7XG5leHBvcnRzLmluZmxhdGVSZXNldEtlZXAgPSBpbmZsYXRlUmVzZXRLZWVwO1xuZXhwb3J0cy5pbmZsYXRlSW5pdCA9IGluZmxhdGVJbml0O1xuZXhwb3J0cy5pbmZsYXRlSW5pdDIgPSBpbmZsYXRlSW5pdDI7XG5leHBvcnRzLmluZmxhdGUgPSBpbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlRW5kID0gaW5mbGF0ZUVuZDtcbmV4cG9ydHMuaW5mbGF0ZUdldEhlYWRlciA9IGluZmxhdGVHZXRIZWFkZXI7XG5leHBvcnRzLmluZmxhdGVTZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZVNldERpY3Rpb25hcnk7XG5leHBvcnRzLmluZmxhdGVJbmZvID0gJ3Bha28gaW5mbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbmV4cG9ydHMuaW5mbGF0ZUNvcHkgPSBpbmZsYXRlQ29weTtcbmV4cG9ydHMuaW5mbGF0ZUdldERpY3Rpb25hcnkgPSBpbmZsYXRlR2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuaW5mbGF0ZU1hcmsgPSBpbmZsYXRlTWFyaztcbmV4cG9ydHMuaW5mbGF0ZVByaW1lID0gaW5mbGF0ZVByaW1lO1xuZXhwb3J0cy5pbmZsYXRlU3luYyA9IGluZmxhdGVTeW5jO1xuZXhwb3J0cy5pbmZsYXRlU3luY1BvaW50ID0gaW5mbGF0ZVN5bmNQb2ludDtcbmV4cG9ydHMuaW5mbGF0ZVVuZGVybWluZSA9IGluZmxhdGVVbmRlcm1pbmU7XG4qL1xuXG59LHtcIi4uL3V0aWxzL2NvbW1vblwiOjUsXCIuL2FkbGVyMzJcIjo3LFwiLi9jcmMzMlwiOjksXCIuL2luZmZhc3RcIjoxMSxcIi4vaW5mdHJlZXNcIjoxM31dLDEzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblxudmFyIE1BWEJJVFMgPSAxNTtcbnZhciBFTk9VR0hfTEVOUyA9IDg1MjtcbnZhciBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL3ZhciBFTk9VR0ggPSAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxudmFyIENPREVTID0gMDtcbnZhciBMRU5TID0gMTtcbnZhciBESVNUUyA9IDI7XG5cbnZhciBsYmFzZSA9IFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGJhc2UgKi9cbiAgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMywgMTUsIDE3LCAxOSwgMjMsIDI3LCAzMSxcbiAgMzUsIDQzLCA1MSwgNTksIDY3LCA4MywgOTksIDExNSwgMTMxLCAxNjMsIDE5NSwgMjI3LCAyNTgsIDAsIDBcbl07XG5cbnZhciBsZXh0ID0gWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE3LCAxNywgMTgsIDE4LCAxOCwgMTgsXG4gIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLCAyMCwgMjEsIDIxLCAyMSwgMjEsIDE2LCA3MiwgNzhcbl07XG5cbnZhciBkYmFzZSA9IFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgYmFzZSAqL1xuICAxLCAyLCAzLCA0LCA1LCA3LCA5LCAxMywgMTcsIDI1LCAzMywgNDksIDY1LCA5NywgMTI5LCAxOTMsXG4gIDI1NywgMzg1LCA1MTMsIDc2OSwgMTAyNSwgMTUzNywgMjA0OSwgMzA3MywgNDA5NywgNjE0NSxcbiAgODE5MywgMTIyODksIDE2Mzg1LCAyNDU3NywgMCwgMFxuXTtcblxudmFyIGRleHQgPSBbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE4LCAxOCwgMTksIDE5LCAyMCwgMjAsIDIxLCAyMSwgMjIsIDIyLFxuICAyMywgMjMsIDI0LCAyNCwgMjUsIDI1LCAyNiwgMjYsIDI3LCAyNyxcbiAgMjgsIDI4LCAyOSwgMjksIDY0LCA2NFxuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX3RhYmxlKHR5cGUsIGxlbnMsIGxlbnNfaW5kZXgsIGNvZGVzLCB0YWJsZSwgdGFibGVfaW5kZXgsIHdvcmssIG9wdHMpXG57XG4gIHZhciBiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgLy9oZXJlID0gb3B0cy5oZXJlOyAvKiB0YWJsZSBlbnRyeSBmb3IgZHVwbGljYXRpb24gKi9cblxuICB2YXIgbGVuID0gMDsgICAgICAgICAgICAgICAvKiBhIGNvZGUncyBsZW5ndGggaW4gYml0cyAqL1xuICB2YXIgc3ltID0gMDsgICAgICAgICAgICAgICAvKiBpbmRleCBvZiBjb2RlIHN5bWJvbHMgKi9cbiAgdmFyIG1pbiA9IDAsIG1heCA9IDA7ICAgICAgICAgIC8qIG1pbmltdW0gYW5kIG1heGltdW0gY29kZSBsZW5ndGhzICovXG4gIHZhciByb290ID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciByb290IHRhYmxlICovXG4gIHZhciBjdXJyID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciBjdXJyZW50IHRhYmxlICovXG4gIHZhciBkcm9wID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgYml0cyB0byBkcm9wIGZvciBzdWItdGFibGUgKi9cbiAgdmFyIGxlZnQgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgcHJlZml4IGNvZGVzIGF2YWlsYWJsZSAqL1xuICB2YXIgdXNlZCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGVudHJpZXMgaW4gdGFibGUgdXNlZCAqL1xuICB2YXIgaHVmZiA9IDA7ICAgICAgICAgICAgICAvKiBIdWZmbWFuIGNvZGUgKi9cbiAgdmFyIGluY3I7ICAgICAgICAgICAgICAvKiBmb3IgaW5jcmVtZW50aW5nIGNvZGUsIGluZGV4ICovXG4gIHZhciBmaWxsOyAgICAgICAgICAgICAgLyogaW5kZXggZm9yIHJlcGxpY2F0aW5nIGVudHJpZXMgKi9cbiAgdmFyIGxvdzsgICAgICAgICAgICAgICAvKiBsb3cgYml0cyBmb3IgY3VycmVudCByb290IGVudHJ5ICovXG4gIHZhciBtYXNrOyAgICAgICAgICAgICAgLyogbWFzayBmb3IgbG93IHJvb3QgYml0cyAqL1xuICB2YXIgbmV4dDsgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gdGFibGUgKi9cbiAgdmFyIGJhc2UgPSBudWxsOyAgICAgLyogYmFzZSB2YWx1ZSB0YWJsZSB0byB1c2UgKi9cbiAgdmFyIGJhc2VfaW5kZXggPSAwO1xuLy8gIHZhciBzaG9leHRyYTsgICAgLyogZXh0cmEgYml0cyB0YWJsZSB0byB1c2UgKi9cbiAgdmFyIGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHVzZSBiYXNlIGFuZCBleHRyYSBmb3Igc3ltYm9sID4gZW5kICovXG4gIHZhciBjb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgIC8qIG51bWJlciBvZiBjb2RlcyBvZiBlYWNoIGxlbmd0aCAqL1xuICB2YXIgb2ZmcyA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgICAvKiBvZmZzZXRzIGluIHRhYmxlIGZvciBlYWNoIGxlbmd0aCAqL1xuICB2YXIgZXh0cmEgPSBudWxsO1xuICB2YXIgZXh0cmFfaW5kZXggPSAwO1xuXG4gIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsO1xuXG4gIC8qXG4gICBQcm9jZXNzIGEgc2V0IG9mIGNvZGUgbGVuZ3RocyB0byBjcmVhdGUgYSBjYW5vbmljYWwgSHVmZm1hbiBjb2RlLiAgVGhlXG4gICBjb2RlIGxlbmd0aHMgYXJlIGxlbnNbMC4uY29kZXMtMV0uICBFYWNoIGxlbmd0aCBjb3JyZXNwb25kcyB0byB0aGVcbiAgIHN5bWJvbHMgMC4uY29kZXMtMS4gIFRoZSBIdWZmbWFuIGNvZGUgaXMgZ2VuZXJhdGVkIGJ5IGZpcnN0IHNvcnRpbmcgdGhlXG4gICBzeW1ib2xzIGJ5IGxlbmd0aCBmcm9tIHNob3J0IHRvIGxvbmcsIGFuZCByZXRhaW5pbmcgdGhlIHN5bWJvbCBvcmRlclxuICAgZm9yIGNvZGVzIHdpdGggZXF1YWwgbGVuZ3Rocy4gIFRoZW4gdGhlIGNvZGUgc3RhcnRzIHdpdGggYWxsIHplcm8gYml0c1xuICAgZm9yIHRoZSBmaXJzdCBjb2RlIG9mIHRoZSBzaG9ydGVzdCBsZW5ndGgsIGFuZCB0aGUgY29kZXMgYXJlIGludGVnZXJcbiAgIGluY3JlbWVudHMgZm9yIHRoZSBzYW1lIGxlbmd0aCwgYW5kIHplcm9zIGFyZSBhcHBlbmRlZCBhcyB0aGUgbGVuZ3RoXG4gICBpbmNyZWFzZXMuICBGb3IgdGhlIGRlZmxhdGUgZm9ybWF0LCB0aGVzZSBiaXRzIGFyZSBzdG9yZWQgYmFja3dhcmRzXG4gICBmcm9tIHRoZWlyIG1vcmUgbmF0dXJhbCBpbnRlZ2VyIGluY3JlbWVudCBvcmRlcmluZywgYW5kIHNvIHdoZW4gdGhlXG4gICBkZWNvZGluZyB0YWJsZXMgYXJlIGJ1aWx0IGluIHRoZSBsYXJnZSBsb29wIGJlbG93LCB0aGUgaW50ZWdlciBjb2Rlc1xuICAgYXJlIGluY3JlbWVudGVkIGJhY2t3YXJkcy5cblxuICAgVGhpcyByb3V0aW5lIGFzc3VtZXMsIGJ1dCBkb2VzIG5vdCBjaGVjaywgdGhhdCBhbGwgb2YgdGhlIGVudHJpZXMgaW5cbiAgIGxlbnNbXSBhcmUgaW4gdGhlIHJhbmdlIDAuLk1BWEJJVFMuICBUaGUgY2FsbGVyIG11c3QgYXNzdXJlIHRoaXMuXG4gICAxLi5NQVhCSVRTIGlzIGludGVycHJldGVkIGFzIHRoYXQgY29kZSBsZW5ndGguICB6ZXJvIG1lYW5zIHRoYXQgdGhhdFxuICAgc3ltYm9sIGRvZXMgbm90IG9jY3VyIGluIHRoaXMgY29kZS5cblxuICAgVGhlIGNvZGVzIGFyZSBzb3J0ZWQgYnkgY29tcHV0aW5nIGEgY291bnQgb2YgY29kZXMgZm9yIGVhY2ggbGVuZ3RoLFxuICAgY3JlYXRpbmcgZnJvbSB0aGF0IGEgdGFibGUgb2Ygc3RhcnRpbmcgaW5kaWNlcyBmb3IgZWFjaCBsZW5ndGggaW4gdGhlXG4gICBzb3J0ZWQgdGFibGUsIGFuZCB0aGVuIGVudGVyaW5nIHRoZSBzeW1ib2xzIGluIG9yZGVyIGluIHRoZSBzb3J0ZWRcbiAgIHRhYmxlLiAgVGhlIHNvcnRlZCB0YWJsZSBpcyB3b3JrW10sIHdpdGggdGhhdCBzcGFjZSBiZWluZyBwcm92aWRlZCBieVxuICAgdGhlIGNhbGxlci5cblxuICAgVGhlIGxlbmd0aCBjb3VudHMgYXJlIHVzZWQgZm9yIG90aGVyIHB1cnBvc2VzIGFzIHdlbGwsIGkuZS4gZmluZGluZ1xuICAgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gbGVuZ3RoIGNvZGVzLCBkZXRlcm1pbmluZyBpZiB0aGVyZSBhcmUgYW55XG4gICBjb2RlcyBhdCBhbGwsIGNoZWNraW5nIGZvciBhIHZhbGlkIHNldCBvZiBsZW5ndGhzLCBhbmQgbG9va2luZyBhaGVhZFxuICAgYXQgbGVuZ3RoIGNvdW50cyB0byBkZXRlcm1pbmUgc3ViLXRhYmxlIHNpemVzIHdoZW4gYnVpbGRpbmcgdGhlXG4gICBkZWNvZGluZyB0YWJsZXMuXG4gICAqL1xuXG4gIC8qIGFjY3VtdWxhdGUgbGVuZ3RocyBmb3IgY29kZXMgKGFzc3VtZXMgbGVuc1tdIGFsbCBpbiAwLi5NQVhCSVRTKSAqL1xuICBmb3IgKGxlbiA9IDA7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGNvdW50W2xlbl0gPSAwO1xuICB9XG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgY291bnRbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rKztcbiAgfVxuXG4gIC8qIGJvdW5kIGNvZGUgbGVuZ3RocywgZm9yY2Ugcm9vdCB0byBiZSB3aXRoaW4gY29kZSBsZW5ndGhzICovXG4gIHJvb3QgPSBiaXRzO1xuICBmb3IgKG1heCA9IE1BWEJJVFM7IG1heCA+PSAxOyBtYXgtLSkge1xuICAgIGlmIChjb3VudFttYXhdICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPiBtYXgpIHtcbiAgICByb290ID0gbWF4O1xuICB9XG4gIGlmIChtYXggPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAvKiBubyBzeW1ib2xzIHRvIGNvZGUgYXQgYWxsICovXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0OyAgLy9oZXJlLm9wID0gKHZhciBjaGFyKTY0OyAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTsgICAvL2hlcmUuYml0cyA9ICh2YXIgY2hhcikxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwOyAgIC8vaGVyZS52YWwgPSAodmFyIHNob3J0KTA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0O1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuICAgIG9wdHMuYml0cyA9IDE7XG4gICAgcmV0dXJuIDA7ICAgICAvKiBubyBzeW1ib2xzLCBidXQgd2FpdCBmb3IgZGVjb2RpbmcgdG8gcmVwb3J0IGVycm9yICovXG4gIH1cbiAgZm9yIChtaW4gPSAxOyBtaW4gPCBtYXg7IG1pbisrKSB7XG4gICAgaWYgKGNvdW50W21pbl0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA8IG1pbikge1xuICAgIHJvb3QgPSBtaW47XG4gIH1cblxuICAvKiBjaGVjayBmb3IgYW4gb3Zlci1zdWJzY3JpYmVkIG9yIGluY29tcGxldGUgc2V0IG9mIGxlbmd0aHMgKi9cbiAgbGVmdCA9IDE7XG4gIGZvciAobGVuID0gMTsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgbGVmdCA8PD0gMTtcbiAgICBsZWZ0IC09IGNvdW50W2xlbl07XG4gICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSAgICAgICAgLyogb3Zlci1zdWJzY3JpYmVkICovXG4gIH1cbiAgaWYgKGxlZnQgPiAwICYmICh0eXBlID09PSBDT0RFUyB8fCBtYXggIT09IDEpKSB7XG4gICAgcmV0dXJuIC0xOyAgICAgICAgICAgICAgICAgICAgICAvKiBpbmNvbXBsZXRlIHNldCAqL1xuICB9XG5cbiAgLyogZ2VuZXJhdGUgb2Zmc2V0cyBpbnRvIHN5bWJvbCB0YWJsZSBmb3IgZWFjaCBsZW5ndGggZm9yIHNvcnRpbmcgKi9cbiAgb2Zmc1sxXSA9IDA7XG4gIGZvciAobGVuID0gMTsgbGVuIDwgTUFYQklUUzsgbGVuKyspIHtcbiAgICBvZmZzW2xlbiArIDFdID0gb2Zmc1tsZW5dICsgY291bnRbbGVuXTtcbiAgfVxuXG4gIC8qIHNvcnQgc3ltYm9scyBieSBsZW5ndGgsIGJ5IHN5bWJvbCBvcmRlciB3aXRoaW4gZWFjaCBsZW5ndGggKi9cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBpZiAobGVuc1tsZW5zX2luZGV4ICsgc3ltXSAhPT0gMCkge1xuICAgICAgd29ya1tvZmZzW2xlbnNbbGVuc19pbmRleCArIHN5bV1dKytdID0gc3ltO1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gICBDcmVhdGUgYW5kIGZpbGwgaW4gZGVjb2RpbmcgdGFibGVzLiAgSW4gdGhpcyBsb29wLCB0aGUgdGFibGUgYmVpbmdcbiAgIGZpbGxlZCBpcyBhdCBuZXh0IGFuZCBoYXMgY3VyciBpbmRleCBiaXRzLiAgVGhlIGNvZGUgYmVpbmcgdXNlZCBpcyBodWZmXG4gICB3aXRoIGxlbmd0aCBsZW4uICBUaGF0IGNvZGUgaXMgY29udmVydGVkIHRvIGFuIGluZGV4IGJ5IGRyb3BwaW5nIGRyb3BcbiAgIGJpdHMgb2ZmIG9mIHRoZSBib3R0b20uICBGb3IgY29kZXMgd2hlcmUgbGVuIGlzIGxlc3MgdGhhbiBkcm9wICsgY3VycixcbiAgIHRob3NlIHRvcCBkcm9wICsgY3VyciAtIGxlbiBiaXRzIGFyZSBpbmNyZW1lbnRlZCB0aHJvdWdoIGFsbCB2YWx1ZXMgdG9cbiAgIGZpbGwgdGhlIHRhYmxlIHdpdGggcmVwbGljYXRlZCBlbnRyaWVzLlxuXG4gICByb290IGlzIHRoZSBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgdGhlIHJvb3QgdGFibGUuICBXaGVuIGxlbiBleGNlZWRzXG4gICByb290LCBzdWItdGFibGVzIGFyZSBjcmVhdGVkIHBvaW50ZWQgdG8gYnkgdGhlIHJvb3QgZW50cnkgd2l0aCBhbiBpbmRleFxuICAgb2YgdGhlIGxvdyByb290IGJpdHMgb2YgaHVmZi4gIFRoaXMgaXMgc2F2ZWQgaW4gbG93IHRvIGNoZWNrIGZvciB3aGVuIGFcbiAgIG5ldyBzdWItdGFibGUgc2hvdWxkIGJlIHN0YXJ0ZWQuICBkcm9wIGlzIHplcm8gd2hlbiB0aGUgcm9vdCB0YWJsZSBpc1xuICAgYmVpbmcgZmlsbGVkLCBhbmQgZHJvcCBpcyByb290IHdoZW4gc3ViLXRhYmxlcyBhcmUgYmVpbmcgZmlsbGVkLlxuXG4gICBXaGVuIGEgbmV3IHN1Yi10YWJsZSBpcyBuZWVkZWQsIGl0IGlzIG5lY2Vzc2FyeSB0byBsb29rIGFoZWFkIGluIHRoZVxuICAgY29kZSBsZW5ndGhzIHRvIGRldGVybWluZSB3aGF0IHNpemUgc3ViLXRhYmxlIGlzIG5lZWRlZC4gIFRoZSBsZW5ndGhcbiAgIGNvdW50cyBhcmUgdXNlZCBmb3IgdGhpcywgYW5kIHNvIGNvdW50W10gaXMgZGVjcmVtZW50ZWQgYXMgY29kZXMgYXJlXG4gICBlbnRlcmVkIGluIHRoZSB0YWJsZXMuXG5cbiAgIHVzZWQga2VlcHMgdHJhY2sgb2YgaG93IG1hbnkgdGFibGUgZW50cmllcyBoYXZlIGJlZW4gYWxsb2NhdGVkIGZyb20gdGhlXG4gICBwcm92aWRlZCAqdGFibGUgc3BhY2UuICBJdCBpcyBjaGVja2VkIGZvciBMRU5TIGFuZCBESVNUIHRhYmxlcyBhZ2FpbnN0XG4gICB0aGUgY29uc3RhbnRzIEVOT1VHSF9MRU5TIGFuZCBFTk9VR0hfRElTVFMgdG8gZ3VhcmQgYWdhaW5zdCBjaGFuZ2VzIGluXG4gICB0aGUgaW5pdGlhbCByb290IHRhYmxlIHNpemUgY29uc3RhbnRzLiAgU2VlIHRoZSBjb21tZW50cyBpbiBpbmZ0cmVlcy5oXG4gICBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblxuICAgc3ltIGluY3JlbWVudHMgdGhyb3VnaCBhbGwgc3ltYm9scywgYW5kIHRoZSBsb29wIHRlcm1pbmF0ZXMgd2hlblxuICAgYWxsIGNvZGVzIG9mIGxlbmd0aCBtYXgsIGkuZS4gYWxsIGNvZGVzLCBoYXZlIGJlZW4gcHJvY2Vzc2VkLiAgVGhpc1xuICAgcm91dGluZSBwZXJtaXRzIGluY29tcGxldGUgY29kZXMsIHNvIGFub3RoZXIgbG9vcCBhZnRlciB0aGlzIG9uZSBmaWxsc1xuICAgaW4gdGhlIHJlc3Qgb2YgdGhlIGRlY29kaW5nIHRhYmxlcyB3aXRoIGludmFsaWQgY29kZSBtYXJrZXJzLlxuICAgKi9cblxuICAvKiBzZXQgdXAgZm9yIGNvZGUgdHlwZSAqL1xuICAvLyBwb29yIG1hbiBvcHRpbWl6YXRpb24gLSB1c2UgaWYtZWxzZSBpbnN0ZWFkIG9mIHN3aXRjaCxcbiAgLy8gdG8gYXZvaWQgZGVvcHRzIGluIG9sZCB2OFxuICBpZiAodHlwZSA9PT0gQ09ERVMpIHtcbiAgICBiYXNlID0gZXh0cmEgPSB3b3JrOyAgICAvKiBkdW1teSB2YWx1ZS0tbm90IHVzZWQgKi9cbiAgICBlbmQgPSAxOTtcblxuICB9IGVsc2UgaWYgKHR5cGUgPT09IExFTlMpIHtcbiAgICBiYXNlID0gbGJhc2U7XG4gICAgYmFzZV9pbmRleCAtPSAyNTc7XG4gICAgZXh0cmEgPSBsZXh0O1xuICAgIGV4dHJhX2luZGV4IC09IDI1NztcbiAgICBlbmQgPSAyNTY7XG5cbiAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgIC8qIERJU1RTICovXG4gICAgYmFzZSA9IGRiYXNlO1xuICAgIGV4dHJhID0gZGV4dDtcbiAgICBlbmQgPSAtMTtcbiAgfVxuXG4gIC8qIGluaXRpYWxpemUgb3B0cyBmb3IgbG9vcCAqL1xuICBodWZmID0gMDsgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSAqL1xuICBzeW0gPSAwOyAgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBzeW1ib2wgKi9cbiAgbGVuID0gbWluOyAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgbGVuZ3RoICovXG4gIG5leHQgPSB0YWJsZV9pbmRleDsgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgdG8gZmlsbCBpbiAqL1xuICBjdXJyID0gcm9vdDsgICAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSBpbmRleCBiaXRzICovXG4gIGRyb3AgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBjdXJyZW50IGJpdHMgdG8gZHJvcCBmcm9tIGNvZGUgZm9yIGluZGV4ICovXG4gIGxvdyA9IC0xOyAgICAgICAgICAgICAgICAgICAvKiB0cmlnZ2VyIG5ldyBzdWItdGFibGUgd2hlbiBsZW4gPiByb290ICovXG4gIHVzZWQgPSAxIDw8IHJvb3Q7ICAgICAgICAgIC8qIHVzZSByb290IHRhYmxlIGVudHJpZXMgKi9cbiAgbWFzayA9IHVzZWQgLSAxOyAgICAgICAgICAgIC8qIG1hc2sgZm9yIGNvbXBhcmluZyBsb3cgKi9cblxuICAvKiBjaGVjayBhdmFpbGFibGUgdGFibGUgc3BhY2UgKi9cbiAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHxcbiAgICAodHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8qIHByb2Nlc3MgYWxsIGNvZGVzIGFuZCBtYWtlIHRhYmxlIGVudHJpZXMgKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIGNyZWF0ZSB0YWJsZSBlbnRyeSAqL1xuICAgIGhlcmVfYml0cyA9IGxlbiAtIGRyb3A7XG4gICAgaWYgKHdvcmtbc3ltXSA8IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IDA7XG4gICAgICBoZXJlX3ZhbCA9IHdvcmtbc3ltXTtcbiAgICB9XG4gICAgZWxzZSBpZiAod29ya1tzeW1dID4gZW5kKSB7XG4gICAgICBoZXJlX29wID0gZXh0cmFbZXh0cmFfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgICAgaGVyZV92YWwgPSBiYXNlW2Jhc2VfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGhlcmVfb3AgPSAzMiArIDY0OyAgICAgICAgIC8qIGVuZCBvZiBibG9jayAqL1xuICAgICAgaGVyZV92YWwgPSAwO1xuICAgIH1cblxuICAgIC8qIHJlcGxpY2F0ZSBmb3IgdGhvc2UgaW5kaWNlcyB3aXRoIGxvdyBsZW4gYml0cyBlcXVhbCB0byBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIGRyb3ApO1xuICAgIGZpbGwgPSAxIDw8IGN1cnI7XG4gICAgbWluID0gZmlsbDsgICAgICAgICAgICAgICAgIC8qIHNhdmUgb2Zmc2V0IHRvIG5leHQgdGFibGUgKi9cbiAgICBkbyB7XG4gICAgICBmaWxsIC09IGluY3I7XG4gICAgICB0YWJsZVtuZXh0ICsgKGh1ZmYgPj4gZHJvcCkgKyBmaWxsXSA9IChoZXJlX2JpdHMgPDwgMjQpIHwgKGhlcmVfb3AgPDwgMTYpIHwgaGVyZV92YWwgfDA7XG4gICAgfSB3aGlsZSAoZmlsbCAhPT0gMCk7XG5cbiAgICAvKiBiYWNrd2FyZHMgaW5jcmVtZW50IHRoZSBsZW4tYml0IGNvZGUgaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSAxKTtcbiAgICB3aGlsZSAoaHVmZiAmIGluY3IpIHtcbiAgICAgIGluY3IgPj49IDE7XG4gICAgfVxuICAgIGlmIChpbmNyICE9PSAwKSB7XG4gICAgICBodWZmICY9IGluY3IgLSAxO1xuICAgICAgaHVmZiArPSBpbmNyO1xuICAgIH0gZWxzZSB7XG4gICAgICBodWZmID0gMDtcbiAgICB9XG5cbiAgICAvKiBnbyB0byBuZXh0IHN5bWJvbCwgdXBkYXRlIGNvdW50LCBsZW4gKi9cbiAgICBzeW0rKztcbiAgICBpZiAoLS1jb3VudFtsZW5dID09PSAwKSB7XG4gICAgICBpZiAobGVuID09PSBtYXgpIHsgYnJlYWs7IH1cbiAgICAgIGxlbiA9IGxlbnNbbGVuc19pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuXG4gICAgLyogY3JlYXRlIG5ldyBzdWItdGFibGUgaWYgbmVlZGVkICovXG4gICAgaWYgKGxlbiA+IHJvb3QgJiYgKGh1ZmYgJiBtYXNrKSAhPT0gbG93KSB7XG4gICAgICAvKiBpZiBmaXJzdCB0aW1lLCB0cmFuc2l0aW9uIHRvIHN1Yi10YWJsZXMgKi9cbiAgICAgIGlmIChkcm9wID09PSAwKSB7XG4gICAgICAgIGRyb3AgPSByb290O1xuICAgICAgfVxuXG4gICAgICAvKiBpbmNyZW1lbnQgcGFzdCBsYXN0IHRhYmxlICovXG4gICAgICBuZXh0ICs9IG1pbjsgICAgICAgICAgICAvKiBoZXJlIG1pbiBpcyAxIDw8IGN1cnIgKi9cblxuICAgICAgLyogZGV0ZXJtaW5lIGxlbmd0aCBvZiBuZXh0IHRhYmxlICovXG4gICAgICBjdXJyID0gbGVuIC0gZHJvcDtcbiAgICAgIGxlZnQgPSAxIDw8IGN1cnI7XG4gICAgICB3aGlsZSAoY3VyciArIGRyb3AgPCBtYXgpIHtcbiAgICAgICAgbGVmdCAtPSBjb3VudFtjdXJyICsgZHJvcF07XG4gICAgICAgIGlmIChsZWZ0IDw9IDApIHsgYnJlYWs7IH1cbiAgICAgICAgY3VycisrO1xuICAgICAgICBsZWZ0IDw8PSAxO1xuICAgICAgfVxuXG4gICAgICAvKiBjaGVjayBmb3IgZW5vdWdoIHNwYWNlICovXG4gICAgICB1c2VkICs9IDEgPDwgY3VycjtcbiAgICAgIGlmICgodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMpIHx8XG4gICAgICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgLyogcG9pbnQgZW50cnkgaW4gcm9vdCB0YWJsZSB0byBzdWItdGFibGUgKi9cbiAgICAgIGxvdyA9IGh1ZmYgJiBtYXNrO1xuICAgICAgLyp0YWJsZS5vcFtsb3ddID0gY3VycjtcbiAgICAgIHRhYmxlLmJpdHNbbG93XSA9IHJvb3Q7XG4gICAgICB0YWJsZS52YWxbbG93XSA9IG5leHQgLSBvcHRzLnRhYmxlX2luZGV4OyovXG4gICAgICB0YWJsZVtsb3ddID0gKHJvb3QgPDwgMjQpIHwgKGN1cnIgPDwgMTYpIHwgKG5leHQgLSB0YWJsZV9pbmRleCkgfDA7XG4gICAgfVxuICB9XG5cbiAgLyogZmlsbCBpbiByZW1haW5pbmcgdGFibGUgZW50cnkgaWYgY29kZSBpcyBpbmNvbXBsZXRlIChndWFyYW50ZWVkIHRvIGhhdmVcbiAgIGF0IG1vc3Qgb25lIHJlbWFpbmluZyBlbnRyeSwgc2luY2UgaWYgdGhlIGNvZGUgaXMgaW5jb21wbGV0ZSwgdGhlXG4gICBtYXhpbXVtIGNvZGUgbGVuZ3RoIHRoYXQgd2FzIGFsbG93ZWQgdG8gZ2V0IHRoaXMgZmFyIGlzIG9uZSBiaXQpICovXG4gIGlmIChodWZmICE9PSAwKSB7XG4gICAgLy90YWJsZS5vcFtuZXh0ICsgaHVmZl0gPSA2NDsgICAgICAgICAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW25leHQgKyBodWZmXSA9IGxlbiAtIGRyb3A7XG4gICAgLy90YWJsZS52YWxbbmV4dCArIGh1ZmZdID0gMDtcbiAgICB0YWJsZVtuZXh0ICsgaHVmZl0gPSAoKGxlbiAtIGRyb3ApIDw8IDI0KSB8ICg2NCA8PCAxNikgfDA7XG4gIH1cblxuICAvKiBzZXQgcmV0dXJuIHBhcmFtZXRlcnMgKi9cbiAgLy9vcHRzLnRhYmxlX2luZGV4ICs9IHVzZWQ7XG4gIG9wdHMuYml0cyA9IHJvb3Q7XG4gIHJldHVybiAwO1xufTtcblxufSx7XCIuLi91dGlscy9jb21tb25cIjo1fV0sMTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAyOiAgICAgICduZWVkIGRpY3Rpb25hcnknLCAgICAgLyogWl9ORUVEX0RJQ1QgICAgICAgMiAgKi9cbiAgMTogICAgICAnc3RyZWFtIGVuZCcsICAgICAgICAgIC8qIFpfU1RSRUFNX0VORCAgICAgIDEgICovXG4gIDA6ICAgICAgJycsICAgICAgICAgICAgICAgICAgICAvKiBaX09LICAgICAgICAgICAgICAwICAqL1xuICAnLTEnOiAgICdmaWxlIGVycm9yJywgICAgICAgICAgLyogWl9FUlJOTyAgICAgICAgICgtMSkgKi9cbiAgJy0yJzogICAnc3RyZWFtIGVycm9yJywgICAgICAgIC8qIFpfU1RSRUFNX0VSUk9SICAoLTIpICovXG4gICctMyc6ICAgJ2RhdGEgZXJyb3InLCAgICAgICAgICAvKiBaX0RBVEFfRVJST1IgICAgKC0zKSAqL1xuICAnLTQnOiAgICdpbnN1ZmZpY2llbnQgbWVtb3J5JywgLyogWl9NRU1fRVJST1IgICAgICgtNCkgKi9cbiAgJy01JzogICAnYnVmZmVyIGVycm9yJywgICAgICAgIC8qIFpfQlVGX0VSUk9SICAgICAoLTUpICovXG4gICctNic6ICAgJ2luY29tcGF0aWJsZSB2ZXJzaW9uJyAvKiBaX1ZFUlNJT05fRVJST1IgKC02KSAqL1xufTtcblxufSx7fV0sMTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIFpTdHJlYW0oKSB7XG4gIC8qIG5leHQgaW5wdXQgYnl0ZSAqL1xuICB0aGlzLmlucHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfaW4gPSAwO1xuICAvKiBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlIGF0IGlucHV0ICovXG4gIHRoaXMuYXZhaWxfaW4gPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgaW5wdXQgYnl0ZXMgcmVhZCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9pbiA9IDA7XG4gIC8qIG5leHQgb3V0cHV0IGJ5dGUgc2hvdWxkIGJlIHB1dCB0aGVyZSAqL1xuICB0aGlzLm91dHB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X291dCA9IDA7XG4gIC8qIHJlbWFpbmluZyBmcmVlIHNwYWNlIGF0IG91dHB1dCAqL1xuICB0aGlzLmF2YWlsX291dCA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBieXRlcyBvdXRwdXQgc28gZmFyICovXG4gIHRoaXMudG90YWxfb3V0ID0gMDtcbiAgLyogbGFzdCBlcnJvciBtZXNzYWdlLCBOVUxMIGlmIG5vIGVycm9yICovXG4gIHRoaXMubXNnID0gJycvKlpfTlVMTCovO1xuICAvKiBub3QgdmlzaWJsZSBieSBhcHBsaWNhdGlvbnMgKi9cbiAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gIC8qIGJlc3QgZ3Vlc3MgYWJvdXQgdGhlIGRhdGEgdHlwZTogYmluYXJ5IG9yIHRleHQgKi9cbiAgdGhpcy5kYXRhX3R5cGUgPSAyLypaX1VOS05PV04qLztcbiAgLyogYWRsZXIzMiB2YWx1ZSBvZiB0aGUgdW5jb21wcmVzc2VkIGRhdGEgKi9cbiAgdGhpcy5hZGxlciA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gWlN0cmVhbTtcblxufSx7fV19LHt9LFszXSkoMylcbn0pO1xuIiwgIm1vZHVsZS5leHBvcnRzID0ge1xuICBlbmNvZGU6IHJlcXVpcmUoJy4vZGlzdC9wbGFudHVtbC1lbmNvZGVyJykuZW5jb2RlLFxuICBkZWNvZGU6IHJlcXVpcmUoJy4vZGlzdC9wbGFudHVtbC1kZWNvZGVyJykuZGVjb2RlXG59XG4iLCAiLyohXG4gICAgbG9jYWxGb3JhZ2UgLS0gT2ZmbGluZSBTdG9yYWdlLCBJbXByb3ZlZFxuICAgIFZlcnNpb24gMS4xMC4wXG4gICAgaHR0cHM6Ly9sb2NhbGZvcmFnZS5naXRodWIuaW8vbG9jYWxGb3JhZ2VcbiAgICAoYykgMjAxMy0yMDE3IE1vemlsbGEsIEFwYWNoZSBMaWNlbnNlIDIuMFxuKi9cbihmdW5jdGlvbihmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCImJnR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiKXttb2R1bGUuZXhwb3J0cz1mKCl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZil9ZWxzZXt2YXIgZztpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7Zz13aW5kb3d9ZWxzZSBpZih0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIil7Zz1nbG9iYWx9ZWxzZSBpZih0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCIpe2c9c2VsZn1lbHNle2c9dGhpc31nLmxvY2FsZm9yYWdlID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IChmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsIGYpfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xudmFyIE11dGF0aW9uID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG5cbnZhciBzY2hlZHVsZURyYWluO1xuXG57XG4gIGlmIChNdXRhdGlvbikge1xuICAgIHZhciBjYWxsZWQgPSAwO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbihuZXh0VGljayk7XG4gICAgdmFyIGVsZW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCwge1xuICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICAgIH0pO1xuICAgIHNjaGVkdWxlRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBlbGVtZW50LmRhdGEgPSAoY2FsbGVkID0gKytjYWxsZWQgJSAyKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKCFnbG9iYWwuc2V0SW1tZWRpYXRlICYmIHR5cGVvZiBnbG9iYWwuTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGNoYW5uZWwgPSBuZXcgZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKCk7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBuZXh0VGljaztcbiAgICBzY2hlZHVsZURyYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKCdkb2N1bWVudCcgaW4gZ2xvYmFsICYmICdvbnJlYWR5c3RhdGVjaGFuZ2UnIGluIGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSkge1xuICAgIHNjaGVkdWxlRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgIHZhciBzY3JpcHRFbCA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgIHNjcmlwdEVsLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbmV4dFRpY2soKTtcblxuICAgICAgICBzY3JpcHRFbC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICBzY3JpcHRFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdEVsKTtcbiAgICAgICAgc2NyaXB0RWwgPSBudWxsO1xuICAgICAgfTtcbiAgICAgIGdsb2JhbC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0RWwpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgc2NoZWR1bGVEcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNldFRpbWVvdXQobmV4dFRpY2ssIDApO1xuICAgIH07XG4gIH1cbn1cblxudmFyIGRyYWluaW5nO1xudmFyIHF1ZXVlID0gW107XG4vL25hbWVkIG5leHRUaWNrIGZvciBsZXNzIGNvbmZ1c2luZyBzdGFjayB0cmFjZXNcbmZ1bmN0aW9uIG5leHRUaWNrKCkge1xuICBkcmFpbmluZyA9IHRydWU7XG4gIHZhciBpLCBvbGRRdWV1ZTtcbiAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGxlbikge1xuICAgIG9sZFF1ZXVlID0gcXVldWU7XG4gICAgcXVldWUgPSBbXTtcbiAgICBpID0gLTE7XG4gICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgb2xkUXVldWVbaV0oKTtcbiAgICB9XG4gICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICB9XG4gIGRyYWluaW5nID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW1tZWRpYXRlO1xuZnVuY3Rpb24gaW1tZWRpYXRlKHRhc2spIHtcbiAgaWYgKHF1ZXVlLnB1c2godGFzaykgPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgc2NoZWR1bGVEcmFpbigpO1xuICB9XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7fV0sMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG52YXIgaW1tZWRpYXRlID0gX2RlcmVxXygxKTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIElOVEVSTkFMKCkge31cblxudmFyIGhhbmRsZXJzID0ge307XG5cbnZhciBSRUpFQ1RFRCA9IFsnUkVKRUNURUQnXTtcbnZhciBGVUxGSUxMRUQgPSBbJ0ZVTEZJTExFRCddO1xudmFyIFBFTkRJTkcgPSBbJ1BFTkRJTkcnXTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuXG5mdW5jdGlvbiBQcm9taXNlKHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgcmVzb2x2ZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZXNvbHZlciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB0aGlzLnN0YXRlID0gUEVORElORztcbiAgdGhpcy5xdWV1ZSA9IFtdO1xuICB0aGlzLm91dGNvbWUgPSB2b2lkIDA7XG4gIGlmIChyZXNvbHZlciAhPT0gSU5URVJOQUwpIHtcbiAgICBzYWZlbHlSZXNvbHZlVGhlbmFibGUodGhpcywgcmVzb2x2ZXIpO1xuICB9XG59XG5cblByb21pc2UucHJvdG90eXBlW1wiY2F0Y2hcIl0gPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xufTtcblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgaWYgKHR5cGVvZiBvbkZ1bGZpbGxlZCAhPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzLnN0YXRlID09PSBGVUxGSUxMRUQgfHxcbiAgICB0eXBlb2Ygb25SZWplY3RlZCAhPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzLnN0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHZhciBwcm9taXNlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoSU5URVJOQUwpO1xuICBpZiAodGhpcy5zdGF0ZSAhPT0gUEVORElORykge1xuICAgIHZhciByZXNvbHZlciA9IHRoaXMuc3RhdGUgPT09IEZVTEZJTExFRCA/IG9uRnVsZmlsbGVkIDogb25SZWplY3RlZDtcbiAgICB1bndyYXAocHJvbWlzZSwgcmVzb2x2ZXIsIHRoaXMub3V0Y29tZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5xdWV1ZS5wdXNoKG5ldyBRdWV1ZUl0ZW0ocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufTtcbmZ1bmN0aW9uIFF1ZXVlSXRlbShwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICBpZiAodHlwZW9mIG9uRnVsZmlsbGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5vbkZ1bGZpbGxlZCA9IG9uRnVsZmlsbGVkO1xuICAgIHRoaXMuY2FsbEZ1bGZpbGxlZCA9IHRoaXMub3RoZXJDYWxsRnVsZmlsbGVkO1xuICB9XG4gIGlmICh0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMub25SZWplY3RlZCA9IG9uUmVqZWN0ZWQ7XG4gICAgdGhpcy5jYWxsUmVqZWN0ZWQgPSB0aGlzLm90aGVyQ2FsbFJlamVjdGVkO1xuICB9XG59XG5RdWV1ZUl0ZW0ucHJvdG90eXBlLmNhbGxGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaGFuZGxlcnMucmVzb2x2ZSh0aGlzLnByb21pc2UsIHZhbHVlKTtcbn07XG5RdWV1ZUl0ZW0ucHJvdG90eXBlLm90aGVyQ2FsbEZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB1bndyYXAodGhpcy5wcm9taXNlLCB0aGlzLm9uRnVsZmlsbGVkLCB2YWx1ZSk7XG59O1xuUXVldWVJdGVtLnByb3RvdHlwZS5jYWxsUmVqZWN0ZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaGFuZGxlcnMucmVqZWN0KHRoaXMucHJvbWlzZSwgdmFsdWUpO1xufTtcblF1ZXVlSXRlbS5wcm90b3R5cGUub3RoZXJDYWxsUmVqZWN0ZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdW53cmFwKHRoaXMucHJvbWlzZSwgdGhpcy5vblJlamVjdGVkLCB2YWx1ZSk7XG59O1xuXG5mdW5jdGlvbiB1bndyYXAocHJvbWlzZSwgZnVuYywgdmFsdWUpIHtcbiAgaW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmV0dXJuVmFsdWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVyblZhbHVlID0gZnVuYyh2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGhhbmRsZXJzLnJlamVjdChwcm9taXNlLCBlKTtcbiAgICB9XG4gICAgaWYgKHJldHVyblZhbHVlID09PSBwcm9taXNlKSB7XG4gICAgICBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgbmV3IFR5cGVFcnJvcignQ2Fubm90IHJlc29sdmUgcHJvbWlzZSB3aXRoIGl0c2VsZicpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlcnMucmVzb2x2ZShwcm9taXNlLCByZXR1cm5WYWx1ZSk7XG4gICAgfVxuICB9KTtcbn1cblxuaGFuZGxlcnMucmVzb2x2ZSA9IGZ1bmN0aW9uIChzZWxmLCB2YWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2goZ2V0VGhlbiwgdmFsdWUpO1xuICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ2Vycm9yJykge1xuICAgIHJldHVybiBoYW5kbGVycy5yZWplY3Qoc2VsZiwgcmVzdWx0LnZhbHVlKTtcbiAgfVxuICB2YXIgdGhlbmFibGUgPSByZXN1bHQudmFsdWU7XG5cbiAgaWYgKHRoZW5hYmxlKSB7XG4gICAgc2FmZWx5UmVzb2x2ZVRoZW5hYmxlKHNlbGYsIHRoZW5hYmxlKTtcbiAgfSBlbHNlIHtcbiAgICBzZWxmLnN0YXRlID0gRlVMRklMTEVEO1xuICAgIHNlbGYub3V0Y29tZSA9IHZhbHVlO1xuICAgIHZhciBpID0gLTE7XG4gICAgdmFyIGxlbiA9IHNlbGYucXVldWUubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgIHNlbGYucXVldWVbaV0uY2FsbEZ1bGZpbGxlZCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZWxmO1xufTtcbmhhbmRsZXJzLnJlamVjdCA9IGZ1bmN0aW9uIChzZWxmLCBlcnJvcikge1xuICBzZWxmLnN0YXRlID0gUkVKRUNURUQ7XG4gIHNlbGYub3V0Y29tZSA9IGVycm9yO1xuICB2YXIgaSA9IC0xO1xuICB2YXIgbGVuID0gc2VsZi5xdWV1ZS5sZW5ndGg7XG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBzZWxmLnF1ZXVlW2ldLmNhbGxSZWplY3RlZChlcnJvcik7XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG5mdW5jdGlvbiBnZXRUaGVuKG9iaikge1xuICAvLyBNYWtlIHN1cmUgd2Ugb25seSBhY2Nlc3MgdGhlIGFjY2Vzc29yIG9uY2UgYXMgcmVxdWlyZWQgYnkgdGhlIHNwZWNcbiAgdmFyIHRoZW4gPSBvYmogJiYgb2JqLnRoZW47XG4gIGlmIChvYmogJiYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpICYmIHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGFwcHlUaGVuKCkge1xuICAgICAgdGhlbi5hcHBseShvYmosIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzYWZlbHlSZXNvbHZlVGhlbmFibGUoc2VsZiwgdGhlbmFibGUpIHtcbiAgLy8gRWl0aGVyIGZ1bGZpbGwsIHJlamVjdCBvciByZWplY3Qgd2l0aCBlcnJvclxuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uRXJyb3IodmFsdWUpIHtcbiAgICBpZiAoY2FsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgaGFuZGxlcnMucmVqZWN0KHNlbGYsIHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uU3VjY2Vzcyh2YWx1ZSkge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBoYW5kbGVycy5yZXNvbHZlKHNlbGYsIHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeVRvVW53cmFwKCkge1xuICAgIHRoZW5hYmxlKG9uU3VjY2Vzcywgb25FcnJvcik7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godHJ5VG9VbndyYXApO1xuICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ2Vycm9yJykge1xuICAgIG9uRXJyb3IocmVzdWx0LnZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cnlDYXRjaChmdW5jLCB2YWx1ZSkge1xuICB2YXIgb3V0ID0ge307XG4gIHRyeSB7XG4gICAgb3V0LnZhbHVlID0gZnVuYyh2YWx1ZSk7XG4gICAgb3V0LnN0YXR1cyA9ICdzdWNjZXNzJztcbiAgfSBjYXRjaCAoZSkge1xuICAgIG91dC5zdGF0dXMgPSAnZXJyb3InO1xuICAgIG91dC52YWx1ZSA9IGU7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuUHJvbWlzZS5yZXNvbHZlID0gcmVzb2x2ZTtcbmZ1bmN0aW9uIHJlc29sdmUodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgdGhpcykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaGFuZGxlcnMucmVzb2x2ZShuZXcgdGhpcyhJTlRFUk5BTCksIHZhbHVlKTtcbn1cblxuUHJvbWlzZS5yZWplY3QgPSByZWplY3Q7XG5mdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gIHZhciBwcm9taXNlID0gbmV3IHRoaXMoSU5URVJOQUwpO1xuICByZXR1cm4gaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG59XG5cblByb21pc2UuYWxsID0gYWxsO1xuZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyYWJsZSkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICByZXR1cm4gdGhpcy5yZWplY3QobmV3IFR5cGVFcnJvcignbXVzdCBiZSBhbiBhcnJheScpKTtcbiAgfVxuXG4gIHZhciBsZW4gPSBpdGVyYWJsZS5sZW5ndGg7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgaWYgKCFsZW4pIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlKFtdKTtcbiAgfVxuXG4gIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgdmFyIHJlc29sdmVkID0gMDtcbiAgdmFyIGkgPSAtMTtcbiAgdmFyIHByb21pc2UgPSBuZXcgdGhpcyhJTlRFUk5BTCk7XG5cbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIGFsbFJlc29sdmVyKGl0ZXJhYmxlW2ldLCBpKTtcbiAgfVxuICByZXR1cm4gcHJvbWlzZTtcbiAgZnVuY3Rpb24gYWxsUmVzb2x2ZXIodmFsdWUsIGkpIHtcbiAgICBzZWxmLnJlc29sdmUodmFsdWUpLnRoZW4ocmVzb2x2ZUZyb21BbGwsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiByZXNvbHZlRnJvbUFsbChvdXRWYWx1ZSkge1xuICAgICAgdmFsdWVzW2ldID0gb3V0VmFsdWU7XG4gICAgICBpZiAoKytyZXNvbHZlZCA9PT0gbGVuICYmICFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaGFuZGxlcnMucmVzb2x2ZShwcm9taXNlLCB2YWx1ZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5Qcm9taXNlLnJhY2UgPSByYWNlO1xuZnVuY3Rpb24gcmFjZShpdGVyYWJsZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcmFibGUpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgcmV0dXJuIHRoaXMucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ211c3QgYmUgYW4gYXJyYXknKSk7XG4gIH1cblxuICB2YXIgbGVuID0gaXRlcmFibGUubGVuZ3RoO1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIGlmICghbGVuKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZShbXSk7XG4gIH1cblxuICB2YXIgaSA9IC0xO1xuICB2YXIgcHJvbWlzZSA9IG5ldyB0aGlzKElOVEVSTkFMKTtcblxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgcmVzb2x2ZXIoaXRlcmFibGVbaV0pO1xuICB9XG4gIHJldHVybiBwcm9taXNlO1xuICBmdW5jdGlvbiByZXNvbHZlcih2YWx1ZSkge1xuICAgIHNlbGYucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGhhbmRsZXJzLnJlc29sdmUocHJvbWlzZSwgcmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG59LHtcIjFcIjoxfV0sMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5pZiAodHlwZW9mIGdsb2JhbC5Qcm9taXNlICE9PSAnZnVuY3Rpb24nKSB7XG4gIGdsb2JhbC5Qcm9taXNlID0gX2RlcmVxXygyKTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIjJcIjoyfV0sNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gZ2V0SURCKCkge1xuICAgIC8qIGdsb2JhbCBpbmRleGVkREIsd2Via2l0SW5kZXhlZERCLG1vekluZGV4ZWREQixPSW5kZXhlZERCLG1zSW5kZXhlZERCICovXG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbmRleGVkREIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXhlZERCO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2Via2l0SW5kZXhlZERCICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHdlYmtpdEluZGV4ZWREQjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG1vekluZGV4ZWREQiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBtb3pJbmRleGVkREI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBPSW5kZXhlZERCICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIE9JbmRleGVkREI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBtc0luZGV4ZWREQiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBtc0luZGV4ZWREQjtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbn1cblxudmFyIGlkYiA9IGdldElEQigpO1xuXG5mdW5jdGlvbiBpc0luZGV4ZWREQlZhbGlkKCkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEluaXRpYWxpemUgSW5kZXhlZERCOyBmYWxsIGJhY2sgdG8gdmVuZG9yLXByZWZpeGVkIHZlcnNpb25zXG4gICAgICAgIC8vIGlmIG5lZWRlZC5cbiAgICAgICAgaWYgKCFpZGIgfHwgIWlkYi5vcGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgbWltaWMgUG91Y2hEQiBoZXJlO1xuICAgICAgICAvL1xuICAgICAgICAvLyBXZSB0ZXN0IGZvciBvcGVuRGF0YWJhc2UgYmVjYXVzZSBJRSBNb2JpbGUgaWRlbnRpZmllcyBpdHNlbGZcbiAgICAgICAgLy8gYXMgU2FmYXJpLiBPaCB0aGUgbHVsei4uLlxuICAgICAgICB2YXIgaXNTYWZhcmkgPSB0eXBlb2Ygb3BlbkRhdGFiYXNlICE9PSAndW5kZWZpbmVkJyAmJiAvKFNhZmFyaXxpUGhvbmV8aVBhZHxpUG9kKS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhL0Nocm9tZS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhL0JsYWNrQmVycnkvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcblxuICAgICAgICB2YXIgaGFzRmV0Y2ggPSB0eXBlb2YgZmV0Y2ggPT09ICdmdW5jdGlvbicgJiYgZmV0Y2gudG9TdHJpbmcoKS5pbmRleE9mKCdbbmF0aXZlIGNvZGUnKSAhPT0gLTE7XG5cbiAgICAgICAgLy8gU2FmYXJpIDwxMC4xIGRvZXMgbm90IG1lZXQgb3VyIHJlcXVpcmVtZW50cyBmb3IgSURCIHN1cHBvcnRcbiAgICAgICAgLy8gKHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3BvdWNoZGIvcG91Y2hkYi9pc3N1ZXMvNTU3MikuXG4gICAgICAgIC8vIFNhZmFyaSAxMC4xIHNoaXBwZWQgd2l0aCBmZXRjaCwgd2UgY2FuIHVzZSB0aGF0IHRvIGRldGVjdCBpdC5cbiAgICAgICAgLy8gTm90ZTogdGhpcyBjcmVhdGVzIGlzc3VlcyB3aXRoIGB3aW5kb3cuZmV0Y2hgIHBvbHlmaWxscyBhbmRcbiAgICAgICAgLy8gb3ZlcnJpZGVzOyBzZWU6XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2NhbEZvcmFnZS9sb2NhbEZvcmFnZS9pc3N1ZXMvODU2XG4gICAgICAgIHJldHVybiAoIWlzU2FmYXJpIHx8IGhhc0ZldGNoKSAmJiB0eXBlb2YgaW5kZXhlZERCICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAvLyBzb21lIG91dGRhdGVkIGltcGxlbWVudGF0aW9ucyBvZiBJREIgdGhhdCBhcHBlYXIgb24gU2Ftc3VuZ1xuICAgICAgICAvLyBhbmQgSFRDIEFuZHJvaWQgZGV2aWNlcyA8NC40IGFyZSBtaXNzaW5nIElEQktleVJhbmdlXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvbG9jYWxGb3JhZ2UvaXNzdWVzLzEyOFxuICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL2xvY2FsRm9yYWdlL2lzc3Vlcy8yNzJcbiAgICAgICAgdHlwZW9mIElEQktleVJhbmdlICE9PSAndW5kZWZpbmVkJztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8vIEFic3RyYWN0cyBjb25zdHJ1Y3RpbmcgYSBCbG9iIG9iamVjdCwgc28gaXQgYWxzbyB3b3JrcyBpbiBvbGRlclxuLy8gYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHRoZSBuYXRpdmUgQmxvYiBjb25zdHJ1Y3Rvci4gKGkuZS5cbi8vIG9sZCBRdFdlYktpdCB2ZXJzaW9ucywgYXQgbGVhc3QpLlxuLy8gQWJzdHJhY3RzIGNvbnN0cnVjdGluZyBhIEJsb2Igb2JqZWN0LCBzbyBpdCBhbHNvIHdvcmtzIGluIG9sZGVyXG4vLyBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgdGhlIG5hdGl2ZSBCbG9iIGNvbnN0cnVjdG9yLiAoaS5lLlxuLy8gb2xkIFF0V2ViS2l0IHZlcnNpb25zLCBhdCBsZWFzdCkuXG5mdW5jdGlvbiBjcmVhdGVCbG9iKHBhcnRzLCBwcm9wZXJ0aWVzKSB7XG4gICAgLyogZ2xvYmFsIEJsb2JCdWlsZGVyLE1TQmxvYkJ1aWxkZXIsTW96QmxvYkJ1aWxkZXIsV2ViS2l0QmxvYkJ1aWxkZXIgKi9cbiAgICBwYXJ0cyA9IHBhcnRzIHx8IFtdO1xuICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IHt9O1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgQmxvYihwYXJ0cywgcHJvcGVydGllcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS5uYW1lICE9PSAnVHlwZUVycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgQnVpbGRlciA9IHR5cGVvZiBCbG9iQnVpbGRlciAhPT0gJ3VuZGVmaW5lZCcgPyBCbG9iQnVpbGRlciA6IHR5cGVvZiBNU0Jsb2JCdWlsZGVyICE9PSAndW5kZWZpbmVkJyA/IE1TQmxvYkJ1aWxkZXIgOiB0eXBlb2YgTW96QmxvYkJ1aWxkZXIgIT09ICd1bmRlZmluZWQnID8gTW96QmxvYkJ1aWxkZXIgOiBXZWJLaXRCbG9iQnVpbGRlcjtcbiAgICAgICAgdmFyIGJ1aWxkZXIgPSBuZXcgQnVpbGRlcigpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBidWlsZGVyLmFwcGVuZChwYXJ0c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZ2V0QmxvYihwcm9wZXJ0aWVzLnR5cGUpO1xuICAgIH1cbn1cblxuLy8gVGhpcyBpcyBDb21tb25KUyBiZWNhdXNlIGxpZSBpcyBhbiBleHRlcm5hbCBkZXBlbmRlbmN5LCBzbyBSb2xsdXBcbi8vIGNhbiBqdXN0IGlnbm9yZSBpdC5cbmlmICh0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBJbiB0aGUgXCJub3Byb21pc2VzXCIgYnVpbGQgdGhpcyB3aWxsIGp1c3QgdGhyb3cgaWYgeW91IGRvbid0IGhhdmVcbiAgICAvLyBhIGdsb2JhbCBwcm9taXNlIG9iamVjdCwgYnV0IGl0IHdvdWxkIHRocm93IGFueXdheSBsYXRlci5cbiAgICBfZGVyZXFfKDMpO1xufVxudmFyIFByb21pc2UkMSA9IFByb21pc2U7XG5cbmZ1bmN0aW9uIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjaykge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZXhlY3V0ZVR3b0NhbGxiYWNrcyhwcm9taXNlLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJvbWlzZS50aGVuKGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGVycm9yQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJvbWlzZVtcImNhdGNoXCJdKGVycm9yQ2FsbGJhY2spO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplS2V5KGtleSkge1xuICAgIC8vIENhc3QgdGhlIGtleSB0byBhIHN0cmluZywgYXMgdGhhdCdzIGFsbCB3ZSBjYW4gc2V0IGFzIGEga2V5LlxuICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zb2xlLndhcm4oa2V5ICsgJyB1c2VkIGFzIGEga2V5LCBidXQgaXQgaXMgbm90IGEgc3RyaW5nLicpO1xuICAgICAgICBrZXkgPSBTdHJpbmcoa2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5O1xufVxuXG5mdW5jdGlvbiBnZXRDYWxsYmFjaygpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAmJiB0eXBlb2YgYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICB9XG59XG5cbi8vIFNvbWUgY29kZSBvcmlnaW5hbGx5IGZyb20gYXN5bmNfc3RvcmFnZS5qcyBpblxuLy8gW0dhaWFdKGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhLWIyZy9nYWlhKS5cblxudmFyIERFVEVDVF9CTE9CX1NVUFBPUlRfU1RPUkUgPSAnbG9jYWwtZm9yYWdlLWRldGVjdC1ibG9iLXN1cHBvcnQnO1xudmFyIHN1cHBvcnRzQmxvYnMgPSB2b2lkIDA7XG52YXIgZGJDb250ZXh0cyA9IHt9O1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLy8gVHJhbnNhY3Rpb24gTW9kZXNcbnZhciBSRUFEX09OTFkgPSAncmVhZG9ubHknO1xudmFyIFJFQURfV1JJVEUgPSAncmVhZHdyaXRlJztcblxuLy8gVHJhbnNmb3JtIGEgYmluYXJ5IHN0cmluZyB0byBhbiBhcnJheSBidWZmZXIsIGJlY2F1c2Ugb3RoZXJ3aXNlXG4vLyB3ZWlyZCBzdHVmZiBoYXBwZW5zIHdoZW4geW91IHRyeSB0byB3b3JrIHdpdGggdGhlIGJpbmFyeSBzdHJpbmcgZGlyZWN0bHkuXG4vLyBJdCBpcyBrbm93bi5cbi8vIEZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNDk2NzY0Ny8gKGNvbnRpbnVlcyBvbiBuZXh0IGxpbmUpXG4vLyBlbmNvZGUtZGVjb2RlLWltYWdlLXdpdGgtYmFzZTY0LWJyZWFrcy1pbWFnZSAoMjAxMy0wNC0yMSlcbmZ1bmN0aW9uIF9iaW5TdHJpbmdUb0FycmF5QnVmZmVyKGJpbikge1xuICAgIHZhciBsZW5ndGggPSBiaW4ubGVuZ3RoO1xuICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIobGVuZ3RoKTtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGJpbi5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xufVxuXG4vL1xuLy8gQmxvYnMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gYWxsIHZlcnNpb25zIG9mIEluZGV4ZWREQiwgbm90YWJseVxuLy8gQ2hyb21lIDwzNyBhbmQgQW5kcm9pZCA8NS4gSW4gdGhvc2UgdmVyc2lvbnMsIHN0b3JpbmcgYSBibG9iIHdpbGwgdGhyb3cuXG4vL1xuLy8gVmFyaW91cyBvdGhlciBibG9iIGJ1Z3MgZXhpc3QgaW4gQ2hyb21lIHYzNy00MiAoaW5jbHVzaXZlKS5cbi8vIERldGVjdGluZyB0aGVtIGlzIGV4cGVuc2l2ZSBhbmQgY29uZnVzaW5nIHRvIHVzZXJzLCBhbmQgQ2hyb21lIDM3LTQyXG4vLyBpcyBhdCB2ZXJ5IGxvdyB1c2FnZSB3b3JsZHdpZGUsIHNvIHdlIGRvIGEgaGFja3kgdXNlckFnZW50IGNoZWNrIGluc3RlYWQuXG4vL1xuLy8gY29udGVudC10eXBlIGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQwODEyMFxuLy8gNDA0IGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0NzkxNlxuLy8gRmlsZVJlYWRlciBidWc6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDc4MzZcbi8vXG4vLyBDb2RlIGJvcnJvd2VkIGZyb20gUG91Y2hEQi4gU2VlOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvdWNoZGIvcG91Y2hkYi9ibG9iL21hc3Rlci9wYWNrYWdlcy9ub2RlX21vZHVsZXMvcG91Y2hkYi1hZGFwdGVyLWlkYi9zcmMvYmxvYlN1cHBvcnQuanNcbi8vXG5mdW5jdGlvbiBfY2hlY2tCbG9iU3VwcG9ydFdpdGhvdXRDYWNoaW5nKGlkYikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHZhciB0eG4gPSBpZGIudHJhbnNhY3Rpb24oREVURUNUX0JMT0JfU1VQUE9SVF9TVE9SRSwgUkVBRF9XUklURSk7XG4gICAgICAgIHZhciBibG9iID0gY3JlYXRlQmxvYihbJyddKTtcbiAgICAgICAgdHhuLm9iamVjdFN0b3JlKERFVEVDVF9CTE9CX1NVUFBPUlRfU1RPUkUpLnB1dChibG9iLCAna2V5Jyk7XG5cbiAgICAgICAgdHhuLm9uYWJvcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHRyYW5zYWN0aW9uIGFib3J0cyBub3cgaXRzIGR1ZSB0byBub3QgYmVpbmcgYWJsZSB0b1xuICAgICAgICAgICAgLy8gd3JpdGUgdG8gdGhlIGRhdGFiYXNlLCBsaWtlbHkgZHVlIHRvIHRoZSBkaXNrIGJlaW5nIGZ1bGxcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0eG4ub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVkQ2hyb21lID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLyk7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlZEVkZ2UgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9FZGdlXFwvLyk7XG4gICAgICAgICAgICAvLyBNUyBFZGdlIHByZXRlbmRzIHRvIGJlIENocm9tZSA0MjpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaGg4NjkzMDElMjh2PXZzLjg1JTI5LmFzcHhcbiAgICAgICAgICAgIHJlc29sdmUobWF0Y2hlZEVkZ2UgfHwgIW1hdGNoZWRDaHJvbWUgfHwgcGFyc2VJbnQobWF0Y2hlZENocm9tZVsxXSwgMTApID49IDQzKTtcbiAgICAgICAgfTtcbiAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBlcnJvciwgc28gYXNzdW1lIHVuc3VwcG9ydGVkXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIF9jaGVja0Jsb2JTdXBwb3J0KGlkYikge1xuICAgIGlmICh0eXBlb2Ygc3VwcG9ydHNCbG9icyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlJDEucmVzb2x2ZShzdXBwb3J0c0Jsb2JzKTtcbiAgICB9XG4gICAgcmV0dXJuIF9jaGVja0Jsb2JTdXBwb3J0V2l0aG91dENhY2hpbmcoaWRiKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBzdXBwb3J0c0Jsb2JzID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBzdXBwb3J0c0Jsb2JzO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBfZGVmZXJSZWFkaW5lc3MoZGJJbmZvKSB7XG4gICAgdmFyIGRiQ29udGV4dCA9IGRiQ29udGV4dHNbZGJJbmZvLm5hbWVdO1xuXG4gICAgLy8gQ3JlYXRlIGEgZGVmZXJyZWQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBkYXRhYmFzZSBvcGVyYXRpb24uXG4gICAgdmFyIGRlZmVycmVkT3BlcmF0aW9uID0ge307XG5cbiAgICBkZWZlcnJlZE9wZXJhdGlvbi5wcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGRlZmVycmVkT3BlcmF0aW9uLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICBkZWZlcnJlZE9wZXJhdGlvbi5yZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG5cbiAgICAvLyBFbnF1ZXVlIHRoZSBkZWZlcnJlZCBvcGVyYXRpb24uXG4gICAgZGJDb250ZXh0LmRlZmVycmVkT3BlcmF0aW9ucy5wdXNoKGRlZmVycmVkT3BlcmF0aW9uKTtcblxuICAgIC8vIENoYWluIGl0cyBwcm9taXNlIHRvIHRoZSBkYXRhYmFzZSByZWFkaW5lc3MuXG4gICAgaWYgKCFkYkNvbnRleHQuZGJSZWFkeSkge1xuICAgICAgICBkYkNvbnRleHQuZGJSZWFkeSA9IGRlZmVycmVkT3BlcmF0aW9uLnByb21pc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGJDb250ZXh0LmRiUmVhZHkgPSBkYkNvbnRleHQuZGJSZWFkeS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZE9wZXJhdGlvbi5wcm9taXNlO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIF9hZHZhbmNlUmVhZGluZXNzKGRiSW5mbykge1xuICAgIHZhciBkYkNvbnRleHQgPSBkYkNvbnRleHRzW2RiSW5mby5uYW1lXTtcblxuICAgIC8vIERlcXVldWUgYSBkZWZlcnJlZCBvcGVyYXRpb24uXG4gICAgdmFyIGRlZmVycmVkT3BlcmF0aW9uID0gZGJDb250ZXh0LmRlZmVycmVkT3BlcmF0aW9ucy5wb3AoKTtcblxuICAgIC8vIFJlc29sdmUgaXRzIHByb21pc2UgKHdoaWNoIGlzIHBhcnQgb2YgdGhlIGRhdGFiYXNlIHJlYWRpbmVzc1xuICAgIC8vIGNoYWluIG9mIHByb21pc2VzKS5cbiAgICBpZiAoZGVmZXJyZWRPcGVyYXRpb24pIHtcbiAgICAgICAgZGVmZXJyZWRPcGVyYXRpb24ucmVzb2x2ZSgpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWRPcGVyYXRpb24ucHJvbWlzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIF9yZWplY3RSZWFkaW5lc3MoZGJJbmZvLCBlcnIpIHtcbiAgICB2YXIgZGJDb250ZXh0ID0gZGJDb250ZXh0c1tkYkluZm8ubmFtZV07XG5cbiAgICAvLyBEZXF1ZXVlIGEgZGVmZXJyZWQgb3BlcmF0aW9uLlxuICAgIHZhciBkZWZlcnJlZE9wZXJhdGlvbiA9IGRiQ29udGV4dC5kZWZlcnJlZE9wZXJhdGlvbnMucG9wKCk7XG5cbiAgICAvLyBSZWplY3QgaXRzIHByb21pc2UgKHdoaWNoIGlzIHBhcnQgb2YgdGhlIGRhdGFiYXNlIHJlYWRpbmVzc1xuICAgIC8vIGNoYWluIG9mIHByb21pc2VzKS5cbiAgICBpZiAoZGVmZXJyZWRPcGVyYXRpb24pIHtcbiAgICAgICAgZGVmZXJyZWRPcGVyYXRpb24ucmVqZWN0KGVycik7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZE9wZXJhdGlvbi5wcm9taXNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gX2dldENvbm5lY3Rpb24oZGJJbmZvLCB1cGdyYWRlTmVlZGVkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBkYkNvbnRleHRzW2RiSW5mby5uYW1lXSA9IGRiQ29udGV4dHNbZGJJbmZvLm5hbWVdIHx8IGNyZWF0ZURiQ29udGV4dCgpO1xuXG4gICAgICAgIGlmIChkYkluZm8uZGIpIHtcbiAgICAgICAgICAgIGlmICh1cGdyYWRlTmVlZGVkKSB7XG4gICAgICAgICAgICAgICAgX2RlZmVyUmVhZGluZXNzKGRiSW5mbyk7XG4gICAgICAgICAgICAgICAgZGJJbmZvLmRiLmNsb3NlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGRiSW5mby5kYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGJBcmdzID0gW2RiSW5mby5uYW1lXTtcblxuICAgICAgICBpZiAodXBncmFkZU5lZWRlZCkge1xuICAgICAgICAgICAgZGJBcmdzLnB1c2goZGJJbmZvLnZlcnNpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9wZW5yZXEgPSBpZGIub3Blbi5hcHBseShpZGIsIGRiQXJncyk7XG5cbiAgICAgICAgaWYgKHVwZ3JhZGVOZWVkZWQpIHtcbiAgICAgICAgICAgIG9wZW5yZXEub251cGdyYWRlbmVlZGVkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGIgPSBvcGVucmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShkYkluZm8uc3RvcmVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUub2xkVmVyc2lvbiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGRlZCB3aGVuIHN1cHBvcnQgZm9yIGJsb2Igc2hpbXMgd2FzIGFkZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShERVRFQ1RfQkxPQl9TVVBQT1JUX1NUT1JFKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleC5uYW1lID09PSAnQ29uc3RyYWludEVycm9yJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGUgZGF0YWJhc2UgXCInICsgZGJJbmZvLm5hbWUgKyAnXCInICsgJyBoYXMgYmVlbiB1cGdyYWRlZCBmcm9tIHZlcnNpb24gJyArIGUub2xkVmVyc2lvbiArICcgdG8gdmVyc2lvbiAnICsgZS5uZXdWZXJzaW9uICsgJywgYnV0IHRoZSBzdG9yYWdlIFwiJyArIGRiSW5mby5zdG9yZU5hbWUgKyAnXCIgYWxyZWFkeSBleGlzdHMuJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBvcGVucmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmVqZWN0KG9wZW5yZXEuZXJyb3IpO1xuICAgICAgICB9O1xuXG4gICAgICAgIG9wZW5yZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRiID0gb3BlbnJlcS5yZXN1bHQ7XG4gICAgICAgICAgICBkYi5vbnZlcnNpb25jaGFuZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIC8vIFRyaWdnZXJlZCB3aGVuIHRoZSBkYXRhYmFzZSBpcyBtb2RpZmllZCAoZS5nLiBhZGRpbmcgYW4gb2JqZWN0U3RvcmUpIG9yXG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlZCAoZXZlbiB3aGVuIGluaXRpYXRlZCBieSBvdGhlciBzZXNzaW9ucyBpbiBkaWZmZXJlbnQgdGFicykuXG4gICAgICAgICAgICAgICAgLy8gQ2xvc2luZyB0aGUgY29ubmVjdGlvbiBoZXJlIHByZXZlbnRzIHRob3NlIG9wZXJhdGlvbnMgZnJvbSBiZWluZyBibG9ja2VkLlxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkYXRhYmFzZSBpcyBhY2Nlc3NlZCBhZ2FpbiBsYXRlciBieSB0aGlzIGluc3RhbmNlLCB0aGUgY29ubmVjdGlvblxuICAgICAgICAgICAgICAgIC8vIHdpbGwgYmUgcmVvcGVuZWQgb3IgdGhlIGRhdGFiYXNlIHJlY3JlYXRlZCBhcyBuZWVkZWQuXG4gICAgICAgICAgICAgICAgZS50YXJnZXQuY2xvc2UoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXNvbHZlKGRiKTtcbiAgICAgICAgICAgIF9hZHZhbmNlUmVhZGluZXNzKGRiSW5mbyk7XG4gICAgICAgIH07XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIF9nZXRPcmlnaW5hbENvbm5lY3Rpb24oZGJJbmZvKSB7XG4gICAgcmV0dXJuIF9nZXRDb25uZWN0aW9uKGRiSW5mbywgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBfZ2V0VXBncmFkZWRDb25uZWN0aW9uKGRiSW5mbykge1xuICAgIHJldHVybiBfZ2V0Q29ubmVjdGlvbihkYkluZm8sIHRydWUpO1xufVxuXG5mdW5jdGlvbiBfaXNVcGdyYWRlTmVlZGVkKGRiSW5mbywgZGVmYXVsdFZlcnNpb24pIHtcbiAgICBpZiAoIWRiSW5mby5kYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNOZXdTdG9yZSA9ICFkYkluZm8uZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyhkYkluZm8uc3RvcmVOYW1lKTtcbiAgICB2YXIgaXNEb3duZ3JhZGUgPSBkYkluZm8udmVyc2lvbiA8IGRiSW5mby5kYi52ZXJzaW9uO1xuICAgIHZhciBpc1VwZ3JhZGUgPSBkYkluZm8udmVyc2lvbiA+IGRiSW5mby5kYi52ZXJzaW9uO1xuXG4gICAgaWYgKGlzRG93bmdyYWRlKSB7XG4gICAgICAgIC8vIElmIHRoZSB2ZXJzaW9uIGlzIG5vdCB0aGUgZGVmYXVsdCBvbmVcbiAgICAgICAgLy8gdGhlbiB3YXJuIGZvciBpbXBvc3NpYmxlIGRvd25ncmFkZS5cbiAgICAgICAgaWYgKGRiSW5mby52ZXJzaW9uICE9PSBkZWZhdWx0VmVyc2lvbikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGUgZGF0YWJhc2UgXCInICsgZGJJbmZvLm5hbWUgKyAnXCInICsgXCIgY2FuJ3QgYmUgZG93bmdyYWRlZCBmcm9tIHZlcnNpb24gXCIgKyBkYkluZm8uZGIudmVyc2lvbiArICcgdG8gdmVyc2lvbiAnICsgZGJJbmZvLnZlcnNpb24gKyAnLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsaWduIHRoZSB2ZXJzaW9ucyB0byBwcmV2ZW50IGVycm9ycy5cbiAgICAgICAgZGJJbmZvLnZlcnNpb24gPSBkYkluZm8uZGIudmVyc2lvbjtcbiAgICB9XG5cbiAgICBpZiAoaXNVcGdyYWRlIHx8IGlzTmV3U3RvcmUpIHtcbiAgICAgICAgLy8gSWYgdGhlIHN0b3JlIGlzIG5ldyB0aGVuIGluY3JlbWVudCB0aGUgdmVyc2lvbiAoaWYgbmVlZGVkKS5cbiAgICAgICAgLy8gVGhpcyB3aWxsIHRyaWdnZXIgYW4gXCJ1cGdyYWRlbmVlZGVkXCIgZXZlbnQgd2hpY2ggaXMgcmVxdWlyZWRcbiAgICAgICAgLy8gZm9yIGNyZWF0aW5nIGEgc3RvcmUuXG4gICAgICAgIGlmIChpc05ld1N0b3JlKSB7XG4gICAgICAgICAgICB2YXIgaW5jVmVyc2lvbiA9IGRiSW5mby5kYi52ZXJzaW9uICsgMTtcbiAgICAgICAgICAgIGlmIChpbmNWZXJzaW9uID4gZGJJbmZvLnZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICBkYkluZm8udmVyc2lvbiA9IGluY1ZlcnNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIGVuY29kZSBhIGJsb2IgZm9yIGluZGV4ZWRkYiBlbmdpbmVzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBibG9ic1xuZnVuY3Rpb24gX2VuY29kZUJsb2IoYmxvYikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIHJlYWRlci5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICByZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBiYXNlNjQgPSBidG9hKGUudGFyZ2V0LnJlc3VsdCB8fCAnJyk7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBfX2xvY2FsX2ZvcmFnZV9lbmNvZGVkX2Jsb2I6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YTogYmFzZTY0LFxuICAgICAgICAgICAgICAgIHR5cGU6IGJsb2IudHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5yZWFkQXNCaW5hcnlTdHJpbmcoYmxvYik7XG4gICAgfSk7XG59XG5cbi8vIGRlY29kZSBhbiBlbmNvZGVkIGJsb2JcbmZ1bmN0aW9uIF9kZWNvZGVCbG9iKGVuY29kZWRCbG9iKSB7XG4gICAgdmFyIGFycmF5QnVmZiA9IF9iaW5TdHJpbmdUb0FycmF5QnVmZmVyKGF0b2IoZW5jb2RlZEJsb2IuZGF0YSkpO1xuICAgIHJldHVybiBjcmVhdGVCbG9iKFthcnJheUJ1ZmZdLCB7IHR5cGU6IGVuY29kZWRCbG9iLnR5cGUgfSk7XG59XG5cbi8vIGlzIHRoaXMgb25lIG9mIG91ciBmYW5jeSBlbmNvZGVkIGJsb2JzP1xuZnVuY3Rpb24gX2lzRW5jb2RlZEJsb2IodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUuX19sb2NhbF9mb3JhZ2VfZW5jb2RlZF9ibG9iO1xufVxuXG4vLyBTcGVjaWFsaXplIHRoZSBkZWZhdWx0IGByZWFkeSgpYCBmdW5jdGlvbiBieSBtYWtpbmcgaXQgZGVwZW5kZW50XG4vLyBvbiB0aGUgY3VycmVudCBkYXRhYmFzZSBvcGVyYXRpb25zLiBUaHVzLCB0aGUgZHJpdmVyIHdpbGwgYmUgYWN0dWFsbHlcbi8vIHJlYWR5IHdoZW4gaXQncyBiZWVuIGluaXRpYWxpemVkIChkZWZhdWx0KSAqYW5kKiB0aGVyZSBhcmUgbm8gcGVuZGluZ1xuLy8gb3BlcmF0aW9ucyBvbiB0aGUgZGF0YWJhc2UgKGluaXRpYXRlZCBieSBzb21lIG90aGVyIGluc3RhbmNlcykuXG5mdW5jdGlvbiBfZnVsbHlSZWFkeShjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwcm9taXNlID0gc2VsZi5faW5pdFJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYkNvbnRleHQgPSBkYkNvbnRleHRzW3NlbGYuX2RiSW5mby5uYW1lXTtcblxuICAgICAgICBpZiAoZGJDb250ZXh0ICYmIGRiQ29udGV4dC5kYlJlYWR5KSB7XG4gICAgICAgICAgICByZXR1cm4gZGJDb250ZXh0LmRiUmVhZHk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGV4ZWN1dGVUd29DYWxsYmFja3MocHJvbWlzZSwgY2FsbGJhY2ssIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLy8gVHJ5IHRvIGVzdGFibGlzaCBhIG5ldyBkYiBjb25uZWN0aW9uIHRvIHJlcGxhY2UgdGhlXG4vLyBjdXJyZW50IG9uZSB3aGljaCBpcyBicm9rZW4gKGkuZS4gZXhwZXJpZW5jaW5nXG4vLyBJbnZhbGlkU3RhdGVFcnJvciB3aGlsZSBjcmVhdGluZyBhIHRyYW5zYWN0aW9uKS5cbmZ1bmN0aW9uIF90cnlSZWNvbm5lY3QoZGJJbmZvKSB7XG4gICAgX2RlZmVyUmVhZGluZXNzKGRiSW5mbyk7XG5cbiAgICB2YXIgZGJDb250ZXh0ID0gZGJDb250ZXh0c1tkYkluZm8ubmFtZV07XG4gICAgdmFyIGZvcmFnZXMgPSBkYkNvbnRleHQuZm9yYWdlcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9yYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZm9yYWdlID0gZm9yYWdlc1tpXTtcbiAgICAgICAgaWYgKGZvcmFnZS5fZGJJbmZvLmRiKSB7XG4gICAgICAgICAgICBmb3JhZ2UuX2RiSW5mby5kYi5jbG9zZSgpO1xuICAgICAgICAgICAgZm9yYWdlLl9kYkluZm8uZGIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRiSW5mby5kYiA9IG51bGw7XG5cbiAgICByZXR1cm4gX2dldE9yaWdpbmFsQ29ubmVjdGlvbihkYkluZm8pLnRoZW4oZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgIGRiSW5mby5kYiA9IGRiO1xuICAgICAgICBpZiAoX2lzVXBncmFkZU5lZWRlZChkYkluZm8pKSB7XG4gICAgICAgICAgICAvLyBSZW9wZW4gdGhlIGRhdGFiYXNlIGZvciB1cGdyYWRpbmcuXG4gICAgICAgICAgICByZXR1cm4gX2dldFVwZ3JhZGVkQ29ubmVjdGlvbihkYkluZm8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYjtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChkYikge1xuICAgICAgICAvLyBzdG9yZSB0aGUgbGF0ZXN0IGRiIHJlZmVyZW5jZVxuICAgICAgICAvLyBpbiBjYXNlIHRoZSBkYiB3YXMgdXBncmFkZWRcbiAgICAgICAgZGJJbmZvLmRiID0gZGJDb250ZXh0LmRiID0gZGI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9yYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yYWdlc1tpXS5fZGJJbmZvLmRiID0gZGI7XG4gICAgICAgIH1cbiAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgX3JlamVjdFJlYWRpbmVzcyhkYkluZm8sIGVycik7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbn1cblxuLy8gRkYgZG9lc24ndCBsaWtlIFByb21pc2VzIChtaWNyby10YXNrcykgYW5kIElEREIgc3RvcmUgb3BlcmF0aW9ucyxcbi8vIHNvIHdlIGhhdmUgdG8gZG8gaXQgd2l0aCBjYWxsYmFja3NcbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zYWN0aW9uKGRiSW5mbywgbW9kZSwgY2FsbGJhY2ssIHJldHJpZXMpIHtcbiAgICBpZiAocmV0cmllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHJpZXMgPSAxO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHZhciB0eCA9IGRiSW5mby5kYi50cmFuc2FjdGlvbihkYkluZm8uc3RvcmVOYW1lLCBtb2RlKTtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgdHgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAocmV0cmllcyA+IDAgJiYgKCFkYkluZm8uZGIgfHwgZXJyLm5hbWUgPT09ICdJbnZhbGlkU3RhdGVFcnJvcicgfHwgZXJyLm5hbWUgPT09ICdOb3RGb3VuZEVycm9yJykpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlJDEucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghZGJJbmZvLmRiIHx8IGVyci5uYW1lID09PSAnTm90Rm91bmRFcnJvcicgJiYgIWRiSW5mby5kYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKGRiSW5mby5zdG9yZU5hbWUpICYmIGRiSW5mby52ZXJzaW9uIDw9IGRiSW5mby5kYi52ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluY3JlYXNlIHRoZSBkYiB2ZXJzaW9uLCB0byBjcmVhdGUgdGhlIG5ldyBPYmplY3RTdG9yZVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGJJbmZvLmRiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYkluZm8udmVyc2lvbiA9IGRiSW5mby5kYi52ZXJzaW9uICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZW9wZW4gdGhlIGRhdGFiYXNlIGZvciB1cGdyYWRpbmcuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0VXBncmFkZWRDb25uZWN0aW9uKGRiSW5mbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90cnlSZWNvbm5lY3QoZGJJbmZvKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlVHJhbnNhY3Rpb24oZGJJbmZvLCBtb2RlLCBjYWxsYmFjaywgcmV0cmllcyAtIDEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlbXCJjYXRjaFwiXShjYWxsYmFjayk7XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRGJDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vIFJ1bm5pbmcgbG9jYWxGb3JhZ2VzIHNoYXJpbmcgYSBkYXRhYmFzZS5cbiAgICAgICAgZm9yYWdlczogW10sXG4gICAgICAgIC8vIFNoYXJlZCBkYXRhYmFzZS5cbiAgICAgICAgZGI6IG51bGwsXG4gICAgICAgIC8vIERhdGFiYXNlIHJlYWRpbmVzcyAocHJvbWlzZSkuXG4gICAgICAgIGRiUmVhZHk6IG51bGwsXG4gICAgICAgIC8vIERlZmVycmVkIG9wZXJhdGlvbnMgb24gdGhlIGRhdGFiYXNlLlxuICAgICAgICBkZWZlcnJlZE9wZXJhdGlvbnM6IFtdXG4gICAgfTtcbn1cblxuLy8gT3BlbiB0aGUgSW5kZXhlZERCIGRhdGFiYXNlIChhdXRvbWF0aWNhbGx5IGNyZWF0ZXMgb25lIGlmIG9uZSBkaWRuJ3Rcbi8vIHByZXZpb3VzbHkgZXhpc3QpLCB1c2luZyBhbnkgb3B0aW9ucyBzZXQgaW4gdGhlIGNvbmZpZy5cbmZ1bmN0aW9uIF9pbml0U3RvcmFnZShvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkYkluZm8gPSB7XG4gICAgICAgIGRiOiBudWxsXG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgZGJJbmZvW2ldID0gb3B0aW9uc1tpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdldCB0aGUgY3VycmVudCBjb250ZXh0IG9mIHRoZSBkYXRhYmFzZTtcbiAgICB2YXIgZGJDb250ZXh0ID0gZGJDb250ZXh0c1tkYkluZm8ubmFtZV07XG5cbiAgICAvLyAuLi5vciBjcmVhdGUgYSBuZXcgY29udGV4dC5cbiAgICBpZiAoIWRiQ29udGV4dCkge1xuICAgICAgICBkYkNvbnRleHQgPSBjcmVhdGVEYkNvbnRleHQoKTtcbiAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIG5ldyBjb250ZXh0IGluIHRoZSBnbG9iYWwgY29udGFpbmVyLlxuICAgICAgICBkYkNvbnRleHRzW2RiSW5mby5uYW1lXSA9IGRiQ29udGV4dDtcbiAgICB9XG5cbiAgICAvLyBSZWdpc3RlciBpdHNlbGYgYXMgYSBydW5uaW5nIGxvY2FsRm9yYWdlIGluIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gICAgZGJDb250ZXh0LmZvcmFnZXMucHVzaChzZWxmKTtcblxuICAgIC8vIFJlcGxhY2UgdGhlIGRlZmF1bHQgYHJlYWR5KClgIGZ1bmN0aW9uIHdpdGggdGhlIHNwZWNpYWxpemVkIG9uZS5cbiAgICBpZiAoIXNlbGYuX2luaXRSZWFkeSkge1xuICAgICAgICBzZWxmLl9pbml0UmVhZHkgPSBzZWxmLnJlYWR5O1xuICAgICAgICBzZWxmLnJlYWR5ID0gX2Z1bGx5UmVhZHk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGFuIGFycmF5IG9mIGluaXRpYWxpemF0aW9uIHN0YXRlcyBvZiB0aGUgcmVsYXRlZCBsb2NhbEZvcmFnZXMuXG4gICAgdmFyIGluaXRQcm9taXNlcyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gaWdub3JlRXJyb3JzKCkge1xuICAgICAgICAvLyBEb24ndCBoYW5kbGUgZXJyb3JzIGhlcmUsXG4gICAgICAgIC8vIGp1c3QgbWFrZXMgc3VyZSByZWxhdGVkIGxvY2FsRm9yYWdlcyBhcmVuJ3QgcGVuZGluZy5cbiAgICAgICAgcmV0dXJuIFByb21pc2UkMS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBkYkNvbnRleHQuZm9yYWdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgZm9yYWdlID0gZGJDb250ZXh0LmZvcmFnZXNbal07XG4gICAgICAgIGlmIChmb3JhZ2UgIT09IHNlbGYpIHtcbiAgICAgICAgICAgIC8vIERvbid0IHdhaXQgZm9yIGl0c2VsZi4uLlxuICAgICAgICAgICAgaW5pdFByb21pc2VzLnB1c2goZm9yYWdlLl9pbml0UmVhZHkoKVtcImNhdGNoXCJdKGlnbm9yZUVycm9ycykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGFrZSBhIHNuYXBzaG90IG9mIHRoZSByZWxhdGVkIGxvY2FsRm9yYWdlcy5cbiAgICB2YXIgZm9yYWdlcyA9IGRiQ29udGV4dC5mb3JhZ2VzLnNsaWNlKDApO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgY29ubmVjdGlvbiBwcm9jZXNzIG9ubHkgd2hlblxuICAgIC8vIGFsbCB0aGUgcmVsYXRlZCBsb2NhbEZvcmFnZXMgYXJlbid0IHBlbmRpbmcuXG4gICAgcmV0dXJuIFByb21pc2UkMS5hbGwoaW5pdFByb21pc2VzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGJJbmZvLmRiID0gZGJDb250ZXh0LmRiO1xuICAgICAgICAvLyBHZXQgdGhlIGNvbm5lY3Rpb24gb3Igb3BlbiBhIG5ldyBvbmUgd2l0aG91dCB1cGdyYWRlLlxuICAgICAgICByZXR1cm4gX2dldE9yaWdpbmFsQ29ubmVjdGlvbihkYkluZm8pO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgIGRiSW5mby5kYiA9IGRiO1xuICAgICAgICBpZiAoX2lzVXBncmFkZU5lZWRlZChkYkluZm8sIHNlbGYuX2RlZmF1bHRDb25maWcudmVyc2lvbikpIHtcbiAgICAgICAgICAgIC8vIFJlb3BlbiB0aGUgZGF0YWJhc2UgZm9yIHVwZ3JhZGluZy5cbiAgICAgICAgICAgIHJldHVybiBfZ2V0VXBncmFkZWRDb25uZWN0aW9uKGRiSW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRiO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgIGRiSW5mby5kYiA9IGRiQ29udGV4dC5kYiA9IGRiO1xuICAgICAgICBzZWxmLl9kYkluZm8gPSBkYkluZm87XG4gICAgICAgIC8vIFNoYXJlIHRoZSBmaW5hbCBjb25uZWN0aW9uIGFtb25nc3QgcmVsYXRlZCBsb2NhbEZvcmFnZXMuXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZm9yYWdlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgdmFyIGZvcmFnZSA9IGZvcmFnZXNba107XG4gICAgICAgICAgICBpZiAoZm9yYWdlICE9PSBzZWxmKSB7XG4gICAgICAgICAgICAgICAgLy8gU2VsZiBpcyBhbHJlYWR5IHVwLXRvLWRhdGUuXG4gICAgICAgICAgICAgICAgZm9yYWdlLl9kYkluZm8uZGIgPSBkYkluZm8uZGI7XG4gICAgICAgICAgICAgICAgZm9yYWdlLl9kYkluZm8udmVyc2lvbiA9IGRiSW5mby52ZXJzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEl0ZW0oa2V5LCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY3JlYXRlVHJhbnNhY3Rpb24oc2VsZi5fZGJJbmZvLCBSRUFEX09OTFksIGZ1bmN0aW9uIChlcnIsIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc2VsZi5fZGJJbmZvLnN0b3JlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBzdG9yZS5nZXQoa2V5KTtcblxuICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0VuY29kZWRCbG9iKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX2RlY29kZUJsb2IodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QocmVxLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLy8gSXRlcmF0ZSBvdmVyIGFsbCBpdGVtcyBzdG9yZWQgaW4gZGF0YWJhc2UuXG5mdW5jdGlvbiBpdGVyYXRlKGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNyZWF0ZVRyYW5zYWN0aW9uKHNlbGYuX2RiSW5mbywgUkVBRF9PTkxZLCBmdW5jdGlvbiAoZXJyLCB0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHNlbGYuX2RiSW5mby5zdG9yZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gc3RvcmUub3BlbkN1cnNvcigpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlcmF0aW9uTnVtYmVyID0gMTtcblxuICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnNvciA9IHJlcS5yZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0VuY29kZWRCbG9iKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9kZWNvZGVCbG9iKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGl0ZXJhdG9yKHZhbHVlLCBjdXJzb3Iua2V5LCBpdGVyYXRpb25OdW1iZXIrKyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBpdGVyYXRvciBjYWxsYmFjayByZXR1cm5zIGFueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIChub24tYHVuZGVmaW5lZGApIHZhbHVlLCB0aGVuIHdlIHN0b3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgaXRlcmF0aW9uIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3JbXCJjb250aW51ZVwiXSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHJlcS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gc2V0SXRlbShrZXksIHZhbHVlLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGRiSW5mbztcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuICAgICAgICAgICAgaWYgKHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBCbG9iXScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NoZWNrQmxvYlN1cHBvcnQoZGJJbmZvLmRiKS50aGVuKGZ1bmN0aW9uIChibG9iU3VwcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmxvYlN1cHBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2VuY29kZUJsb2IodmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgY3JlYXRlVHJhbnNhY3Rpb24oc2VsZi5fZGJJbmZvLCBSRUFEX1dSSVRFLCBmdW5jdGlvbiAoZXJyLCB0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHNlbGYuX2RiSW5mby5zdG9yZU5hbWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZWFzb24gd2UgZG9uJ3QgX3NhdmVfIG51bGwgaXMgYmVjYXVzZSBJRSAxMCBkb2VzXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCBzdXBwb3J0IHNhdmluZyB0aGUgYG51bGxgIHR5cGUgaW4gSW5kZXhlZERCLiBIb3dcbiAgICAgICAgICAgICAgICAgICAgLy8gaXJvbmljLCBnaXZlbiB0aGUgYnVnIGJlbG93IVxuICAgICAgICAgICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL2xvY2FsRm9yYWdlL2lzc3Vlcy8xNjFcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBzdG9yZS5wdXQodmFsdWUsIGtleSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhc3QgdG8gdW5kZWZpbmVkIHNvIHRoZSB2YWx1ZSBwYXNzZWQgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGxiYWNrL3Byb21pc2UgaXMgdGhlIHNhbWUgYXMgd2hhdCBvbmUgd291bGQgZ2V0IG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgYGdldEl0ZW0oKWAgbGF0ZXIuIFRoaXMgbGVhZHMgdG8gc29tZSB3ZWlyZG5lc3NcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIChzZXRJdGVtKCdmb28nLCB1bmRlZmluZWQpIHdpbGwgcmV0dXJuIGBudWxsYCksIGJ1dFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBub3QgbXkgZmF1bHQgbG9jYWxTdG9yYWdlIGlzIG91ciBiYXNlbGluZSBhbmQgdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQncyB3ZWlyZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25hYm9ydCA9IHRyYW5zYWN0aW9uLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gcmVxLmVycm9yID8gcmVxLmVycm9yIDogcmVxLnRyYW5zYWN0aW9uLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUl0ZW0oa2V5LCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY3JlYXRlVHJhbnNhY3Rpb24oc2VsZi5fZGJJbmZvLCBSRUFEX1dSSVRFLCBmdW5jdGlvbiAoZXJyLCB0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHNlbGYuX2RiSW5mby5zdG9yZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSB1c2UgYSBHcnVudCB0YXNrIHRvIG1ha2UgdGhpcyBzYWZlIGZvciBJRSBhbmQgc29tZVxuICAgICAgICAgICAgICAgICAgICAvLyB2ZXJzaW9ucyBvZiBBbmRyb2lkIChpbmNsdWRpbmcgdGhvc2UgdXNlZCBieSBDb3Jkb3ZhKS5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm9ybWFsbHkgSUUgd29uJ3QgbGlrZSBgLmRlbGV0ZSgpYCBhbmQgd2lsbCBpbnNpc3Qgb25cbiAgICAgICAgICAgICAgICAgICAgLy8gdXNpbmcgYFsnZGVsZXRlJ10oKWAsIGJ1dCB3ZSBoYXZlIGEgYnVpbGQgc3RlcCB0aGF0XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpeGVzIHRoaXMgZm9yIHVzIG5vdy5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IHN0b3JlW1wiZGVsZXRlXCJdKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLm9uY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChyZXEuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXF1ZXN0IHdpbGwgYmUgYWxzbyBiZSBhYm9ydGVkIGlmIHdlJ3ZlIGV4Y2VlZGVkIG91ciBzdG9yYWdlXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwYWNlLlxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5vbmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IHJlcS5lcnJvciA/IHJlcS5lcnJvciA6IHJlcS50cmFuc2FjdGlvbi5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKHJlamVjdCk7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBjbGVhcihjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNyZWF0ZVRyYW5zYWN0aW9uKHNlbGYuX2RiSW5mbywgUkVBRF9XUklURSwgZnVuY3Rpb24gKGVyciwgdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzZWxmLl9kYkluZm8uc3RvcmVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IHN0b3JlLmNsZWFyKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5vbmFib3J0ID0gdHJhbnNhY3Rpb24ub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSByZXEuZXJyb3IgPyByZXEuZXJyb3IgOiByZXEudHJhbnNhY3Rpb24uZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gbGVuZ3RoKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY3JlYXRlVHJhbnNhY3Rpb24oc2VsZi5fZGJJbmZvLCBSRUFEX09OTFksIGZ1bmN0aW9uIChlcnIsIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc2VsZi5fZGJJbmZvLnN0b3JlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBzdG9yZS5jb3VudCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlcS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHJlcS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIGtleShuLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGlmIChuIDwgMCkge1xuICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY3JlYXRlVHJhbnNhY3Rpb24oc2VsZi5fZGJJbmZvLCBSRUFEX09OTFksIGZ1bmN0aW9uIChlcnIsIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc2VsZi5fZGJJbmZvLnN0b3JlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhZHZhbmNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gc3RvcmUub3BlbktleUN1cnNvcigpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyc29yID0gcmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGVyZSB3ZXJlbid0IGVub3VnaCBrZXlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIHRoZSBmaXJzdCBrZXksIHJldHVybiBpdCBpZiB0aGF0J3Mgd2hhdCB0aGV5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2FudGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY3Vyc29yLmtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYWR2YW5jZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBhc2sgdGhlIGN1cnNvciB0byBza2lwIGFoZWFkIG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVjb3Jkcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuYWR2YW5jZShuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHdlIGdldCBoZXJlLCB3ZSd2ZSBnb3QgdGhlIG50aCBrZXkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY3Vyc29yLmtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHJlcS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIGtleXMoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjcmVhdGVUcmFuc2FjdGlvbihzZWxmLl9kYkluZm8sIFJFQURfT05MWSwgZnVuY3Rpb24gKGVyciwgdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzZWxmLl9kYkluZm8uc3RvcmVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IHN0b3JlLm9wZW5LZXlDdXJzb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnNvciA9IHJlcS5yZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShrZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChjdXJzb3Iua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcltcImNvbnRpbnVlXCJdKCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QocmVxLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gZHJvcEluc3RhbmNlKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBnZXRDYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdmFyIGN1cnJlbnRDb25maWcgPSB0aGlzLmNvbmZpZygpO1xuICAgIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyAhPT0gJ2Z1bmN0aW9uJyAmJiBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghb3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMubmFtZSA9IG9wdGlvbnMubmFtZSB8fCBjdXJyZW50Q29uZmlnLm5hbWU7XG4gICAgICAgIG9wdGlvbnMuc3RvcmVOYW1lID0gb3B0aW9ucy5zdG9yZU5hbWUgfHwgY3VycmVudENvbmZpZy5zdG9yZU5hbWU7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwcm9taXNlO1xuICAgIGlmICghb3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIHByb21pc2UgPSBQcm9taXNlJDEucmVqZWN0KCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpc0N1cnJlbnREYiA9IG9wdGlvbnMubmFtZSA9PT0gY3VycmVudENvbmZpZy5uYW1lICYmIHNlbGYuX2RiSW5mby5kYjtcblxuICAgICAgICB2YXIgZGJQcm9taXNlID0gaXNDdXJyZW50RGIgPyBQcm9taXNlJDEucmVzb2x2ZShzZWxmLl9kYkluZm8uZGIpIDogX2dldE9yaWdpbmFsQ29ubmVjdGlvbihvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChkYikge1xuICAgICAgICAgICAgdmFyIGRiQ29udGV4dCA9IGRiQ29udGV4dHNbb3B0aW9ucy5uYW1lXTtcbiAgICAgICAgICAgIHZhciBmb3JhZ2VzID0gZGJDb250ZXh0LmZvcmFnZXM7XG4gICAgICAgICAgICBkYkNvbnRleHQuZGIgPSBkYjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9yYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvcmFnZXNbaV0uX2RiSW5mby5kYiA9IGRiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRiO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMuc3RvcmVOYW1lKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gZGJQcm9taXNlLnRoZW4oZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgICAgICAgICAgX2RlZmVyUmVhZGluZXNzKG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRiQ29udGV4dCA9IGRiQ29udGV4dHNbb3B0aW9ucy5uYW1lXTtcbiAgICAgICAgICAgICAgICB2YXIgZm9yYWdlcyA9IGRiQ29udGV4dC5mb3JhZ2VzO1xuXG4gICAgICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcmFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvcmFnZSA9IGZvcmFnZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGZvcmFnZS5fZGJJbmZvLmRiID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZHJvcERCUHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gaWRiLmRlbGV0ZURhdGFiYXNlKG9wdGlvbnMubmFtZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGIgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChyZXEuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbmJsb2NrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDbG9zaW5nIGFsbCBvcGVuIGNvbm5lY3Rpb25zIGluIG9udmVyc2lvbmNoYW5nZSBoYW5kbGVyIHNob3VsZCBwcmV2ZW50IHRoaXMgc2l0dWF0aW9uLCBidXQgaWZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvIGdldCBoZXJlLCBpdCBqdXN0IG1lYW5zIHRoZSByZXF1ZXN0IHJlbWFpbnMgcGVuZGluZyAtIGV2ZW50dWFsbHkgaXQgd2lsbCBzdWNjZWVkIG9yIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2Ryb3BJbnN0YW5jZSBibG9ja2VkIGZvciBkYXRhYmFzZSBcIicgKyBvcHRpb25zLm5hbWUgKyAnXCIgdW50aWwgYWxsIG9wZW4gY29ubmVjdGlvbnMgYXJlIGNsb3NlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGIgPSByZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRyb3BEQlByb21pc2UudGhlbihmdW5jdGlvbiAoZGIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGJDb250ZXh0LmRiID0gZGI7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9yYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9mb3JhZ2UgPSBmb3JhZ2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2FkdmFuY2VSZWFkaW5lc3MoX2ZvcmFnZS5fZGJJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAoX3JlamVjdFJlYWRpbmVzcyhvcHRpb25zLCBlcnIpIHx8IFByb21pc2UkMS5yZXNvbHZlKCkpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBkYlByb21pc2UudGhlbihmdW5jdGlvbiAoZGIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMob3B0aW9ucy5zdG9yZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbmV3VmVyc2lvbiA9IGRiLnZlcnNpb24gKyAxO1xuXG4gICAgICAgICAgICAgICAgX2RlZmVyUmVhZGluZXNzKG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRiQ29udGV4dCA9IGRiQ29udGV4dHNbb3B0aW9ucy5uYW1lXTtcbiAgICAgICAgICAgICAgICB2YXIgZm9yYWdlcyA9IGRiQ29udGV4dC5mb3JhZ2VzO1xuXG4gICAgICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcmFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvcmFnZSA9IGZvcmFnZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGZvcmFnZS5fZGJJbmZvLmRiID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZm9yYWdlLl9kYkluZm8udmVyc2lvbiA9IG5ld1ZlcnNpb247XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGRyb3BPYmplY3RQcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBpZGIub3BlbihvcHRpb25zLm5hbWUsIG5ld1ZlcnNpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRiID0gcmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICByZXEub251cGdyYWRlbmVlZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRiID0gcmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRiLmRlbGV0ZU9iamVjdFN0b3JlKG9wdGlvbnMuc3RvcmVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRiID0gcmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRiKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBkcm9wT2JqZWN0UHJvbWlzZS50aGVuKGZ1bmN0aW9uIChkYikge1xuICAgICAgICAgICAgICAgICAgICBkYkNvbnRleHQuZGIgPSBkYjtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmb3JhZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2ZvcmFnZTIgPSBmb3JhZ2VzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2ZvcmFnZTIuX2RiSW5mby5kYiA9IGRiO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2FkdmFuY2VSZWFkaW5lc3MoX2ZvcmFnZTIuX2RiSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgKF9yZWplY3RSZWFkaW5lc3Mob3B0aW9ucywgZXJyKSB8fCBQcm9taXNlJDEucmVzb2x2ZSgpKVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG52YXIgYXN5bmNTdG9yYWdlID0ge1xuICAgIF9kcml2ZXI6ICdhc3luY1N0b3JhZ2UnLFxuICAgIF9pbml0U3RvcmFnZTogX2luaXRTdG9yYWdlLFxuICAgIF9zdXBwb3J0OiBpc0luZGV4ZWREQlZhbGlkKCksXG4gICAgaXRlcmF0ZTogaXRlcmF0ZSxcbiAgICBnZXRJdGVtOiBnZXRJdGVtLFxuICAgIHNldEl0ZW06IHNldEl0ZW0sXG4gICAgcmVtb3ZlSXRlbTogcmVtb3ZlSXRlbSxcbiAgICBjbGVhcjogY2xlYXIsXG4gICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAga2V5OiBrZXksXG4gICAga2V5czoga2V5cyxcbiAgICBkcm9wSW5zdGFuY2U6IGRyb3BJbnN0YW5jZVxufTtcblxuZnVuY3Rpb24gaXNXZWJTUUxWYWxpZCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9wZW5EYXRhYmFzZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLy8gU2FkbHksIHRoZSBiZXN0IHdheSB0byBzYXZlIGJpbmFyeSBkYXRhIGluIFdlYlNRTC9sb2NhbFN0b3JhZ2UgaXMgc2VyaWFsaXppbmdcbi8vIGl0IHRvIEJhc2U2NCwgc28gdGhpcyBpcyBob3cgd2Ugc3RvcmUgaXQgdG8gcHJldmVudCB2ZXJ5IHN0cmFuZ2UgZXJyb3JzIHdpdGggbGVzc1xuLy8gdmVyYm9zZSB3YXlzIG9mIGJpbmFyeSA8LT4gc3RyaW5nIGRhdGEgc3RvcmFnZS5cbnZhciBCQVNFX0NIQVJTID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG52YXIgQkxPQl9UWVBFX1BSRUZJWCA9ICd+fmxvY2FsX2ZvcmFnZV90eXBlfic7XG52YXIgQkxPQl9UWVBFX1BSRUZJWF9SRUdFWCA9IC9efn5sb2NhbF9mb3JhZ2VfdHlwZX4oW15+XSspfi87XG5cbnZhciBTRVJJQUxJWkVEX01BUktFUiA9ICdfX2xmc2NfXzonO1xudmFyIFNFUklBTElaRURfTUFSS0VSX0xFTkdUSCA9IFNFUklBTElaRURfTUFSS0VSLmxlbmd0aDtcblxuLy8gT01HIHRoZSBzZXJpYWxpemF0aW9ucyFcbnZhciBUWVBFX0FSUkFZQlVGRkVSID0gJ2FyYmYnO1xudmFyIFRZUEVfQkxPQiA9ICdibG9iJztcbnZhciBUWVBFX0lOVDhBUlJBWSA9ICdzaTA4JztcbnZhciBUWVBFX1VJTlQ4QVJSQVkgPSAndWkwOCc7XG52YXIgVFlQRV9VSU5UOENMQU1QRURBUlJBWSA9ICd1aWM4JztcbnZhciBUWVBFX0lOVDE2QVJSQVkgPSAnc2kxNic7XG52YXIgVFlQRV9JTlQzMkFSUkFZID0gJ3NpMzInO1xudmFyIFRZUEVfVUlOVDE2QVJSQVkgPSAndXIxNic7XG52YXIgVFlQRV9VSU5UMzJBUlJBWSA9ICd1aTMyJztcbnZhciBUWVBFX0ZMT0FUMzJBUlJBWSA9ICdmbDMyJztcbnZhciBUWVBFX0ZMT0FUNjRBUlJBWSA9ICdmbDY0JztcbnZhciBUWVBFX1NFUklBTElaRURfTUFSS0VSX0xFTkdUSCA9IFNFUklBTElaRURfTUFSS0VSX0xFTkdUSCArIFRZUEVfQVJSQVlCVUZGRVIubGVuZ3RoO1xuXG52YXIgdG9TdHJpbmckMSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHN0cmluZ1RvQnVmZmVyKHNlcmlhbGl6ZWRTdHJpbmcpIHtcbiAgICAvLyBGaWxsIHRoZSBzdHJpbmcgaW50byBhIEFycmF5QnVmZmVyLlxuICAgIHZhciBidWZmZXJMZW5ndGggPSBzZXJpYWxpemVkU3RyaW5nLmxlbmd0aCAqIDAuNzU7XG4gICAgdmFyIGxlbiA9IHNlcmlhbGl6ZWRTdHJpbmcubGVuZ3RoO1xuICAgIHZhciBpO1xuICAgIHZhciBwID0gMDtcbiAgICB2YXIgZW5jb2RlZDEsIGVuY29kZWQyLCBlbmNvZGVkMywgZW5jb2RlZDQ7XG5cbiAgICBpZiAoc2VyaWFsaXplZFN0cmluZ1tzZXJpYWxpemVkU3RyaW5nLmxlbmd0aCAtIDFdID09PSAnPScpIHtcbiAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICAgIGlmIChzZXJpYWxpemVkU3RyaW5nW3NlcmlhbGl6ZWRTdHJpbmcubGVuZ3RoIC0gMl0gPT09ICc9Jykge1xuICAgICAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlckxlbmd0aCk7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICBlbmNvZGVkMSA9IEJBU0VfQ0hBUlMuaW5kZXhPZihzZXJpYWxpemVkU3RyaW5nW2ldKTtcbiAgICAgICAgZW5jb2RlZDIgPSBCQVNFX0NIQVJTLmluZGV4T2Yoc2VyaWFsaXplZFN0cmluZ1tpICsgMV0pO1xuICAgICAgICBlbmNvZGVkMyA9IEJBU0VfQ0hBUlMuaW5kZXhPZihzZXJpYWxpemVkU3RyaW5nW2kgKyAyXSk7XG4gICAgICAgIGVuY29kZWQ0ID0gQkFTRV9DSEFSUy5pbmRleE9mKHNlcmlhbGl6ZWRTdHJpbmdbaSArIDNdKTtcblxuICAgICAgICAvKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG4gICAgICAgIGJ5dGVzW3ArK10gPSBlbmNvZGVkMSA8PCAyIHwgZW5jb2RlZDIgPj4gNDtcbiAgICAgICAgYnl0ZXNbcCsrXSA9IChlbmNvZGVkMiAmIDE1KSA8PCA0IHwgZW5jb2RlZDMgPj4gMjtcbiAgICAgICAgYnl0ZXNbcCsrXSA9IChlbmNvZGVkMyAmIDMpIDw8IDYgfCBlbmNvZGVkNCAmIDYzO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xufVxuXG4vLyBDb252ZXJ0cyBhIGJ1ZmZlciB0byBhIHN0cmluZyB0byBzdG9yZSwgc2VyaWFsaXplZCwgaW4gdGhlIGJhY2tlbmRcbi8vIHN0b3JhZ2UgbGlicmFyeS5cbmZ1bmN0aW9uIGJ1ZmZlclRvU3RyaW5nKGJ1ZmZlcikge1xuICAgIC8vIGJhc2U2NC1hcnJheWJ1ZmZlclxuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgdmFyIGJhc2U2NFN0cmluZyA9ICcnO1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIC8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cbiAgICAgICAgYmFzZTY0U3RyaW5nICs9IEJBU0VfQ0hBUlNbYnl0ZXNbaV0gPj4gMl07XG4gICAgICAgIGJhc2U2NFN0cmluZyArPSBCQVNFX0NIQVJTWyhieXRlc1tpXSAmIDMpIDw8IDQgfCBieXRlc1tpICsgMV0gPj4gNF07XG4gICAgICAgIGJhc2U2NFN0cmluZyArPSBCQVNFX0NIQVJTWyhieXRlc1tpICsgMV0gJiAxNSkgPDwgMiB8IGJ5dGVzW2kgKyAyXSA+PiA2XTtcbiAgICAgICAgYmFzZTY0U3RyaW5nICs9IEJBU0VfQ0hBUlNbYnl0ZXNbaSArIDJdICYgNjNdO1xuICAgIH1cblxuICAgIGlmIChieXRlcy5sZW5ndGggJSAzID09PSAyKSB7XG4gICAgICAgIGJhc2U2NFN0cmluZyA9IGJhc2U2NFN0cmluZy5zdWJzdHJpbmcoMCwgYmFzZTY0U3RyaW5nLmxlbmd0aCAtIDEpICsgJz0nO1xuICAgIH0gZWxzZSBpZiAoYnl0ZXMubGVuZ3RoICUgMyA9PT0gMSkge1xuICAgICAgICBiYXNlNjRTdHJpbmcgPSBiYXNlNjRTdHJpbmcuc3Vic3RyaW5nKDAsIGJhc2U2NFN0cmluZy5sZW5ndGggLSAyKSArICc9PSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2U2NFN0cmluZztcbn1cblxuLy8gU2VyaWFsaXplIGEgdmFsdWUsIGFmdGVyd2FyZHMgZXhlY3V0aW5nIGEgY2FsbGJhY2sgKHdoaWNoIHVzdWFsbHlcbi8vIGluc3RydWN0cyB0aGUgYHNldEl0ZW0oKWAgY2FsbGJhY2svcHJvbWlzZSB0byBiZSBleGVjdXRlZCkuIFRoaXMgaXMgaG93XG4vLyB3ZSBzdG9yZSBiaW5hcnkgZGF0YSB3aXRoIGxvY2FsU3RvcmFnZS5cbmZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgdmFsdWVUeXBlID0gJyc7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlVHlwZSA9IHRvU3RyaW5nJDEuY2FsbCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gQ2Fubm90IHVzZSBgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcmAgb3Igc3VjaCBoZXJlLCBhcyB0aGVzZVxuICAgIC8vIGNoZWNrcyBmYWlsIHdoZW4gcnVubmluZyB0aGUgdGVzdHMgdXNpbmcgY2FzcGVyLmpzLi4uXG4gICAgLy9cbiAgICAvLyBUT0RPOiBTZWUgd2h5IHRob3NlIHRlc3RzIGZhaWwgYW5kIHVzZSBhIGJldHRlciBzb2x1dGlvbi5cbiAgICBpZiAodmFsdWUgJiYgKHZhbHVlVHlwZSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyB8fCB2YWx1ZS5idWZmZXIgJiYgdG9TdHJpbmckMS5jYWxsKHZhbHVlLmJ1ZmZlcikgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpKSB7XG4gICAgICAgIC8vIENvbnZlcnQgYmluYXJ5IGFycmF5cyB0byBhIHN0cmluZyBhbmQgcHJlZml4IHRoZSBzdHJpbmcgd2l0aFxuICAgICAgICAvLyBhIHNwZWNpYWwgbWFya2VyLlxuICAgICAgICB2YXIgYnVmZmVyO1xuICAgICAgICB2YXIgbWFya2VyID0gU0VSSUFMSVpFRF9NQVJLRVI7XG5cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIGJ1ZmZlciA9IHZhbHVlO1xuICAgICAgICAgICAgbWFya2VyICs9IFRZUEVfQVJSQVlCVUZGRVI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmZXIgPSB2YWx1ZS5idWZmZXI7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZVR5cGUgPT09ICdbb2JqZWN0IEludDhBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyICs9IFRZUEVfSU5UOEFSUkFZO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVR5cGUgPT09ICdbb2JqZWN0IFVpbnQ4QXJyYXldJykge1xuICAgICAgICAgICAgICAgIG1hcmtlciArPSBUWVBFX1VJTlQ4QVJSQVk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlVHlwZSA9PT0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJykge1xuICAgICAgICAgICAgICAgIG1hcmtlciArPSBUWVBFX1VJTlQ4Q0xBTVBFREFSUkFZO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVR5cGUgPT09ICdbb2JqZWN0IEludDE2QXJyYXldJykge1xuICAgICAgICAgICAgICAgIG1hcmtlciArPSBUWVBFX0lOVDE2QVJSQVk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlVHlwZSA9PT0gJ1tvYmplY3QgVWludDE2QXJyYXldJykge1xuICAgICAgICAgICAgICAgIG1hcmtlciArPSBUWVBFX1VJTlQxNkFSUkFZO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVR5cGUgPT09ICdbb2JqZWN0IEludDMyQXJyYXldJykge1xuICAgICAgICAgICAgICAgIG1hcmtlciArPSBUWVBFX0lOVDMyQVJSQVk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlVHlwZSA9PT0gJ1tvYmplY3QgVWludDMyQXJyYXldJykge1xuICAgICAgICAgICAgICAgIG1hcmtlciArPSBUWVBFX1VJTlQzMkFSUkFZO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVR5cGUgPT09ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyICs9IFRZUEVfRkxPQVQzMkFSUkFZO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVR5cGUgPT09ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyICs9IFRZUEVfRkxPQVQ2NEFSUkFZO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgdHlwZSBmb3IgQmluYXJ5QXJyYXknKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhtYXJrZXIgKyBidWZmZXJUb1N0cmluZyhidWZmZXIpKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlVHlwZSA9PT0gJ1tvYmplY3QgQmxvYl0nKSB7XG4gICAgICAgIC8vIENvbnZlciB0aGUgYmxvYiB0byBhIGJpbmFyeUFycmF5IGFuZCB0aGVuIHRvIGEgc3RyaW5nLlxuICAgICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBCYWNrd2FyZHMtY29tcGF0aWJsZSBwcmVmaXggZm9yIHRoZSBibG9iIHR5cGUuXG4gICAgICAgICAgICB2YXIgc3RyID0gQkxPQl9UWVBFX1BSRUZJWCArIHZhbHVlLnR5cGUgKyAnficgKyBidWZmZXJUb1N0cmluZyh0aGlzLnJlc3VsdCk7XG5cbiAgICAgICAgICAgIGNhbGxiYWNrKFNFUklBTElaRURfTUFSS0VSICsgVFlQRV9CTE9CICsgc3RyKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2FsbGJhY2soSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkNvdWxkbid0IGNvbnZlcnQgdmFsdWUgaW50byBhIEpTT04gc3RyaW5nOiBcIiwgdmFsdWUpO1xuXG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gRGVzZXJpYWxpemUgZGF0YSB3ZSd2ZSBpbnNlcnRlZCBpbnRvIGEgdmFsdWUgY29sdW1uL2ZpZWxkLiBXZSBwbGFjZVxuLy8gc3BlY2lhbCBtYXJrZXJzIGludG8gb3VyIHN0cmluZ3MgdG8gbWFyayB0aGVtIGFzIGVuY29kZWQ7IHRoaXMgaXNuJ3Rcbi8vIGFzIG5pY2UgYXMgYSBtZXRhIGZpZWxkLCBidXQgaXQncyB0aGUgb25seSBzYW5lIHRoaW5nIHdlIGNhbiBkbyB3aGlsc3Rcbi8vIGtlZXBpbmcgbG9jYWxTdG9yYWdlIHN1cHBvcnQgaW50YWN0LlxuLy9cbi8vIE9mdGVudGltZXMgdGhpcyB3aWxsIGp1c3QgZGVzZXJpYWxpemUgSlNPTiBjb250ZW50LCBidXQgaWYgd2UgaGF2ZSBhXG4vLyBzcGVjaWFsIG1hcmtlciAoU0VSSUFMSVpFRF9NQVJLRVIsIGRlZmluZWQgYWJvdmUpLCB3ZSB3aWxsIGV4dHJhY3Rcbi8vIHNvbWUga2luZCBvZiBhcnJheWJ1ZmZlci9iaW5hcnkgZGF0YS90eXBlZCBhcnJheSBvdXQgb2YgdGhlIHN0cmluZy5cbmZ1bmN0aW9uIGRlc2VyaWFsaXplKHZhbHVlKSB7XG4gICAgLy8gSWYgd2UgaGF2ZW4ndCBtYXJrZWQgdGhpcyBzdHJpbmcgYXMgYmVpbmcgc3BlY2lhbGx5IHNlcmlhbGl6ZWQgKGkuZS5cbiAgICAvLyBzb21ldGhpbmcgb3RoZXIgdGhhbiBzZXJpYWxpemVkIEpTT04pLCB3ZSBjYW4ganVzdCByZXR1cm4gaXQgYW5kIGJlXG4gICAgLy8gZG9uZSB3aXRoIGl0LlxuICAgIGlmICh2YWx1ZS5zdWJzdHJpbmcoMCwgU0VSSUFMSVpFRF9NQVJLRVJfTEVOR1RIKSAhPT0gU0VSSUFMSVpFRF9NQVJLRVIpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgIH1cblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBkZWFscyB3aXRoIGRlc2VyaWFsaXppbmcgc29tZSBraW5kIG9mIEJsb2Igb3JcbiAgICAvLyBUeXBlZEFycmF5LiBGaXJzdCB3ZSBzZXBhcmF0ZSBvdXQgdGhlIHR5cGUgb2YgZGF0YSB3ZSdyZSBkZWFsaW5nXG4gICAgLy8gd2l0aCBmcm9tIHRoZSBkYXRhIGl0c2VsZi5cbiAgICB2YXIgc2VyaWFsaXplZFN0cmluZyA9IHZhbHVlLnN1YnN0cmluZyhUWVBFX1NFUklBTElaRURfTUFSS0VSX0xFTkdUSCk7XG4gICAgdmFyIHR5cGUgPSB2YWx1ZS5zdWJzdHJpbmcoU0VSSUFMSVpFRF9NQVJLRVJfTEVOR1RILCBUWVBFX1NFUklBTElaRURfTUFSS0VSX0xFTkdUSCk7XG5cbiAgICB2YXIgYmxvYlR5cGU7XG4gICAgLy8gQmFja3dhcmRzLWNvbXBhdGlibGUgYmxvYiB0eXBlIHNlcmlhbGl6YXRpb24gc3RyYXRlZ3kuXG4gICAgLy8gREJzIGNyZWF0ZWQgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBsb2NhbEZvcmFnZSB3aWxsIHNpbXBseSBub3QgaGF2ZSB0aGUgYmxvYiB0eXBlLlxuICAgIGlmICh0eXBlID09PSBUWVBFX0JMT0IgJiYgQkxPQl9UWVBFX1BSRUZJWF9SRUdFWC50ZXN0KHNlcmlhbGl6ZWRTdHJpbmcpKSB7XG4gICAgICAgIHZhciBtYXRjaGVyID0gc2VyaWFsaXplZFN0cmluZy5tYXRjaChCTE9CX1RZUEVfUFJFRklYX1JFR0VYKTtcbiAgICAgICAgYmxvYlR5cGUgPSBtYXRjaGVyWzFdO1xuICAgICAgICBzZXJpYWxpemVkU3RyaW5nID0gc2VyaWFsaXplZFN0cmluZy5zdWJzdHJpbmcobWF0Y2hlclswXS5sZW5ndGgpO1xuICAgIH1cbiAgICB2YXIgYnVmZmVyID0gc3RyaW5nVG9CdWZmZXIoc2VyaWFsaXplZFN0cmluZyk7XG5cbiAgICAvLyBSZXR1cm4gdGhlIHJpZ2h0IHR5cGUgYmFzZWQgb24gdGhlIGNvZGUvdHlwZSBzZXQgZHVyaW5nXG4gICAgLy8gc2VyaWFsaXphdGlvbi5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBUWVBFX0FSUkFZQlVGRkVSOlxuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgY2FzZSBUWVBFX0JMT0I6XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQmxvYihbYnVmZmVyXSwgeyB0eXBlOiBibG9iVHlwZSB9KTtcbiAgICAgICAgY2FzZSBUWVBFX0lOVDhBUlJBWTpcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGNhc2UgVFlQRV9VSU5UOEFSUkFZOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGNhc2UgVFlQRV9VSU5UOENMQU1QRURBUlJBWTpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhDbGFtcGVkQXJyYXkoYnVmZmVyKTtcbiAgICAgICAgY2FzZSBUWVBFX0lOVDE2QVJSQVk6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludDE2QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgY2FzZSBUWVBFX1VJTlQxNkFSUkFZOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShidWZmZXIpO1xuICAgICAgICBjYXNlIFRZUEVfSU5UMzJBUlJBWTpcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShidWZmZXIpO1xuICAgICAgICBjYXNlIFRZUEVfVUlOVDMyQVJSQVk6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGNhc2UgVFlQRV9GTE9BVDMyQVJSQVk6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xuICAgICAgICBjYXNlIFRZUEVfRkxPQVQ2NEFSUkFZOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rb3duIHR5cGU6ICcgKyB0eXBlKTtcbiAgICB9XG59XG5cbnZhciBsb2NhbGZvcmFnZVNlcmlhbGl6ZXIgPSB7XG4gICAgc2VyaWFsaXplOiBzZXJpYWxpemUsXG4gICAgZGVzZXJpYWxpemU6IGRlc2VyaWFsaXplLFxuICAgIHN0cmluZ1RvQnVmZmVyOiBzdHJpbmdUb0J1ZmZlcixcbiAgICBidWZmZXJUb1N0cmluZzogYnVmZmVyVG9TdHJpbmdcbn07XG5cbi8qXG4gKiBJbmNsdWRlcyBjb2RlIGZyb206XG4gKlxuICogYmFzZTY0LWFycmF5YnVmZmVyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbmlrbGFzdmgvYmFzZTY0LWFycmF5YnVmZmVyXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEyIE5pa2xhcyB2b24gSGVydHplblxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZURiVGFibGUodCwgZGJJbmZvLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgIHQuZXhlY3V0ZVNxbCgnQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgJyArIGRiSW5mby5zdG9yZU5hbWUgKyAnICcgKyAnKGlkIElOVEVHRVIgUFJJTUFSWSBLRVksIGtleSB1bmlxdWUsIHZhbHVlKScsIFtdLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjayk7XG59XG5cbi8vIE9wZW4gdGhlIFdlYlNRTCBkYXRhYmFzZSAoYXV0b21hdGljYWxseSBjcmVhdGVzIG9uZSBpZiBvbmUgZGlkbid0XG4vLyBwcmV2aW91c2x5IGV4aXN0KSwgdXNpbmcgYW55IG9wdGlvbnMgc2V0IGluIHRoZSBjb25maWcuXG5mdW5jdGlvbiBfaW5pdFN0b3JhZ2UkMShvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkYkluZm8gPSB7XG4gICAgICAgIGRiOiBudWxsXG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgZGJJbmZvW2ldID0gdHlwZW9mIG9wdGlvbnNbaV0gIT09ICdzdHJpbmcnID8gb3B0aW9uc1tpXS50b1N0cmluZygpIDogb3B0aW9uc1tpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkYkluZm9Qcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIC8vIE9wZW4gdGhlIGRhdGFiYXNlOyB0aGUgb3BlbkRhdGFiYXNlIEFQSSB3aWxsIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgLy8gY3JlYXRlIGl0IGZvciB1cyBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGJJbmZvLmRiID0gb3BlbkRhdGFiYXNlKGRiSW5mby5uYW1lLCBTdHJpbmcoZGJJbmZvLnZlcnNpb24pLCBkYkluZm8uZGVzY3JpcHRpb24sIGRiSW5mby5zaXplKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBvdXIga2V5L3ZhbHVlIHRhYmxlIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICAgIGRiSW5mby5kYi50cmFuc2FjdGlvbihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgY3JlYXRlRGJUYWJsZSh0LCBkYkluZm8sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9kYkluZm8gPSBkYkluZm87XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHQsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZGJJbmZvLnNlcmlhbGl6ZXIgPSBsb2NhbGZvcmFnZVNlcmlhbGl6ZXI7XG4gICAgcmV0dXJuIGRiSW5mb1Byb21pc2U7XG59XG5cbmZ1bmN0aW9uIHRyeUV4ZWN1dGVTcWwodCwgZGJJbmZvLCBzcWxTdGF0ZW1lbnQsIGFyZ3MsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgdC5leGVjdXRlU3FsKHNxbFN0YXRlbWVudCwgYXJncywgY2FsbGJhY2ssIGZ1bmN0aW9uICh0LCBlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gZXJyb3IuU1lOVEFYX0VSUikge1xuICAgICAgICAgICAgdC5leGVjdXRlU3FsKCdTRUxFQ1QgbmFtZSBGUk9NIHNxbGl0ZV9tYXN0ZXIgJyArIFwiV0hFUkUgdHlwZT0ndGFibGUnIEFORCBuYW1lID0gP1wiLCBbZGJJbmZvLnN0b3JlTmFtZV0sIGZ1bmN0aW9uICh0LCByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHRzLnJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSB0YWJsZSBpcyBtaXNzaW5nICh3YXMgZGVsZXRlZClcbiAgICAgICAgICAgICAgICAgICAgLy8gcmUtY3JlYXRlIGl0IHRhYmxlIGFuZCByZXRyeVxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVEYlRhYmxlKHQsIGRiSW5mbywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdC5leGVjdXRlU3FsKHNxbFN0YXRlbWVudCwgYXJncywgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICB9LCBlcnJvckNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKHQsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBlcnJvckNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yQ2FsbGJhY2sodCwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfSwgZXJyb3JDYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGdldEl0ZW0kMShrZXksIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAga2V5ID0gbm9ybWFsaXplS2V5KGtleSk7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuICAgICAgICAgICAgZGJJbmZvLmRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgdHJ5RXhlY3V0ZVNxbCh0LCBkYkluZm8sICdTRUxFQ1QgKiBGUk9NICcgKyBkYkluZm8uc3RvcmVOYW1lICsgJyBXSEVSRSBrZXkgPSA/IExJTUlUIDEnLCBba2V5XSwgZnVuY3Rpb24gKHQsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJlc3VsdHMucm93cy5sZW5ndGggPyByZXN1bHRzLnJvd3MuaXRlbSgwKS52YWx1ZSA6IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoaXMgaXMgc2VyaWFsaXplZCBjb250ZW50IHdlIG5lZWQgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gdW5wYWNrLlxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBkYkluZm8uc2VyaWFsaXplci5kZXNlcmlhbGl6ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICh0LCBlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIGl0ZXJhdGUkMShpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuXG4gICAgICAgICAgICBkYkluZm8uZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICB0cnlFeGVjdXRlU3FsKHQsIGRiSW5mbywgJ1NFTEVDVCAqIEZST00gJyArIGRiSW5mby5zdG9yZU5hbWUsIFtdLCBmdW5jdGlvbiAodCwgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm93cyA9IHJlc3VsdHMucm93cztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHJvd3MubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gcm93cy5pdGVtKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGl0ZW0udmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGlzIGlzIHNlcmlhbGl6ZWQgY29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB1bnBhY2suXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZGJJbmZvLnNlcmlhbGl6ZXIuZGVzZXJpYWxpemUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gaXRlcmF0b3IocmVzdWx0LCBpdGVtLmtleSwgaSArIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB2b2lkKDApIHByZXZlbnRzIHByb2JsZW1zIHdpdGggcmVkZWZpbml0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiBgdW5kZWZpbmVkYC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHQsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gX3NldEl0ZW0oa2V5LCB2YWx1ZSwgY2FsbGJhY2ssIHJldHJpZXNMZWZ0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAga2V5ID0gbm9ybWFsaXplS2V5KGtleSk7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBUaGUgbG9jYWxTdG9yYWdlIEFQSSBkb2Vzbid0IHJldHVybiB1bmRlZmluZWQgdmFsdWVzIGluIGFuXG4gICAgICAgICAgICAvLyBcImV4cGVjdGVkXCIgd2F5LCBzbyB1bmRlZmluZWQgaXMgYWx3YXlzIGNhc3QgdG8gbnVsbCBpbiBhbGxcbiAgICAgICAgICAgIC8vIGRyaXZlcnMuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvbG9jYWxGb3JhZ2UvcHVsbC80MlxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIG9yaWdpbmFsIHZhbHVlIHRvIHBhc3MgdG8gdGhlIGNhbGxiYWNrLlxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsVmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICAgICAgdmFyIGRiSW5mbyA9IHNlbGYuX2RiSW5mbztcbiAgICAgICAgICAgIGRiSW5mby5zZXJpYWxpemVyLnNlcmlhbGl6ZSh2YWx1ZSwgZnVuY3Rpb24gKHZhbHVlLCBlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRiSW5mby5kYi50cmFuc2FjdGlvbihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5RXhlY3V0ZVNxbCh0LCBkYkluZm8sICdJTlNFUlQgT1IgUkVQTEFDRSBJTlRPICcgKyBkYkluZm8uc3RvcmVOYW1lICsgJyAnICsgJyhrZXksIHZhbHVlKSBWQUxVRVMgKD8sID8pJywgW2tleSwgdmFsdWVdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvcmlnaW5hbFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICh0LCBlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHNxbEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdHJhbnNhY3Rpb24gZmFpbGVkOyBjaGVja1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gc2VlIGlmIGl0J3MgYSBxdW90YSBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcWxFcnJvci5jb2RlID09PSBzcWxFcnJvci5RVU9UQV9FUlIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSByZWplY3QgdGhlIGNhbGxiYWNrIG91dHJpZ2h0IGZvciBub3csIGJ1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0J3Mgd29ydGggdHJ5aW5nIHRvIHJlLXJ1biB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXZlbiBpZiB0aGUgdXNlciBhY2NlcHRzIHRoZSBwcm9tcHQgdG8gdXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW9yZSBzdG9yYWdlIG9uIFNhZmFyaSwgdGhpcyBlcnJvciB3aWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmUgY2FsbGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHJlLXJ1biB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldHJpZXNMZWZ0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKF9zZXRJdGVtLmFwcGx5KHNlbGYsIFtrZXksIG9yaWdpbmFsVmFsdWUsIGNhbGxiYWNrLCByZXRyaWVzTGVmdCAtIDFdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHNxbEVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIHNldEl0ZW0kMShrZXksIHZhbHVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBfc2V0SXRlbS5hcHBseSh0aGlzLCBba2V5LCB2YWx1ZSwgY2FsbGJhY2ssIDFdKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlSXRlbSQxKGtleSwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBrZXkgPSBub3JtYWxpemVLZXkoa2V5KTtcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYkluZm8gPSBzZWxmLl9kYkluZm87XG4gICAgICAgICAgICBkYkluZm8uZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICB0cnlFeGVjdXRlU3FsKHQsIGRiSW5mbywgJ0RFTEVURSBGUk9NICcgKyBkYkluZm8uc3RvcmVOYW1lICsgJyBXSEVSRSBrZXkgPSA/JywgW2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICh0LCBlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbi8vIERlbGV0ZXMgZXZlcnkgaXRlbSBpbiB0aGUgdGFibGUuXG4vLyBUT0RPOiBGaW5kIG91dCBpZiB0aGlzIHJlc2V0cyB0aGUgQVVUT19JTkNSRU1FTlQgbnVtYmVyLlxuZnVuY3Rpb24gY2xlYXIkMShjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYkluZm8gPSBzZWxmLl9kYkluZm87XG4gICAgICAgICAgICBkYkluZm8uZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICB0cnlFeGVjdXRlU3FsKHQsIGRiSW5mbywgJ0RFTEVURSBGUk9NICcgKyBkYkluZm8uc3RvcmVOYW1lLCBbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHQsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLy8gRG9lcyBhIHNpbXBsZSBgQ09VTlQoa2V5KWAgdG8gZ2V0IHRoZSBudW1iZXIgb2YgaXRlbXMgc3RvcmVkIGluXG4vLyBsb2NhbEZvcmFnZS5cbmZ1bmN0aW9uIGxlbmd0aCQxKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRiSW5mbyA9IHNlbGYuX2RiSW5mbztcbiAgICAgICAgICAgIGRiSW5mby5kYi50cmFuc2FjdGlvbihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIC8vIEFoaGgsIFNRTCBtYWtlcyB0aGlzIG9uZSBzb29vb29vIGVhc3kuXG4gICAgICAgICAgICAgICAgdHJ5RXhlY3V0ZVNxbCh0LCBkYkluZm8sICdTRUxFQ1QgQ09VTlQoa2V5KSBhcyBjIEZST00gJyArIGRiSW5mby5zdG9yZU5hbWUsIFtdLCBmdW5jdGlvbiAodCwgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzdWx0cy5yb3dzLml0ZW0oMCkuYztcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICh0LCBlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbi8vIFJldHVybiB0aGUga2V5IGxvY2F0ZWQgYXQga2V5IGluZGV4IFg7IGVzc2VudGlhbGx5IGdldHMgdGhlIGtleSBmcm9tIGFcbi8vIGBXSEVSRSBpZCA9ID9gLiBUaGlzIGlzIHRoZSBtb3N0IGVmZmljaWVudCB3YXkgSSBjYW4gdGhpbmsgdG8gaW1wbGVtZW50XG4vLyB0aGlzIHJhcmVseS11c2VkIChpbiBteSBleHBlcmllbmNlKSBwYXJ0IG9mIHRoZSBBUEksIGJ1dCBpdCBjYW4gc2VlbVxuLy8gaW5jb25zaXN0ZW50LCBiZWNhdXNlIHdlIGRvIGBJTlNFUlQgT1IgUkVQTEFDRSBJTlRPYCBvbiBgc2V0SXRlbSgpYCwgc29cbi8vIHRoZSBJRCBvZiBlYWNoIGtleSB3aWxsIGNoYW5nZSBldmVyeSB0aW1lIGl0J3MgdXBkYXRlZC4gUGVyaGFwcyBhIHN0b3JlZFxuLy8gcHJvY2VkdXJlIGZvciB0aGUgYHNldEl0ZW0oKWAgU1FMIHdvdWxkIHNvbHZlIHRoaXMgcHJvYmxlbT9cbi8vIFRPRE86IERvbid0IGNoYW5nZSBJRCBvbiBgc2V0SXRlbSgpYC5cbmZ1bmN0aW9uIGtleSQxKG4sIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRiSW5mbyA9IHNlbGYuX2RiSW5mbztcbiAgICAgICAgICAgIGRiSW5mby5kYi50cmFuc2FjdGlvbihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHRyeUV4ZWN1dGVTcWwodCwgZGJJbmZvLCAnU0VMRUNUIGtleSBGUk9NICcgKyBkYkluZm8uc3RvcmVOYW1lICsgJyBXSEVSRSBpZCA9ID8gTElNSVQgMScsIFtuICsgMV0sIGZ1bmN0aW9uICh0LCByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRzLnJvd3MubGVuZ3RoID8gcmVzdWx0cy5yb3dzLml0ZW0oMCkua2V5IDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICh0LCBlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIGtleXMkMShjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYkluZm8gPSBzZWxmLl9kYkluZm87XG4gICAgICAgICAgICBkYkluZm8uZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICB0cnlFeGVjdXRlU3FsKHQsIGRiSW5mbywgJ1NFTEVDVCBrZXkgRlJPTSAnICsgZGJJbmZvLnN0b3JlTmFtZSwgW10sIGZ1bmN0aW9uICh0LCByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlzID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRzLnJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChyZXN1bHRzLnJvd3MuaXRlbShpKS5rZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShrZXlzKTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAodCwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKHJlamVjdCk7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViZGF0YWJhc2UvI2RhdGFiYXNlc1xuLy8gPiBUaGVyZSBpcyBubyB3YXkgdG8gZW51bWVyYXRlIG9yIGRlbGV0ZSB0aGUgZGF0YWJhc2VzIGF2YWlsYWJsZSBmb3IgYW4gb3JpZ2luIGZyb20gdGhpcyBBUEkuXG5mdW5jdGlvbiBnZXRBbGxTdG9yZU5hbWVzKGRiKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBkYi50cmFuc2FjdGlvbihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdC5leGVjdXRlU3FsKCdTRUxFQ1QgbmFtZSBGUk9NIHNxbGl0ZV9tYXN0ZXIgJyArIFwiV0hFUkUgdHlwZT0ndGFibGUnIEFORCBuYW1lIDw+ICdfX1dlYktpdERhdGFiYXNlSW5mb1RhYmxlX18nXCIsIFtdLCBmdW5jdGlvbiAodCwgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIHZhciBzdG9yZU5hbWVzID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdHMucm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZU5hbWVzLnB1c2gocmVzdWx0cy5yb3dzLml0ZW0oaSkubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgIGRiOiBkYixcbiAgICAgICAgICAgICAgICAgICAgc3RvcmVOYW1lczogc3RvcmVOYW1lc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHQsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoc3FsRXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChzcWxFcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBkcm9wSW5zdGFuY2UkMShvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gZ2V0Q2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHZhciBjdXJyZW50Q29uZmlnID0gdGhpcy5jb25maWcoKTtcbiAgICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgIT09ICdmdW5jdGlvbicgJiYgb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoIW9wdGlvbnMubmFtZSkge1xuICAgICAgICBvcHRpb25zLm5hbWUgPSBvcHRpb25zLm5hbWUgfHwgY3VycmVudENvbmZpZy5uYW1lO1xuICAgICAgICBvcHRpb25zLnN0b3JlTmFtZSA9IG9wdGlvbnMuc3RvcmVOYW1lIHx8IGN1cnJlbnRDb25maWcuc3RvcmVOYW1lO1xuICAgIH1cblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcHJvbWlzZTtcbiAgICBpZiAoIW9wdGlvbnMubmFtZSkge1xuICAgICAgICBwcm9taXNlID0gUHJvbWlzZSQxLnJlamVjdCgnSW52YWxpZCBhcmd1bWVudHMnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgdmFyIGRiO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubmFtZSA9PT0gY3VycmVudENvbmZpZy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBkYiByZWZlcmVuY2Ugb2YgdGhlIGN1cnJlbnQgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICBkYiA9IHNlbGYuX2RiSW5mby5kYjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGIgPSBvcGVuRGF0YWJhc2Uob3B0aW9ucy5uYW1lLCAnJywgJycsIDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuc3RvcmVOYW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gZHJvcCBhbGwgZGF0YWJhc2UgdGFibGVzXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShnZXRBbGxTdG9yZU5hbWVzKGRiKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICBkYjogZGIsXG4gICAgICAgICAgICAgICAgICAgIHN0b3JlTmFtZXM6IFtvcHRpb25zLnN0b3JlTmFtZV1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAob3BlcmF0aW9uSW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbkluZm8uZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZHJvcFRhYmxlKHN0b3JlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuZXhlY3V0ZVNxbCgnRFJPUCBUQUJMRSBJRiBFWElTVFMgJyArIHN0b3JlTmFtZSwgW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICh0LCBlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgb3BlcmF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb3BlcmF0aW9uSW5mby5zdG9yZU5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25zLnB1c2goZHJvcFRhYmxlKG9wZXJhdGlvbkluZm8uc3RvcmVOYW1lc1tpXSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZSQxLmFsbChvcGVyYXRpb25zKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoc3FsRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHNxbEVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG52YXIgd2ViU1FMU3RvcmFnZSA9IHtcbiAgICBfZHJpdmVyOiAnd2ViU1FMU3RvcmFnZScsXG4gICAgX2luaXRTdG9yYWdlOiBfaW5pdFN0b3JhZ2UkMSxcbiAgICBfc3VwcG9ydDogaXNXZWJTUUxWYWxpZCgpLFxuICAgIGl0ZXJhdGU6IGl0ZXJhdGUkMSxcbiAgICBnZXRJdGVtOiBnZXRJdGVtJDEsXG4gICAgc2V0SXRlbTogc2V0SXRlbSQxLFxuICAgIHJlbW92ZUl0ZW06IHJlbW92ZUl0ZW0kMSxcbiAgICBjbGVhcjogY2xlYXIkMSxcbiAgICBsZW5ndGg6IGxlbmd0aCQxLFxuICAgIGtleToga2V5JDEsXG4gICAga2V5czoga2V5cyQxLFxuICAgIGRyb3BJbnN0YW5jZTogZHJvcEluc3RhbmNlJDFcbn07XG5cbmZ1bmN0aW9uIGlzTG9jYWxTdG9yYWdlVmFsaWQoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09ICd1bmRlZmluZWQnICYmICdzZXRJdGVtJyBpbiBsb2NhbFN0b3JhZ2UgJiZcbiAgICAgICAgLy8gaW4gSUU4IHR5cGVvZiBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSA9PT0gJ29iamVjdCdcbiAgICAgICAgISFsb2NhbFN0b3JhZ2Uuc2V0SXRlbTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIF9nZXRLZXlQcmVmaXgob3B0aW9ucywgZGVmYXVsdENvbmZpZykge1xuICAgIHZhciBrZXlQcmVmaXggPSBvcHRpb25zLm5hbWUgKyAnLyc7XG5cbiAgICBpZiAob3B0aW9ucy5zdG9yZU5hbWUgIT09IGRlZmF1bHRDb25maWcuc3RvcmVOYW1lKSB7XG4gICAgICAgIGtleVByZWZpeCArPSBvcHRpb25zLnN0b3JlTmFtZSArICcvJztcbiAgICB9XG4gICAgcmV0dXJuIGtleVByZWZpeDtcbn1cblxuLy8gQ2hlY2sgaWYgbG9jYWxTdG9yYWdlIHRocm93cyB3aGVuIHNhdmluZyBhbiBpdGVtXG5mdW5jdGlvbiBjaGVja0lmTG9jYWxTdG9yYWdlVGhyb3dzKCkge1xuICAgIHZhciBsb2NhbFN0b3JhZ2VUZXN0S2V5ID0gJ19sb2NhbGZvcmFnZV9zdXBwb3J0X3Rlc3QnO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0obG9jYWxTdG9yYWdlVGVzdEtleSwgdHJ1ZSk7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGxvY2FsU3RvcmFnZVRlc3RLZXkpO1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuLy8gQ2hlY2sgaWYgbG9jYWxTdG9yYWdlIGlzIHVzYWJsZSBhbmQgYWxsb3dzIHRvIHNhdmUgYW4gaXRlbVxuLy8gVGhpcyBtZXRob2QgY2hlY2tzIGlmIGxvY2FsU3RvcmFnZSBpcyB1c2FibGUgaW4gU2FmYXJpIFByaXZhdGUgQnJvd3Npbmdcbi8vIG1vZGUsIG9yIGluIGFueSBvdGhlciBjYXNlIHdoZXJlIHRoZSBhdmFpbGFibGUgcXVvdGEgZm9yIGxvY2FsU3RvcmFnZVxuLy8gaXMgMCBhbmQgdGhlcmUgd2Fzbid0IGFueSBzYXZlZCBpdGVtcyB5ZXQuXG5mdW5jdGlvbiBfaXNMb2NhbFN0b3JhZ2VVc2FibGUoKSB7XG4gICAgcmV0dXJuICFjaGVja0lmTG9jYWxTdG9yYWdlVGhyb3dzKCkgfHwgbG9jYWxTdG9yYWdlLmxlbmd0aCA+IDA7XG59XG5cbi8vIENvbmZpZyB0aGUgbG9jYWxTdG9yYWdlIGJhY2tlbmQsIHVzaW5nIG9wdGlvbnMgc2V0IGluIHRoZSBjb25maWcuXG5mdW5jdGlvbiBfaW5pdFN0b3JhZ2UkMihvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkYkluZm8gPSB7fTtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGRiSW5mb1tpXSA9IG9wdGlvbnNbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkYkluZm8ua2V5UHJlZml4ID0gX2dldEtleVByZWZpeChvcHRpb25zLCBzZWxmLl9kZWZhdWx0Q29uZmlnKTtcblxuICAgIGlmICghX2lzTG9jYWxTdG9yYWdlVXNhYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UkMS5yZWplY3QoKTtcbiAgICB9XG5cbiAgICBzZWxmLl9kYkluZm8gPSBkYkluZm87XG4gICAgZGJJbmZvLnNlcmlhbGl6ZXIgPSBsb2NhbGZvcmFnZVNlcmlhbGl6ZXI7XG5cbiAgICByZXR1cm4gUHJvbWlzZSQxLnJlc29sdmUoKTtcbn1cblxuLy8gUmVtb3ZlIGFsbCBrZXlzIGZyb20gdGhlIGRhdGFzdG9yZSwgZWZmZWN0aXZlbHkgZGVzdHJveWluZyBhbGwgZGF0YSBpblxuLy8gdGhlIGFwcCdzIGtleS92YWx1ZSBzdG9yZSFcbmZ1bmN0aW9uIGNsZWFyJDIoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHByb21pc2UgPSBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBrZXlQcmVmaXggPSBzZWxmLl9kYkluZm8ua2V5UHJlZml4O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBsb2NhbFN0b3JhZ2UubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBsb2NhbFN0b3JhZ2Uua2V5KGkpO1xuXG4gICAgICAgICAgICBpZiAoa2V5LmluZGV4T2Yoa2V5UHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbi8vIFJldHJpZXZlIGFuIGl0ZW0gZnJvbSB0aGUgc3RvcmUuIFVubGlrZSB0aGUgb3JpZ2luYWwgYXN5bmNfc3RvcmFnZVxuLy8gbGlicmFyeSBpbiBHYWlhLCB3ZSBkb24ndCBtb2RpZnkgcmV0dXJuIHZhbHVlcyBhdCBhbGwuIElmIGEga2V5J3MgdmFsdWVcbi8vIGlzIGB1bmRlZmluZWRgLCB3ZSBwYXNzIHRoYXQgdmFsdWUgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuZnVuY3Rpb24gZ2V0SXRlbSQyKGtleSwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBrZXkgPSBub3JtYWxpemVLZXkoa2V5KTtcblxuICAgIHZhciBwcm9taXNlID0gc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oZGJJbmZvLmtleVByZWZpeCArIGtleSk7XG5cbiAgICAgICAgLy8gSWYgYSByZXN1bHQgd2FzIGZvdW5kLCBwYXJzZSBpdCBmcm9tIHRoZSBzZXJpYWxpemVkXG4gICAgICAgIC8vIHN0cmluZyBpbnRvIGEgSlMgb2JqZWN0LiBJZiByZXN1bHQgaXNuJ3QgdHJ1dGh5LCB0aGUga2V5XG4gICAgICAgIC8vIGlzIGxpa2VseSB1bmRlZmluZWQgYW5kIHdlJ2xsIHBhc3MgaXQgc3RyYWlnaHQgdG8gdGhlXG4gICAgICAgIC8vIGNhbGxiYWNrLlxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBkYkluZm8uc2VyaWFsaXplci5kZXNlcmlhbGl6ZShyZXN1bHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbi8vIEl0ZXJhdGUgb3ZlciBhbGwgaXRlbXMgaW4gdGhlIHN0b3JlLlxuZnVuY3Rpb24gaXRlcmF0ZSQyKGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwcm9taXNlID0gc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuICAgICAgICB2YXIga2V5UHJlZml4ID0gZGJJbmZvLmtleVByZWZpeDtcbiAgICAgICAgdmFyIGtleVByZWZpeExlbmd0aCA9IGtleVByZWZpeC5sZW5ndGg7XG4gICAgICAgIHZhciBsZW5ndGggPSBsb2NhbFN0b3JhZ2UubGVuZ3RoO1xuXG4gICAgICAgIC8vIFdlIHVzZSBhIGRlZGljYXRlZCBpdGVyYXRvciBpbnN0ZWFkIG9mIHRoZSBgaWAgdmFyaWFibGUgYmVsb3dcbiAgICAgICAgLy8gc28gb3RoZXIga2V5cyB3ZSBmZXRjaCBpbiBsb2NhbFN0b3JhZ2UgYXJlbid0IGNvdW50ZWQgaW5cbiAgICAgICAgLy8gdGhlIGBpdGVyYXRpb25OdW1iZXJgIGFyZ3VtZW50IHBhc3NlZCB0byB0aGUgYGl0ZXJhdGUoKWBcbiAgICAgICAgLy8gY2FsbGJhY2suXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFNlZTogZ2l0aHViLmNvbS9tb3ppbGxhL2xvY2FsRm9yYWdlL3B1bGwvNDM1I2Rpc2N1c3Npb25fcjM4MDYxNTMwXG4gICAgICAgIHZhciBpdGVyYXRpb25OdW1iZXIgPSAxO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBsb2NhbFN0b3JhZ2Uua2V5KGkpO1xuICAgICAgICAgICAgaWYgKGtleS5pbmRleE9mKGtleVByZWZpeCkgIT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG5cbiAgICAgICAgICAgIC8vIElmIGEgcmVzdWx0IHdhcyBmb3VuZCwgcGFyc2UgaXQgZnJvbSB0aGUgc2VyaWFsaXplZFxuICAgICAgICAgICAgLy8gc3RyaW5nIGludG8gYSBKUyBvYmplY3QuIElmIHJlc3VsdCBpc24ndCB0cnV0aHksIHRoZVxuICAgICAgICAgICAgLy8ga2V5IGlzIGxpa2VseSB1bmRlZmluZWQgYW5kIHdlJ2xsIHBhc3MgaXQgc3RyYWlnaHRcbiAgICAgICAgICAgIC8vIHRvIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZGJJbmZvLnNlcmlhbGl6ZXIuZGVzZXJpYWxpemUodmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IGl0ZXJhdG9yKHZhbHVlLCBrZXkuc3Vic3RyaW5nKGtleVByZWZpeExlbmd0aCksIGl0ZXJhdGlvbk51bWJlcisrKTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbi8vIFNhbWUgYXMgbG9jYWxTdG9yYWdlJ3Mga2V5KCkgbWV0aG9kLCBleGNlcHQgdGFrZXMgYSBjYWxsYmFjay5cbmZ1bmN0aW9uIGtleSQyKG4sIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwcm9taXNlID0gc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbG9jYWxTdG9yYWdlLmtleShuKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgdGhlIHByZWZpeCBmcm9tIHRoZSBrZXksIGlmIGEga2V5IGlzIGZvdW5kLlxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc3Vic3RyaW5nKGRiSW5mby5rZXlQcmVmaXgubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBrZXlzJDIoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHByb21pc2UgPSBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYkluZm8gPSBzZWxmLl9kYkluZm87XG4gICAgICAgIHZhciBsZW5ndGggPSBsb2NhbFN0b3JhZ2UubGVuZ3RoO1xuICAgICAgICB2YXIga2V5cyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVtS2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKTtcbiAgICAgICAgICAgIGlmIChpdGVtS2V5LmluZGV4T2YoZGJJbmZvLmtleVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goaXRlbUtleS5zdWJzdHJpbmcoZGJJbmZvLmtleVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLy8gU3VwcGx5IHRoZSBudW1iZXIgb2Yga2V5cyBpbiB0aGUgZGF0YXN0b3JlIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbmZ1bmN0aW9uIGxlbmd0aCQyKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwcm9taXNlID0gc2VsZi5rZXlzKCkudGhlbihmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICByZXR1cm4ga2V5cy5sZW5ndGg7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG4vLyBSZW1vdmUgYW4gaXRlbSBmcm9tIHRoZSBzdG9yZSwgbmljZSBhbmQgc2ltcGxlLlxuZnVuY3Rpb24gcmVtb3ZlSXRlbSQyKGtleSwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBrZXkgPSBub3JtYWxpemVLZXkoa2V5KTtcblxuICAgIHZhciBwcm9taXNlID0gc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShkYkluZm8ua2V5UHJlZml4ICsga2V5KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbi8vIFNldCBhIGtleSdzIHZhbHVlIGFuZCBydW4gYW4gb3B0aW9uYWwgY2FsbGJhY2sgb25jZSB0aGUgdmFsdWUgaXMgc2V0LlxuLy8gVW5saWtlIEdhaWEncyBpbXBsZW1lbnRhdGlvbiwgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIHBhc3NlZCB0aGUgdmFsdWUsXG4vLyBpbiBjYXNlIHlvdSB3YW50IHRvIG9wZXJhdGUgb24gdGhhdCB2YWx1ZSBvbmx5IGFmdGVyIHlvdSdyZSBzdXJlIGl0XG4vLyBzYXZlZCwgb3Igc29tZXRoaW5nIGxpa2UgdGhhdC5cbmZ1bmN0aW9uIHNldEl0ZW0kMihrZXksIHZhbHVlLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuXG4gICAgdmFyIHByb21pc2UgPSBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIENvbnZlcnQgdW5kZWZpbmVkIHZhbHVlcyB0byBudWxsLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9sb2NhbEZvcmFnZS9wdWxsLzQyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTYXZlIHRoZSBvcmlnaW5hbCB2YWx1ZSB0byBwYXNzIHRvIHRoZSBjYWxsYmFjay5cbiAgICAgICAgdmFyIG9yaWdpbmFsVmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuICAgICAgICAgICAgZGJJbmZvLnNlcmlhbGl6ZXIuc2VyaWFsaXplKHZhbHVlLCBmdW5jdGlvbiAodmFsdWUsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGRiSW5mby5rZXlQcmVmaXggKyBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUob3JpZ2luYWxWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvY2FsU3RvcmFnZSBjYXBhY2l0eSBleGNlZWRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IE1ha2UgdGhpcyBhIHNwZWNpZmljIGVycm9yL2V2ZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUubmFtZSA9PT0gJ1F1b3RhRXhjZWVkZWRFcnJvcicgfHwgZS5uYW1lID09PSAnTlNfRVJST1JfRE9NX1FVT1RBX1JFQUNIRUQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gZHJvcEluc3RhbmNlJDIob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGdldENhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgIT09ICdmdW5jdGlvbicgJiYgb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoIW9wdGlvbnMubmFtZSkge1xuICAgICAgICB2YXIgY3VycmVudENvbmZpZyA9IHRoaXMuY29uZmlnKCk7XG4gICAgICAgIG9wdGlvbnMubmFtZSA9IG9wdGlvbnMubmFtZSB8fCBjdXJyZW50Q29uZmlnLm5hbWU7XG4gICAgICAgIG9wdGlvbnMuc3RvcmVOYW1lID0gb3B0aW9ucy5zdG9yZU5hbWUgfHwgY3VycmVudENvbmZpZy5zdG9yZU5hbWU7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwcm9taXNlO1xuICAgIGlmICghb3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIHByb21pc2UgPSBQcm9taXNlJDEucmVqZWN0KCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuc3RvcmVOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShvcHRpb25zLm5hbWUgKyAnLycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKF9nZXRLZXlQcmVmaXgob3B0aW9ucywgc2VsZi5fZGVmYXVsdENvbmZpZykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChrZXlQcmVmaXgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBsb2NhbFN0b3JhZ2UubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKTtcblxuICAgICAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZihrZXlQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG52YXIgbG9jYWxTdG9yYWdlV3JhcHBlciA9IHtcbiAgICBfZHJpdmVyOiAnbG9jYWxTdG9yYWdlV3JhcHBlcicsXG4gICAgX2luaXRTdG9yYWdlOiBfaW5pdFN0b3JhZ2UkMixcbiAgICBfc3VwcG9ydDogaXNMb2NhbFN0b3JhZ2VWYWxpZCgpLFxuICAgIGl0ZXJhdGU6IGl0ZXJhdGUkMixcbiAgICBnZXRJdGVtOiBnZXRJdGVtJDIsXG4gICAgc2V0SXRlbTogc2V0SXRlbSQyLFxuICAgIHJlbW92ZUl0ZW06IHJlbW92ZUl0ZW0kMixcbiAgICBjbGVhcjogY2xlYXIkMixcbiAgICBsZW5ndGg6IGxlbmd0aCQyLFxuICAgIGtleToga2V5JDIsXG4gICAga2V5czoga2V5cyQyLFxuICAgIGRyb3BJbnN0YW5jZTogZHJvcEluc3RhbmNlJDJcbn07XG5cbnZhciBzYW1lVmFsdWUgPSBmdW5jdGlvbiBzYW1lVmFsdWUoeCwgeSkge1xuICAgIHJldHVybiB4ID09PSB5IHx8IHR5cGVvZiB4ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgeSA9PT0gJ251bWJlcicgJiYgaXNOYU4oeCkgJiYgaXNOYU4oeSk7XG59O1xuXG52YXIgaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyhhcnJheSwgc2VhcmNoRWxlbWVudCkge1xuICAgIHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIGlmIChzYW1lVmFsdWUoYXJyYXlbaV0sIHNlYXJjaEVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcmcpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG4vLyBEcml2ZXJzIGFyZSBzdG9yZWQgaGVyZSB3aGVuIGBkZWZpbmVEcml2ZXIoKWAgaXMgY2FsbGVkLlxuLy8gVGhleSBhcmUgc2hhcmVkIGFjcm9zcyBhbGwgaW5zdGFuY2VzIG9mIGxvY2FsRm9yYWdlLlxudmFyIERlZmluZWREcml2ZXJzID0ge307XG5cbnZhciBEcml2ZXJTdXBwb3J0ID0ge307XG5cbnZhciBEZWZhdWx0RHJpdmVycyA9IHtcbiAgICBJTkRFWEVEREI6IGFzeW5jU3RvcmFnZSxcbiAgICBXRUJTUUw6IHdlYlNRTFN0b3JhZ2UsXG4gICAgTE9DQUxTVE9SQUdFOiBsb2NhbFN0b3JhZ2VXcmFwcGVyXG59O1xuXG52YXIgRGVmYXVsdERyaXZlck9yZGVyID0gW0RlZmF1bHREcml2ZXJzLklOREVYRUREQi5fZHJpdmVyLCBEZWZhdWx0RHJpdmVycy5XRUJTUUwuX2RyaXZlciwgRGVmYXVsdERyaXZlcnMuTE9DQUxTVE9SQUdFLl9kcml2ZXJdO1xuXG52YXIgT3B0aW9uYWxEcml2ZXJNZXRob2RzID0gWydkcm9wSW5zdGFuY2UnXTtcblxudmFyIExpYnJhcnlNZXRob2RzID0gWydjbGVhcicsICdnZXRJdGVtJywgJ2l0ZXJhdGUnLCAna2V5JywgJ2tleXMnLCAnbGVuZ3RoJywgJ3JlbW92ZUl0ZW0nLCAnc2V0SXRlbSddLmNvbmNhdChPcHRpb25hbERyaXZlck1ldGhvZHMpO1xuXG52YXIgRGVmYXVsdENvbmZpZyA9IHtcbiAgICBkZXNjcmlwdGlvbjogJycsXG4gICAgZHJpdmVyOiBEZWZhdWx0RHJpdmVyT3JkZXIuc2xpY2UoKSxcbiAgICBuYW1lOiAnbG9jYWxmb3JhZ2UnLFxuICAgIC8vIERlZmF1bHQgREIgc2l6ZSBpcyBfSlVTVCBVTkRFUl8gNU1CLCBhcyBpdCdzIHRoZSBoaWdoZXN0IHNpemVcbiAgICAvLyB3ZSBjYW4gdXNlIHdpdGhvdXQgYSBwcm9tcHQuXG4gICAgc2l6ZTogNDk4MDczNixcbiAgICBzdG9yZU5hbWU6ICdrZXl2YWx1ZXBhaXJzJyxcbiAgICB2ZXJzaW9uOiAxLjBcbn07XG5cbmZ1bmN0aW9uIGNhbGxXaGVuUmVhZHkobG9jYWxGb3JhZ2VJbnN0YW5jZSwgbGlicmFyeU1ldGhvZCkge1xuICAgIGxvY2FsRm9yYWdlSW5zdGFuY2VbbGlicmFyeU1ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIGxvY2FsRm9yYWdlSW5zdGFuY2UucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbEZvcmFnZUluc3RhbmNlW2xpYnJhcnlNZXRob2RdLmFwcGx5KGxvY2FsRm9yYWdlSW5zdGFuY2UsIF9hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgaWYgKGFyZykge1xuICAgICAgICAgICAgZm9yICh2YXIgX2tleSBpbiBhcmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJnLmhhc093blByb3BlcnR5KF9rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGFyZ1tfa2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50c1swXVtfa2V5XSA9IGFyZ1tfa2V5XS5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzWzBdW19rZXldID0gYXJnW19rZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbn1cblxudmFyIExvY2FsRm9yYWdlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvY2FsRm9yYWdlKG9wdGlvbnMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExvY2FsRm9yYWdlKTtcblxuICAgICAgICBmb3IgKHZhciBkcml2ZXJUeXBlS2V5IGluIERlZmF1bHREcml2ZXJzKSB7XG4gICAgICAgICAgICBpZiAoRGVmYXVsdERyaXZlcnMuaGFzT3duUHJvcGVydHkoZHJpdmVyVHlwZUtleSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHJpdmVyID0gRGVmYXVsdERyaXZlcnNbZHJpdmVyVHlwZUtleV07XG4gICAgICAgICAgICAgICAgdmFyIGRyaXZlck5hbWUgPSBkcml2ZXIuX2RyaXZlcjtcbiAgICAgICAgICAgICAgICB0aGlzW2RyaXZlclR5cGVLZXldID0gZHJpdmVyTmFtZTtcblxuICAgICAgICAgICAgICAgIGlmICghRGVmaW5lZERyaXZlcnNbZHJpdmVyTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0byB3YWl0IGZvciB0aGUgcHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgZHJpdmVycyBjYW4gYmUgZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAvLyBpbiBhIGJsb2NraW5nIG1hbm5lclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmluZURyaXZlcihkcml2ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2RlZmF1bHRDb25maWcgPSBleHRlbmQoe30sIERlZmF1bHRDb25maWcpO1xuICAgICAgICB0aGlzLl9jb25maWcgPSBleHRlbmQoe30sIHRoaXMuX2RlZmF1bHRDb25maWcsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9kcml2ZXJTZXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9pbml0RHJpdmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmVhZHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGJJbmZvID0gbnVsbDtcblxuICAgICAgICB0aGlzLl93cmFwTGlicmFyeU1ldGhvZHNXaXRoUmVhZHkoKTtcbiAgICAgICAgdGhpcy5zZXREcml2ZXIodGhpcy5fY29uZmlnLmRyaXZlcilbXCJjYXRjaFwiXShmdW5jdGlvbiAoKSB7fSk7XG4gICAgfVxuXG4gICAgLy8gU2V0IGFueSBjb25maWcgdmFsdWVzIGZvciBsb2NhbEZvcmFnZTsgY2FuIGJlIGNhbGxlZCBhbnl0aW1lIGJlZm9yZVxuICAgIC8vIHRoZSBmaXJzdCBBUEkgY2FsbCAoZS5nLiBgZ2V0SXRlbWAsIGBzZXRJdGVtYCkuXG4gICAgLy8gV2UgbG9vcCB0aHJvdWdoIG9wdGlvbnMgc28gd2UgZG9uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGNvbmZpZ1xuICAgIC8vIHZhbHVlcy5cblxuXG4gICAgTG9jYWxGb3JhZ2UucHJvdG90eXBlLmNvbmZpZyA9IGZ1bmN0aW9uIGNvbmZpZyhvcHRpb25zKSB7XG4gICAgICAgIC8vIElmIHRoZSBvcHRpb25zIGFyZ3VtZW50IGlzIGFuIG9iamVjdCwgd2UgdXNlIGl0IHRvIHNldCB2YWx1ZXMuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UgcmV0dXJuIGVpdGhlciBhIHNwZWNpZmllZCBjb25maWcgdmFsdWUgb3IgYWxsXG4gICAgICAgIC8vIGNvbmZpZyB2YWx1ZXMuXG4gICAgICAgIGlmICgodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9wdGlvbnMpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIC8vIElmIGxvY2FsZm9yYWdlIGlzIHJlYWR5IGFuZCBmdWxseSBpbml0aWFsaXplZCwgd2UgY2FuJ3Qgc2V0XG4gICAgICAgICAgICAvLyBhbnkgbmV3IGNvbmZpZ3VyYXRpb24gdmFsdWVzLiBJbnN0ZWFkLCB3ZSByZXR1cm4gYW4gZXJyb3IuXG4gICAgICAgICAgICBpZiAodGhpcy5fcmVhZHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFwiQ2FuJ3QgY2FsbCBjb25maWcoKSBhZnRlciBsb2NhbGZvcmFnZSBcIiArICdoYXMgYmVlbiB1c2VkLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gJ3N0b3JlTmFtZScpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1tpXSA9IG9wdGlvbnNbaV0ucmVwbGFjZSgvXFxXL2csICdfJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09ICd2ZXJzaW9uJyAmJiB0eXBlb2Ygb3B0aW9uc1tpXSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignRGF0YWJhc2UgdmVyc2lvbiBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbmZpZ1tpXSA9IG9wdGlvbnNbaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFmdGVyIGFsbCBjb25maWcgb3B0aW9ucyBhcmUgc2V0IGFuZFxuICAgICAgICAgICAgLy8gdGhlIGRyaXZlciBvcHRpb24gaXMgdXNlZCwgdHJ5IHNldHRpbmcgaXRcbiAgICAgICAgICAgIGlmICgnZHJpdmVyJyBpbiBvcHRpb25zICYmIG9wdGlvbnMuZHJpdmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0RHJpdmVyKHRoaXMuX2NvbmZpZy5kcml2ZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb25maWdbb3B0aW9uc107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29uZmlnO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFVzZWQgdG8gZGVmaW5lIGEgY3VzdG9tIGRyaXZlciwgc2hhcmVkIGFjcm9zcyBhbGwgaW5zdGFuY2VzIG9mXG4gICAgLy8gbG9jYWxGb3JhZ2UuXG5cblxuICAgIExvY2FsRm9yYWdlLnByb3RvdHlwZS5kZWZpbmVEcml2ZXIgPSBmdW5jdGlvbiBkZWZpbmVEcml2ZXIoZHJpdmVyT2JqZWN0LCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgZHJpdmVyTmFtZSA9IGRyaXZlck9iamVjdC5fZHJpdmVyO1xuICAgICAgICAgICAgICAgIHZhciBjb21wbGlhbmNlRXJyb3IgPSBuZXcgRXJyb3IoJ0N1c3RvbSBkcml2ZXIgbm90IGNvbXBsaWFudDsgc2VlICcgKyAnaHR0cHM6Ly9tb3ppbGxhLmdpdGh1Yi5pby9sb2NhbEZvcmFnZS8jZGVmaW5lZHJpdmVyJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBBIGRyaXZlciBuYW1lIHNob3VsZCBiZSBkZWZpbmVkIGFuZCBub3Qgb3ZlcmxhcCB3aXRoIHRoZVxuICAgICAgICAgICAgICAgIC8vIGxpYnJhcnktZGVmaW5lZCwgZGVmYXVsdCBkcml2ZXJzLlxuICAgICAgICAgICAgICAgIGlmICghZHJpdmVyT2JqZWN0Ll9kcml2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGNvbXBsaWFuY2VFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZHJpdmVyTWV0aG9kcyA9IExpYnJhcnlNZXRob2RzLmNvbmNhdCgnX2luaXRTdG9yYWdlJyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRyaXZlck1ldGhvZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyaXZlck1ldGhvZE5hbWUgPSBkcml2ZXJNZXRob2RzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIHByb3BlcnR5IGlzIHRoZXJlLFxuICAgICAgICAgICAgICAgICAgICAvLyBpdCBzaG91bGQgYmUgYSBtZXRob2QgZXZlbiB3aGVuIG9wdGlvbmFsXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc1JlcXVpcmVkID0gIWluY2x1ZGVzKE9wdGlvbmFsRHJpdmVyTWV0aG9kcywgZHJpdmVyTWV0aG9kTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoaXNSZXF1aXJlZCB8fCBkcml2ZXJPYmplY3RbZHJpdmVyTWV0aG9kTmFtZV0pICYmIHR5cGVvZiBkcml2ZXJPYmplY3RbZHJpdmVyTWV0aG9kTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChjb21wbGlhbmNlRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpZ3VyZU1pc3NpbmdNZXRob2RzID0gZnVuY3Rpb24gY29uZmlndXJlTWlzc2luZ01ldGhvZHMoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXRob2ROb3RJbXBsZW1lbnRlZEZhY3RvcnkgPSBmdW5jdGlvbiBtZXRob2ROb3RJbXBsZW1lbnRlZEZhY3RvcnkobWV0aG9kTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ01ldGhvZCAnICsgbWV0aG9kTmFtZSArICcgaXMgbm90IGltcGxlbWVudGVkIGJ5IHRoZSBjdXJyZW50IGRyaXZlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gUHJvbWlzZSQxLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9sZW4gPSBPcHRpb25hbERyaXZlck1ldGhvZHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25hbERyaXZlck1ldGhvZCA9IE9wdGlvbmFsRHJpdmVyTWV0aG9kc1tfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRyaXZlck9iamVjdFtvcHRpb25hbERyaXZlck1ldGhvZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcml2ZXJPYmplY3Rbb3B0aW9uYWxEcml2ZXJNZXRob2RdID0gbWV0aG9kTm90SW1wbGVtZW50ZWRGYWN0b3J5KG9wdGlvbmFsRHJpdmVyTWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBjb25maWd1cmVNaXNzaW5nTWV0aG9kcygpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHNldERyaXZlclN1cHBvcnQgPSBmdW5jdGlvbiBzZXREcml2ZXJTdXBwb3J0KHN1cHBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKERlZmluZWREcml2ZXJzW2RyaXZlck5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oJ1JlZGVmaW5pbmcgTG9jYWxGb3JhZ2UgZHJpdmVyOiAnICsgZHJpdmVyTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgRGVmaW5lZERyaXZlcnNbZHJpdmVyTmFtZV0gPSBkcml2ZXJPYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgIERyaXZlclN1cHBvcnRbZHJpdmVyTmFtZV0gPSBzdXBwb3J0O1xuICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCB1c2UgYSB0aGVuLCBzbyB0aGF0IHdlIGNhbiBkZWZpbmVcbiAgICAgICAgICAgICAgICAgICAgLy8gZHJpdmVycyB0aGF0IGhhdmUgc2ltcGxlIF9zdXBwb3J0IG1ldGhvZHNcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gYSBibG9ja2luZyBtYW5uZXJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoJ19zdXBwb3J0JyBpbiBkcml2ZXJPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRyaXZlck9iamVjdC5fc3VwcG9ydCAmJiB0eXBlb2YgZHJpdmVyT2JqZWN0Ll9zdXBwb3J0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcml2ZXJPYmplY3QuX3N1cHBvcnQoKS50aGVuKHNldERyaXZlclN1cHBvcnQsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXREcml2ZXJTdXBwb3J0KCEhZHJpdmVyT2JqZWN0Ll9zdXBwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldERyaXZlclN1cHBvcnQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhlY3V0ZVR3b0NhbGxiYWNrcyhwcm9taXNlLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG5cbiAgICBMb2NhbEZvcmFnZS5wcm90b3R5cGUuZHJpdmVyID0gZnVuY3Rpb24gZHJpdmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZHJpdmVyIHx8IG51bGw7XG4gICAgfTtcblxuICAgIExvY2FsRm9yYWdlLnByb3RvdHlwZS5nZXREcml2ZXIgPSBmdW5jdGlvbiBnZXREcml2ZXIoZHJpdmVyTmFtZSwgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGdldERyaXZlclByb21pc2UgPSBEZWZpbmVkRHJpdmVyc1tkcml2ZXJOYW1lXSA/IFByb21pc2UkMS5yZXNvbHZlKERlZmluZWREcml2ZXJzW2RyaXZlck5hbWVdKSA6IFByb21pc2UkMS5yZWplY3QobmV3IEVycm9yKCdEcml2ZXIgbm90IGZvdW5kLicpKTtcblxuICAgICAgICBleGVjdXRlVHdvQ2FsbGJhY2tzKGdldERyaXZlclByb21pc2UsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIGdldERyaXZlclByb21pc2U7XG4gICAgfTtcblxuICAgIExvY2FsRm9yYWdlLnByb3RvdHlwZS5nZXRTZXJpYWxpemVyID0gZnVuY3Rpb24gZ2V0U2VyaWFsaXplcihjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2VyaWFsaXplclByb21pc2UgPSBQcm9taXNlJDEucmVzb2x2ZShsb2NhbGZvcmFnZVNlcmlhbGl6ZXIpO1xuICAgICAgICBleGVjdXRlVHdvQ2FsbGJhY2tzKHNlcmlhbGl6ZXJQcm9taXNlLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVyUHJvbWlzZTtcbiAgICB9O1xuXG4gICAgTG9jYWxGb3JhZ2UucHJvdG90eXBlLnJlYWR5ID0gZnVuY3Rpb24gcmVhZHkoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHZhciBwcm9taXNlID0gc2VsZi5fZHJpdmVyU2V0LnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuX3JlYWR5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fcmVhZHkgPSBzZWxmLl9pbml0RHJpdmVyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9yZWFkeTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXhlY3V0ZVR3b0NhbGxiYWNrcyhwcm9taXNlLCBjYWxsYmFjaywgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgTG9jYWxGb3JhZ2UucHJvdG90eXBlLnNldERyaXZlciA9IGZ1bmN0aW9uIHNldERyaXZlcihkcml2ZXJzLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFpc0FycmF5KGRyaXZlcnMpKSB7XG4gICAgICAgICAgICBkcml2ZXJzID0gW2RyaXZlcnNdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN1cHBvcnRlZERyaXZlcnMgPSB0aGlzLl9nZXRTdXBwb3J0ZWREcml2ZXJzKGRyaXZlcnMpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHNldERyaXZlclRvQ29uZmlnKCkge1xuICAgICAgICAgICAgc2VsZi5fY29uZmlnLmRyaXZlciA9IHNlbGYuZHJpdmVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBleHRlbmRTZWxmV2l0aERyaXZlcihkcml2ZXIpIHtcbiAgICAgICAgICAgIHNlbGYuX2V4dGVuZChkcml2ZXIpO1xuICAgICAgICAgICAgc2V0RHJpdmVyVG9Db25maWcoKTtcblxuICAgICAgICAgICAgc2VsZi5fcmVhZHkgPSBzZWxmLl9pbml0U3RvcmFnZShzZWxmLl9jb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3JlYWR5O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdERyaXZlcihzdXBwb3J0ZWREcml2ZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50RHJpdmVySW5kZXggPSAwO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZHJpdmVyUHJvbWlzZUxvb3AoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjdXJyZW50RHJpdmVySW5kZXggPCBzdXBwb3J0ZWREcml2ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRyaXZlck5hbWUgPSBzdXBwb3J0ZWREcml2ZXJzW2N1cnJlbnREcml2ZXJJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RHJpdmVySW5kZXgrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fZGJJbmZvID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3JlYWR5ID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0RHJpdmVyKGRyaXZlck5hbWUpLnRoZW4oZXh0ZW5kU2VsZldpdGhEcml2ZXIpW1wiY2F0Y2hcIl0oZHJpdmVyUHJvbWlzZUxvb3ApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0RHJpdmVyVG9Db25maWcoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdObyBhdmFpbGFibGUgc3RvcmFnZSBtZXRob2QgZm91bmQuJyk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2RyaXZlclNldCA9IFByb21pc2UkMS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fZHJpdmVyU2V0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBkcml2ZXJQcm9taXNlTG9vcCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZXJlIG1pZ2h0IGJlIGEgZHJpdmVyIGluaXRpYWxpemF0aW9uIGluIHByb2dyZXNzXG4gICAgICAgIC8vIHNvIHdhaXQgZm9yIGl0IHRvIGZpbmlzaCBpbiBvcmRlciB0byBhdm9pZCBhIHBvc3NpYmxlXG4gICAgICAgIC8vIHJhY2UgY29uZGl0aW9uIHRvIHNldCBfZGJJbmZvXG4gICAgICAgIHZhciBvbGREcml2ZXJTZXREb25lID0gdGhpcy5fZHJpdmVyU2V0ICE9PSBudWxsID8gdGhpcy5fZHJpdmVyU2V0W1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UkMS5yZXNvbHZlKCk7XG4gICAgICAgIH0pIDogUHJvbWlzZSQxLnJlc29sdmUoKTtcblxuICAgICAgICB0aGlzLl9kcml2ZXJTZXQgPSBvbGREcml2ZXJTZXREb25lLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRyaXZlck5hbWUgPSBzdXBwb3J0ZWREcml2ZXJzWzBdO1xuICAgICAgICAgICAgc2VsZi5fZGJJbmZvID0gbnVsbDtcbiAgICAgICAgICAgIHNlbGYuX3JlYWR5ID0gbnVsbDtcblxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0RHJpdmVyKGRyaXZlck5hbWUpLnRoZW4oZnVuY3Rpb24gKGRyaXZlcikge1xuICAgICAgICAgICAgICAgIHNlbGYuX2RyaXZlciA9IGRyaXZlci5fZHJpdmVyO1xuICAgICAgICAgICAgICAgIHNldERyaXZlclRvQ29uZmlnKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5fd3JhcExpYnJhcnlNZXRob2RzV2l0aFJlYWR5KCk7XG4gICAgICAgICAgICAgICAgc2VsZi5faW5pdERyaXZlciA9IGluaXREcml2ZXIoc3VwcG9ydGVkRHJpdmVycyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXREcml2ZXJUb0NvbmZpZygpO1xuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdObyBhdmFpbGFibGUgc3RvcmFnZSBtZXRob2QgZm91bmQuJyk7XG4gICAgICAgICAgICBzZWxmLl9kcml2ZXJTZXQgPSBQcm9taXNlJDEucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9kcml2ZXJTZXQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4ZWN1dGVUd29DYWxsYmFja3ModGhpcy5fZHJpdmVyU2V0LCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjayk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kcml2ZXJTZXQ7XG4gICAgfTtcblxuICAgIExvY2FsRm9yYWdlLnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIHN1cHBvcnRzKGRyaXZlck5hbWUpIHtcbiAgICAgICAgcmV0dXJuICEhRHJpdmVyU3VwcG9ydFtkcml2ZXJOYW1lXTtcbiAgICB9O1xuXG4gICAgTG9jYWxGb3JhZ2UucHJvdG90eXBlLl9leHRlbmQgPSBmdW5jdGlvbiBfZXh0ZW5kKGxpYnJhcnlNZXRob2RzQW5kUHJvcGVydGllcykge1xuICAgICAgICBleHRlbmQodGhpcywgbGlicmFyeU1ldGhvZHNBbmRQcm9wZXJ0aWVzKTtcbiAgICB9O1xuXG4gICAgTG9jYWxGb3JhZ2UucHJvdG90eXBlLl9nZXRTdXBwb3J0ZWREcml2ZXJzID0gZnVuY3Rpb24gX2dldFN1cHBvcnRlZERyaXZlcnMoZHJpdmVycykge1xuICAgICAgICB2YXIgc3VwcG9ydGVkRHJpdmVycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZHJpdmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGRyaXZlck5hbWUgPSBkcml2ZXJzW2ldO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHMoZHJpdmVyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBzdXBwb3J0ZWREcml2ZXJzLnB1c2goZHJpdmVyTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cHBvcnRlZERyaXZlcnM7XG4gICAgfTtcblxuICAgIExvY2FsRm9yYWdlLnByb3RvdHlwZS5fd3JhcExpYnJhcnlNZXRob2RzV2l0aFJlYWR5ID0gZnVuY3Rpb24gX3dyYXBMaWJyYXJ5TWV0aG9kc1dpdGhSZWFkeSgpIHtcbiAgICAgICAgLy8gQWRkIGEgc3R1YiBmb3IgZWFjaCBkcml2ZXIgQVBJIG1ldGhvZCB0aGF0IGRlbGF5cyB0aGUgY2FsbCB0byB0aGVcbiAgICAgICAgLy8gY29ycmVzcG9uZGluZyBkcml2ZXIgbWV0aG9kIHVudGlsIGxvY2FsRm9yYWdlIGlzIHJlYWR5LiBUaGVzZSBzdHVic1xuICAgICAgICAvLyB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBkcml2ZXIgbWV0aG9kcyBhcyBzb29uIGFzIHRoZSBkcml2ZXIgaXNcbiAgICAgICAgLy8gbG9hZGVkLCBzbyB0aGVyZSBpcyBubyBwZXJmb3JtYW5jZSBpbXBhY3QuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBMaWJyYXJ5TWV0aG9kcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY2FsbFdoZW5SZWFkeSh0aGlzLCBMaWJyYXJ5TWV0aG9kc1tpXSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTG9jYWxGb3JhZ2UucHJvdG90eXBlLmNyZWF0ZUluc3RhbmNlID0gZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2Uob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IExvY2FsRm9yYWdlKG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gTG9jYWxGb3JhZ2U7XG59KCk7XG5cbi8vIFRoZSBhY3R1YWwgbG9jYWxGb3JhZ2Ugb2JqZWN0IHRoYXQgd2UgZXhwb3NlIGFzIGEgbW9kdWxlIG9yIHZpYSBhXG4vLyBnbG9iYWwuIEl0J3MgZXh0ZW5kZWQgYnkgcHVsbGluZyBpbiBvbmUgb2Ygb3VyIG90aGVyIGxpYnJhcmllcy5cblxuXG52YXIgbG9jYWxmb3JhZ2VfanMgPSBuZXcgTG9jYWxGb3JhZ2UoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBsb2NhbGZvcmFnZV9qcztcblxufSx7XCIzXCI6M31dfSx7fSxbNF0pKDQpXG59KTtcbiIsICJpbXBvcnQge1xyXG4gICAgYWRkSWNvbiwgUGxhdGZvcm0sXHJcbiAgICBQbHVnaW5cclxufSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCB7REVGQVVMVF9TRVRUSU5HUywgUGxhbnRVTUxTZXR0aW5ncywgUGxhbnRVTUxTZXR0aW5nc1RhYn0gZnJvbSBcIi4vc2V0dGluZ3NcIjtcclxuaW1wb3J0IHtMb2NhbFByb2Nlc3NvcnN9IGZyb20gXCIuL3Byb2Nlc3NvcnMvbG9jYWxQcm9jZXNzb3JzXCI7XHJcbmltcG9ydCB7RGVib3VuY2VkUHJvY2Vzc29yc30gZnJvbSBcIi4vcHJvY2Vzc29ycy9kZWJvdW5jZWRQcm9jZXNzb3JzXCI7XHJcbmltcG9ydCB7TE9HT19TVkd9IGZyb20gXCIuL2NvbnN0XCI7XHJcbmltcG9ydCB7UHJvY2Vzc29yfSBmcm9tIFwiLi9wcm9jZXNzb3JzL3Byb2Nlc3NvclwiO1xyXG5pbXBvcnQge1NlcnZlclByb2Nlc3Nvcn0gZnJvbSBcIi4vcHJvY2Vzc29ycy9zZXJ2ZXJQcm9jZXNzb3JcIjtcclxuaW1wb3J0IHtSZXBsYWNlcn0gZnJvbSBcIi4vZnVuY3Rpb25zXCI7XHJcbmltcG9ydCB7UHVtbFZpZXcsIFZJRVdfVFlQRX0gZnJvbSBcIi4vUHVtbFZpZXdcIjtcclxuaW1wb3J0IGxvY2FsZm9yYWdlIGZyb20gXCJsb2NhbGZvcmFnZVwiO1xyXG5pbXBvcnQge1B1bWxFbWJlZH0gZnJvbSBcIi4vZW1iZWRcIjtcclxuXHJcbmRlY2xhcmUgbW9kdWxlIFwib2JzaWRpYW5cIiB7XHJcbiAgICBpbnRlcmZhY2UgV29ya3NwYWNlIHtcclxuICAgICAgICBvbihcclxuICAgICAgICAgICAgbmFtZTogXCJob3Zlci1saW5rXCIsXHJcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoZTogTW91c2VFdmVudCkgPT4gYW55LFxyXG4gICAgICAgICAgICBjdHg/OiBhbnksXHJcbiAgICAgICAgKTogRXZlbnRSZWY7XHJcbiAgICB9XHJcbiAgICBpbnRlcmZhY2UgQXBwIHtcclxuICAgICAgICBlbWJlZFJlZ2lzdHJ5OiBFbWJlZFJlZ2lzdHJ5O1xyXG4gICAgfVxyXG4gICAgaW50ZXJmYWNlIEVtYmVkUmVnaXN0cnkgZXh0ZW5kcyBFdmVudHMge1xyXG4gICAgICAgIHJlZ2lzdGVyRXh0ZW5zaW9ucyhleHRlbnNpb25zOiBzdHJpbmdbXSwgZW1iZWRDcmVhdG9yOiBFbWJlZENyZWF0b3IpOiB2b2lkO1xyXG4gICAgICAgIHVucmVnaXN0ZXJFeHRlbnNpb25zKGV4dGVuc2lvbnM6IHN0cmluZ1tdKTogdm9pZDtcclxuICAgIH1cclxuICAgIGludGVyZmFjZSBFbWJlZENoaWxkIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgICAgICBsb2FkRmlsZSgpOiBQcm9taXNlPHZvaWQ+O1xyXG4gICAgfVxyXG4gICAgdHlwZSBFbWJlZENyZWF0b3IgPSAoY29udGV4dDogRW1iZWRDb250ZXh0LCBmaWxlOiBURmlsZSwgcGF0aD86IHN0cmluZykgPT4gQ29tcG9uZW50O1xyXG4gICAgaW50ZXJmYWNlIEVtYmVkQ29udGV4dCB7XHJcbiAgICAgICAgYXBwOiBBcHA7XHJcbiAgICAgICAgY29udGFpbmVyRWw6IEhUTUxFbGVtZW50O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQbGFudHVtbFBsdWdpbiBleHRlbmRzIFBsdWdpbiB7XHJcbiAgICBzZXR0aW5nczogUGxhbnRVTUxTZXR0aW5ncztcclxuXHJcbiAgICBzZXJ2ZXJQcm9jZXNzb3I6IFByb2Nlc3NvcjtcclxuICAgIGxvY2FsUHJvY2Vzc29yOiBQcm9jZXNzb3I7XHJcbiAgICByZXBsYWNlcjogUmVwbGFjZXI7XHJcblxyXG4gICAgb2JzZXJ2ZXI6IE11dGF0aW9uT2JzZXJ2ZXI7XHJcblxyXG4gICAgcHVibGljIGhvdmVyOiB7XHJcbiAgICAgICAgbGlua1RleHQ6IHN0cmluZztcclxuICAgICAgICBzb3VyY2VQYXRoOiBzdHJpbmc7XHJcbiAgICB9ID0ge1xyXG4gICAgICAgIGxpbmtUZXh0OiBudWxsLFxyXG4gICAgICAgIHNvdXJjZVBhdGg6IG51bGwsXHJcbiAgICB9O1xyXG5cclxuICAgIGdldFByb2Nlc3NvcigpOiBQcm9jZXNzb3Ige1xyXG4gICAgICAgIGlmIChQbGF0Zm9ybS5pc01vYmlsZUFwcCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJ2ZXJQcm9jZXNzb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmxvY2FsSmFyLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxQcm9jZXNzb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZlclByb2Nlc3NvcjtcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBvbmxvYWQoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ2xvYWRpbmcgcGx1Z2luIHBsYW50dW1sJyk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcclxuICAgICAgICB0aGlzLmFkZFNldHRpbmdUYWIobmV3IFBsYW50VU1MU2V0dGluZ3NUYWIodGhpcykpO1xyXG4gICAgICAgIHRoaXMucmVwbGFjZXIgPSBuZXcgUmVwbGFjZXIodGhpcyk7XHJcblxyXG4gICAgICAgIHRoaXMuc2VydmVyUHJvY2Vzc29yID0gbmV3IFNlcnZlclByb2Nlc3Nvcih0aGlzKTtcclxuICAgICAgICBpZiAoUGxhdGZvcm0uaXNEZXNrdG9wQXBwKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9jYWxQcm9jZXNzb3IgPSBuZXcgTG9jYWxQcm9jZXNzb3JzKHRoaXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgcHJvY2Vzc29yID0gbmV3IERlYm91bmNlZFByb2Nlc3NvcnModGhpcyk7XHJcblxyXG4gICAgICAgIGFkZEljb24oXCJkb2N1bWVudC1cIiArIFZJRVdfVFlQRSwgTE9HT19TVkcpO1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJWaWV3KFZJRVdfVFlQRSwgKGxlYWYpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQdW1sVmlldyhsZWFmLCB0aGlzKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnJlZ2lzdGVyRXh0ZW5zaW9ucyhbXCJwdW1sXCIsIFwicHVcIl0sIFZJRVdfVFlQRSk7XHJcblxyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJNYXJrZG93bkNvZGVCbG9ja1Byb2Nlc3NvcihcInBsYW50dW1sXCIsIHByb2Nlc3Nvci5kZWZhdWx0KTtcclxuICAgICAgICB0aGlzLnJlZ2lzdGVyTWFya2Rvd25Db2RlQmxvY2tQcm9jZXNzb3IoXCJwbGFudHVtbC1wbmdcIiwgcHJvY2Vzc29yLnBuZyk7XHJcbiAgICAgICAgdGhpcy5yZWdpc3Rlck1hcmtkb3duQ29kZUJsb2NrUHJvY2Vzc29yKFwicGxhbnR1bWwtYXNjaWlcIiwgcHJvY2Vzc29yLmFzY2lpKTtcclxuICAgICAgICB0aGlzLnJlZ2lzdGVyTWFya2Rvd25Db2RlQmxvY2tQcm9jZXNzb3IoXCJwbGFudHVtbC1zdmdcIiwgcHJvY2Vzc29yLnN2Zyk7XHJcbiAgICAgICAgdGhpcy5yZWdpc3Rlck1hcmtkb3duQ29kZUJsb2NrUHJvY2Vzc29yKFwicHVtbFwiLCBwcm9jZXNzb3IuZGVmYXVsdCk7XHJcbiAgICAgICAgdGhpcy5yZWdpc3Rlck1hcmtkb3duQ29kZUJsb2NrUHJvY2Vzc29yKFwicHVtbC1wbmdcIiwgcHJvY2Vzc29yLnBuZyk7XHJcbiAgICAgICAgdGhpcy5yZWdpc3Rlck1hcmtkb3duQ29kZUJsb2NrUHJvY2Vzc29yKFwicHVtbC1zdmdcIiwgcHJvY2Vzc29yLnN2Zyk7XHJcbiAgICAgICAgdGhpcy5yZWdpc3Rlck1hcmtkb3duQ29kZUJsb2NrUHJvY2Vzc29yKFwicHVtbC1hc2NpaVwiLCBwcm9jZXNzb3IuYXNjaWkpO1xyXG5cclxuICAgICAgICAvL2tlZXAgdGhpcyBwcm9jZXNzb3IgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcbiAgICAgICAgdGhpcy5yZWdpc3Rlck1hcmtkb3duQ29kZUJsb2NrUHJvY2Vzc29yKFwicGxhbnR1bWwtbWFwXCIsIHByb2Nlc3Nvci5wbmcpO1xyXG5cclxuICAgICAgICB0aGlzLmFwcC5lbWJlZFJlZ2lzdHJ5LnJlZ2lzdGVyRXh0ZW5zaW9ucyhbJ3B1bWwnLCAncHUnXSwgKGN0eCwgZmlsZSwgc3VicGF0aCkgPT4gbmV3IFB1bWxFbWJlZCh0aGlzLCBmaWxlLCBjdHgpKTtcclxuXHJcbiAgICAgICAgdGhpcy5jbGVhbnVwTG9jYWxTdG9yYWdlKCk7XHJcbiAgICAgICAgbG9jYWxmb3JhZ2UuY29uZmlnKHtcclxuICAgICAgICAgICAgbmFtZTogJ3B1bWwnLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1BsYW50VU1MIHBsdWdpbidcclxuICAgICAgICB9KTtcclxuICAgICAgICBhd2FpdCB0aGlzLmNsZWFudXBDYWNoZSgpO1xyXG5cclxuXHJcbiAgICAgICAgLy9pbnRlcm5hbCBsaW5rc1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihhc3luYyAobXV0YXRpb24pID0+IHtcclxuICAgICAgICAgICAgaWYgKG11dGF0aW9uLmxlbmd0aCAhPT0gMSkgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZiAobXV0YXRpb25bMF0uYWRkZWROb2Rlcy5sZW5ndGggIT09IDEpIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaG92ZXIubGlua1RleHQgPT09IG51bGwpIHJldHVybjtcclxuICAgICAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgICAgIGlmIChtdXRhdGlvblswXS5hZGRlZE5vZGVzWzBdLmNsYXNzTmFtZSAhPT0gXCJwb3BvdmVyIGhvdmVyLXBvcG92ZXIgZmlsZS1lbWJlZCBpcy1sb2FkZWRcIikgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QodGhpcy5ob3Zlci5saW5rVGV4dCwgdGhpcy5ob3Zlci5zb3VyY2VQYXRoKTtcclxuICAgICAgICAgICAgaWYgKCFmaWxlKSByZXR1cm47XHJcbiAgICAgICAgICAgIGlmIChmaWxlLmV4dGVuc2lvbiAhPT0gXCJwdW1sXCIgJiYgZmlsZS5leHRlbnNpb24gIT09IFwicHVcIikgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgZmlsZUNvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGZpbGUpO1xyXG4gICAgICAgICAgICBjb25zdCBpbWdEaXYgPSBjcmVhdGVEaXYoKTtcclxuICAgICAgICAgICAgaWYodGhpcy5zZXR0aW5ncy5kZWZhdWx0UHJvY2Vzc29yID09PSBcInBuZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmdldFByb2Nlc3NvcigpLnBuZyhmaWxlQ29udGVudCwgaW1nRGl2LCBudWxsKTtcclxuICAgICAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5nZXRQcm9jZXNzb3IoKS5zdmcoZmlsZUNvbnRlbnQsIGltZ0RpdiwgbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGU6IE5vZGUgPSBtdXRhdGlvblswXS5hZGRlZE5vZGVzWzBdO1xyXG4gICAgICAgICAgICBub2RlLmVtcHR5KCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBkaXYgPSBjcmVhdGVEaXYoXCJcIiwgYXN5bmMgKGVsZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoaW1nRGl2KTtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdzcmMnLCBmaWxlLnBhdGgpO1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5vbkNsaWNrRXZlbnQoKGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZWFmID0gdGhpcy5hcHAud29ya3NwYWNlLmdldExlYWYoZXZlbnQuY3RybEtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVhZi5zZXRWaWV3U3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBWSUVXX1RZUEUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiB7ZmlsZTogZmlsZS5wYXRofVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGRpdik7XHJcblxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnJlZ2lzdGVyRXZlbnQodGhpcy5hcHAud29ya3NwYWNlLm9uKFwiaG92ZXItbGlua1wiLCBhc3luYyAoZXZlbnQ6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBsaW5rVGV4dDogc3RyaW5nID0gZXZlbnQubGlua3RleHQ7XHJcbiAgICAgICAgICAgIGlmICghbGlua1RleHQpIHJldHVybjtcclxuICAgICAgICAgICAgY29uc3Qgc291cmNlUGF0aDogc3RyaW5nID0gZXZlbnQuc291cmNlUGF0aDtcclxuXHJcbiAgICAgICAgICAgIGlmICghbGlua1RleHQuZW5kc1dpdGgoXCIucHVtbFwiKSAmJiAhbGlua1RleHQuZW5kc1dpdGgoXCIucHVcIikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5ob3Zlci5saW5rVGV4dCA9IGxpbmtUZXh0O1xyXG4gICAgICAgICAgICB0aGlzLmhvdmVyLnNvdXJjZVBhdGggPSBzb3VyY2VQYXRoO1xyXG4gICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgdGhpcy5vYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlfSk7XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgY2xlYW51cENhY2hlKCkge1xyXG4gICAgICAgIGF3YWl0IGxvY2FsZm9yYWdlLml0ZXJhdGUoKHZhbHVlLCBrZXkpID0+IHtcclxuICAgICAgICAgICAgaWYoa2V5LnN0YXJ0c1dpdGgoJ3RzLScpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVkID0ga2V5LnNwbGl0KCctJylbMV07XHJcbiAgICAgICAgICAgICAgICBpZih2YWx1ZSA8IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gKHRoaXMuc2V0dGluZ3MuY2FjaGUgKiAyNCAqIDYwICogNjAgKiAxMDAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZm9yYWdlLnJlbW92ZUl0ZW0oJ3BuZy0nICsgZW5jb2RlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxmb3JhZ2UucmVtb3ZlSXRlbSgnc3ZnLScgKyBlbmNvZGVkKTtcclxuICAgICAgICAgICAgICAgICAgICBsb2NhbGZvcmFnZS5yZW1vdmVJdGVtKCdtYXAtJyArIGVuY29kZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZm9yYWdlLnJlbW92ZUl0ZW0oJ2FzY2lpLScgKyBlbmNvZGVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBvbGRlciB2ZXJzaW9ucyB1c2VkIHRvIHN0b3JlIGdlbmVyYXRlZCBpbWFnZXMgaW4gbG9jYWwgc3RvcmFnZSB3aGVuIHVzaW5nIGxvY2FsIGdlbmVyYXRpb24uXHJcbiAgICAgKiBUbyBmaXggaXNzdWVzIHdpdGggdGhlIGxvY2FsIHN0b3JhZ2UgcXVvdGEgd2UgaGF2ZSB0byBjbGVhbiB0aGlzIHVwIHdoZW4gdXBncmFkaW5nIGZyb20gYSB2ZXJzaW9uIHRoYXQgc3VwcG9ydGVkIHRoaXMuXHJcbiAgICAgKi9cclxuICAgIGNsZWFudXBMb2NhbFN0b3JhZ2UoKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobG9jYWxTdG9yYWdlKSkge1xyXG4gICAgICAgICAgICBpZihrZXkuZW5kc1dpdGgoJy1tYXAnKSB8fCBrZXkuZW5kc1dpdGgoJy1wbmcnKSB8fCBrZXkuZW5kc1dpdGgoJy1zdmcnKSB8fCBrZXkuZW5kc1dpdGgoJ2FzY2lpJykpIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgb251bmxvYWQoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ3VubG9hZGluZyBwbHVnaW4gcGxhbnR1bWwnKTtcclxuICAgICAgICB0aGlzLm9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICB0aGlzLmFwcC5lbWJlZFJlZ2lzdHJ5LnVucmVnaXN0ZXJFeHRlbnNpb25zKFsncHVtbCcsICdwdSddKTtcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBsb2FkU2V0dGluZ3MoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIGF3YWl0IHRoaXMubG9hZERhdGEoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgc2F2ZVNldHRpbmdzKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgb25FeHRlcm5hbFNldHRpbmdzQ2hhbmdlKCkge1xyXG4gICAgICAgIGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XHJcbiAgICB9XHJcbn1cclxuIiwgImltcG9ydCB7IE5vdGljZSwgUGxhdGZvcm0sIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IFBsYW50dW1sUGx1Z2luIGZyb20gXCIuL21haW5cIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUGxhbnRVTUxTZXR0aW5ncyB7XHJcbiAgICBzZXJ2ZXJfdXJsOiBzdHJpbmcsXHJcbiAgICBoZWFkZXI6IHN0cmluZztcclxuICAgIGRlYm91bmNlOiBudW1iZXI7XHJcbiAgICBsb2NhbEphcjogc3RyaW5nO1xyXG4gICAgamF2YVBhdGg6IHN0cmluZztcclxuICAgIGRvdFBhdGg6IHN0cmluZztcclxuICAgIGRlZmF1bHRQcm9jZXNzb3I6IHN0cmluZztcclxuICAgIGNhY2hlOiBudW1iZXI7XHJcbiAgICBleHBvcnRQYXRoOiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX1NFVFRJTkdTOiBQbGFudFVNTFNldHRpbmdzID0ge1xyXG4gICAgc2VydmVyX3VybDogJ2h0dHBzOi8vd3d3LnBsYW50dW1sLmNvbS9wbGFudHVtbCcsXHJcbiAgICBoZWFkZXI6ICcnLFxyXG4gICAgZGVib3VuY2U6IDMsXHJcbiAgICBsb2NhbEphcjogJycsXHJcbiAgICBqYXZhUGF0aDogJ2phdmEnLFxyXG4gICAgZG90UGF0aDogJ2RvdCcsXHJcbiAgICBkZWZhdWx0UHJvY2Vzc29yOiBcInBuZ1wiLFxyXG4gICAgY2FjaGU6IDYwLFxyXG4gICAgZXhwb3J0UGF0aDogJydcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFBsYW50VU1MU2V0dGluZ3NUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcclxuICAgIHBsdWdpbjogUGxhbnR1bWxQbHVnaW47XHJcblxyXG4gICAgY29uc3RydWN0b3IocGx1Z2luOiBQbGFudHVtbFBsdWdpbikge1xyXG4gICAgICAgIHN1cGVyKHBsdWdpbi5hcHAsIHBsdWdpbik7XHJcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgICB9XHJcblxyXG4gICAgZGlzcGxheSgpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCB7Y29udGFpbmVyRWx9ID0gdGhpcztcclxuXHJcbiAgICAgICAgY29udGFpbmVyRWwuZW1wdHkoKTtcclxuXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldE5hbWUoXCJTZXJ2ZXIgVVJMXCIpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKFwiUGxhbnRVTUwgU2VydmVyIFVSTFwiKVxyXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHQuc2V0UGxhY2Vob2xkZXIoREVGQVVMVF9TRVRUSU5HUy5zZXJ2ZXJfdXJsKVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnNlcnZlcl91cmwpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnNlcnZlcl91cmwgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICBpZihQbGF0Zm9ybS5pc0Rlc2t0b3BBcHApIHtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGphckRlc2MgPSBuZXcgRG9jdW1lbnRGcmFnbWVudCgpO1xyXG4gICAgICAgICAgICBqYXJEZXNjLmNyZWF0ZURpdigpLmlubmVySFRNTCA9IFwiUGF0aCB0byBsb2NhbCBKQVI8YnI+U3VwcG9ydHM6XCIgK1xyXG4gICAgICAgICAgICAgICAgXCI8dWw+XCIgK1xyXG4gICAgICAgICAgICAgICAgXCI8bGk+QWJzb2x1dGUgcGF0aDwvbGk+XCIgK1xyXG4gICAgICAgICAgICAgICAgXCI8bGk+UGF0aCByZWxhdGl2ZSB0byB2YXVsdDwvbGk+XCIgK1xyXG4gICAgICAgICAgICAgICAgXCI8bGk+UGF0aCByZWxhdGl2ZSB0byB1c2VycyBob21lIGRpcmVjdG9yeSA8Y29kZT5+LzwvY29kZT48L2xpPlwiICtcclxuICAgICAgICAgICAgICAgIFwiPC91bD5cIjtcclxuXHJcbiAgICAgICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAgICAgLnNldE5hbWUoXCJMb2NhbCBKQVJcIilcclxuICAgICAgICAgICAgICAgIC5zZXREZXNjKGphckRlc2MpXHJcbiAgICAgICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHQuc2V0UGxhY2Vob2xkZXIoREVGQVVMVF9TRVRUSU5HUy5sb2NhbEphcilcclxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MubG9jYWxKYXIpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MubG9jYWxKYXIgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAgICAgLnNldE5hbWUoXCJKYXZhIHBhdGhcIilcclxuICAgICAgICAgICAgICAgIC5zZXREZXNjKFwiUGF0aCB0byBKYXZhIGV4ZWN1dGFibGVcIilcclxuICAgICAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dC5zZXRQbGFjZWhvbGRlcihERUZBVUxUX1NFVFRJTkdTLmphdmFQYXRoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5qYXZhUGF0aClcclxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5qYXZhUGF0aCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgICAgICAuc2V0TmFtZShcIkRvdCBwYXRoXCIpXHJcbiAgICAgICAgICAgICAgICAuc2V0RGVzYyhcIlBhdGggdG8gZG90IGV4ZWN1dGFibGVcIilcclxuICAgICAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dC5zZXRQbGFjZWhvbGRlcihERUZBVUxUX1NFVFRJTkdTLmRvdFBhdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmRvdFBhdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZG90UGF0aCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgICAgICAuc2V0TmFtZShcIkRpYWdyYW0gZXhwb3J0IHBhdGhcIilcclxuICAgICAgICAgICAgICAgIC5zZXREZXNjKFwiUGF0aCB3aGVyZSBleHBvcnRlZCBkaWFncmFtcyB3aWxsIGJlIHNhdmVkIHJlbGF0aXZlIHRvIHRoZSB2YXVsdCByb290LiBMZWF2ZSBibGFuayB0byBzYXZlIGFsb25nIHNpZGUgdGhlIG5vdGUuXCIpXHJcbiAgICAgICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHQuc2V0UGxhY2Vob2xkZXIoREVGQVVMVF9TRVRUSU5HUy5leHBvcnRQYXRoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5leHBvcnRQYXRoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmV4cG9ydFBhdGggPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAuc2V0TmFtZShcIkRlZmF1bHQgcHJvY2Vzc29yIGZvciBpbmNsdWRlc1wiKVxyXG4gICAgICAgICAgICAuc2V0RGVzYyhcIkFueSAucHUvLnB1bWwgZmlsZXMgbGlua2VkIHdpbGwgdXNlIHRoaXMgcHJvY2Vzc29yXCIpXHJcbiAgICAgICAgICAgIC5hZGREcm9wZG93bihkcm9wZG93biA9PiB7XHJcbiAgICAgICAgICAgICAgIGRyb3Bkb3duXHJcbiAgICAgICAgICAgICAgICAgICAuYWRkT3B0aW9uKFwicG5nXCIsIFwiUE5HXCIpXHJcbiAgICAgICAgICAgICAgICAgICAuYWRkT3B0aW9uKFwic3ZnXCIsIFwiU1ZHXCIpXHJcbiAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZGVmYXVsdFByb2Nlc3NvcilcclxuICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZGVmYXVsdFByb2Nlc3NvciA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKS5zZXROYW1lKFwiSGVhZGVyXCIpXHJcbiAgICAgICAgICAgIC5zZXREZXNjKFwiSW5jbHVkZWQgYXQgdGhlIGhlYWQgaW4gZXZlcnkgZGlhZ3JhbS4gVXNlZnVsIGZvciBzcGVjaWZ5aW5nIGEgY29tbW9uIHRoZW1lICgucHVtbCBmaWxlKVwiKVxyXG4gICAgICAgICAgICAuYWRkVGV4dEFyZWEodGV4dCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dC5zZXRQbGFjZWhvbGRlcihcIiFpbmNsdWRlIGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS8uLi4ucHVtbFxcblwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuaGVhZGVyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuaGVhZGVyID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0LmlucHV0RWwuc2V0QXR0cihcInJvd3NcIiwgNCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dC5pbnB1dEVsLmFkZENsYXNzKFwicHVtbC1zZXR0aW5ncy1hcmVhXCIpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxyXG4gICAgICAgICAgICAuc2V0TmFtZSgnQ2FjaGUnKVxyXG4gICAgICAgICAgICAuc2V0RGVzYygnaW4gZGF5cy4gT25seSBhcHBsaWNhYmxlIHdoZW4gZ2VuZXJhdGluZyBkaWFncmFtcyBsb2NhbGx5JylcclxuICAgICAgICAgICAgLmFkZFNsaWRlcihzbGlkZXIgPT4ge1xyXG4gICAgICAgICAgICAgICAgc2xpZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldExpbWl0cygxMCwgMzYwLCAxMClcclxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuY2FjaGUpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNldER5bmFtaWNUb29sdGlwKClcclxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgdmFsdWUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5jYWNoZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcbiAgICAgICAgICAgIC5zZXROYW1lKFwiRGVib3VuY2VcIilcclxuICAgICAgICAgICAgLnNldERlc2MoXCJIb3cgb2Z0ZW4gc2hvdWxkIHRoZSBkaWFncmFtIHJlZnJlc2ggaW4gc2Vjb25kc1wiKVxyXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHQuc2V0UGxhY2Vob2xkZXIoU3RyaW5nKERFRkFVTFRfU0VUVElOR1MuZGVib3VuY2UpKVxyXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKFN0cmluZyh0aGlzLnBsdWdpbi5zZXR0aW5ncy5kZWJvdW5jZSkpXHJcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9tYWtlIHN1cmUgdGhhdCB0aGVyZSBpcyBhbHdheXMgc29tZSB2YWx1ZSBkZWZpbmVkLCBvciByZXNldCB0byBkZWZhdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTihOdW1iZXIodmFsdWUpKSB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmRlYm91bmNlID0gTnVtYmVyKHZhbHVlIHx8IERFRkFVTFRfU0VUVElOR1MuZGVib3VuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKFwiUGxlYXNlIHNwZWNpZnkgYSB2YWxpZCBudW1iZXJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgfVxyXG59XHJcbiIsICJpbXBvcnQgUGxhbnR1bWxQbHVnaW4gZnJvbSBcIi4uL21haW5cIjtcclxuaW1wb3J0IHtQcm9jZXNzb3J9IGZyb20gXCIuL3Byb2Nlc3NvclwiO1xyXG5pbXBvcnQge01hcmtkb3duUG9zdFByb2Nlc3NvckNvbnRleHQsIG1vbWVudH0gZnJvbSBcIm9ic2lkaWFuXCI7XHJcbmltcG9ydCAqIGFzIHBsYW50dW1sIGZyb20gXCJwbGFudHVtbC1lbmNvZGVyXCI7XHJcbmltcG9ydCB7aW5zZXJ0QXNjaWlJbWFnZSwgaW5zZXJ0SW1hZ2VXaXRoTWFwLCBpbnNlcnRTdmdJbWFnZX0gZnJvbSBcIi4uL2Z1bmN0aW9uc1wiO1xyXG5pbXBvcnQge091dHB1dFR5cGV9IGZyb20gXCIuLi9jb25zdFwiO1xyXG5pbXBvcnQgKiBhcyBsb2NhbGZvcmFnZSBmcm9tIFwibG9jYWxmb3JhZ2VcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBMb2NhbFByb2Nlc3NvcnMgaW1wbGVtZW50cyBQcm9jZXNzb3Ige1xyXG5cclxuICAgIHBsdWdpbjogUGxhbnR1bWxQbHVnaW47XHJcblxyXG4gICAgY29uc3RydWN0b3IocGx1Z2luOiBQbGFudHVtbFBsdWdpbikge1xyXG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xyXG4gICAgfVxyXG5cclxuICAgIGFzY2lpID0gYXN5bmMoc291cmNlOiBzdHJpbmcsIGVsOiBIVE1MRWxlbWVudCwgY3R4OiBNYXJrZG93blBvc3RQcm9jZXNzb3JDb250ZXh0KSA9PiB7XHJcbiAgICAgICAgY29uc3QgZW5jb2RlZERpYWdyYW0gPSBwbGFudHVtbC5lbmNvZGUoc291cmNlKTtcclxuICAgICAgICBjb25zdCBpdGVtOiBzdHJpbmcgPSBhd2FpdCBsb2NhbGZvcmFnZS5nZXRJdGVtKCdhc2NpaS0nICsgZW5jb2RlZERpYWdyYW0pO1xyXG4gICAgICAgIGlmKGl0ZW0pIHtcclxuICAgICAgICAgICAgaW5zZXJ0QXNjaWlJbWFnZShlbCwgaXRlbSk7XHJcbiAgICAgICAgICAgIGF3YWl0IGxvY2FsZm9yYWdlLnNldEl0ZW0oJ3RzLScgKyBlbmNvZGVkRGlhZ3JhbSwgRGF0ZS5ub3coKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGltYWdlID0gYXdhaXQgdGhpcy5nZW5lcmF0ZUxvY2FsSW1hZ2Uoc291cmNlLCBPdXRwdXRUeXBlLkFTQ0lJLCB0aGlzLnBsdWdpbi5yZXBsYWNlci5nZXRQYXRoKGN0eCkpO1xyXG4gICAgICAgIGluc2VydEFzY2lpSW1hZ2UoZWwsIGltYWdlKTtcclxuICAgICAgICBhd2FpdCBsb2NhbGZvcmFnZS5zZXRJdGVtKCdhc2NpaS0nICsgZW5jb2RlZERpYWdyYW0sIGltYWdlKTtcclxuICAgICAgICBhd2FpdCBsb2NhbGZvcmFnZS5zZXRJdGVtKCd0cy0nICsgZW5jb2RlZERpYWdyYW0sIERhdGUubm93KCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHBuZyA9IGFzeW5jKHNvdXJjZTogc3RyaW5nLCBlbDogSFRNTEVsZW1lbnQsIGN0eDogTWFya2Rvd25Qb3N0UHJvY2Vzc29yQ29udGV4dCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGVuY29kZWREaWFncmFtID0gcGxhbnR1bWwuZW5jb2RlKHNvdXJjZSk7XHJcbiAgICAgICAgY29uc3QgaXRlbTogc3RyaW5nID0gYXdhaXQgbG9jYWxmb3JhZ2UuZ2V0SXRlbSgncG5nLScgKyBlbmNvZGVkRGlhZ3JhbSk7XHJcbiAgICAgICAgaWYoaXRlbSkge1xyXG4gICAgICAgICAgICBjb25zdCBtYXA6IHN0cmluZyA9IGF3YWl0IGxvY2FsZm9yYWdlLmdldEl0ZW0oJ21hcC0nICsgZW5jb2RlZERpYWdyYW0pO1xyXG4gICAgICAgICAgICBpbnNlcnRJbWFnZVdpdGhNYXAoZWwsIGl0ZW0gLCBtYXAsIGVuY29kZWREaWFncmFtKTtcclxuICAgICAgICAgICAgYXdhaXQgbG9jYWxmb3JhZ2Uuc2V0SXRlbSgndHMtJyArIGVuY29kZWREaWFncmFtLCBEYXRlLm5vdygpKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMucGx1Z2luLnJlcGxhY2VyLmdldFBhdGgoY3R4KTtcclxuICAgICAgICBjb25zdCBpbWFnZSA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVMb2NhbEltYWdlKHNvdXJjZSwgT3V0cHV0VHlwZS5QTkcsIHBhdGgpO1xyXG4gICAgICAgIGNvbnN0IG1hcCA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVMb2NhbE1hcChzb3VyY2UsIHBhdGgpO1xyXG5cclxuICAgICAgICBhd2FpdCBsb2NhbGZvcmFnZS5zZXRJdGVtKCdwbmctJyArIGVuY29kZWREaWFncmFtLCBpbWFnZSk7XHJcbiAgICAgICAgYXdhaXQgbG9jYWxmb3JhZ2Uuc2V0SXRlbSgnbWFwLScgKyBlbmNvZGVkRGlhZ3JhbSwgbWFwKTtcclxuICAgICAgICBhd2FpdCBsb2NhbGZvcmFnZS5zZXRJdGVtKCd0cy0nKyBlbmNvZGVkRGlhZ3JhbSwgRGF0ZS5ub3coKSk7XHJcblxyXG4gICAgICAgIGluc2VydEltYWdlV2l0aE1hcChlbCwgaW1hZ2UsIG1hcCwgZW5jb2RlZERpYWdyYW0pO1xyXG4gICAgfVxyXG5cclxuICAgIHN2ZyA9IGFzeW5jKHNvdXJjZTogc3RyaW5nLCBlbDogSFRNTEVsZW1lbnQsIGN0eDogTWFya2Rvd25Qb3N0UHJvY2Vzc29yQ29udGV4dCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGVuY29kZWREaWFncmFtID0gcGxhbnR1bWwuZW5jb2RlKHNvdXJjZSk7XHJcbiAgICAgICAgY29uc3QgaXRlbTogc3RyaW5nID0gYXdhaXQgbG9jYWxmb3JhZ2UuZ2V0SXRlbSgnc3ZnLScgKyBlbmNvZGVkRGlhZ3JhbSk7XHJcbiAgICAgICAgaWYoaXRlbSkge1xyXG4gICAgICAgICAgICBpbnNlcnRTdmdJbWFnZShlbCwgaXRlbSk7XHJcbiAgICAgICAgICAgIGF3YWl0IGxvY2FsZm9yYWdlLnNldEl0ZW0oJ3RzLScgKyBlbmNvZGVkRGlhZ3JhbSwgRGF0ZS5ub3coKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBhd2FpdCB0aGlzLmdlbmVyYXRlTG9jYWxJbWFnZShzb3VyY2UsIE91dHB1dFR5cGUuU1ZHLCB0aGlzLnBsdWdpbi5yZXBsYWNlci5nZXRQYXRoKGN0eCkpO1xyXG4gICAgICAgIGF3YWl0IGxvY2FsZm9yYWdlLnNldEl0ZW0oJ3N2Zy0nICsgZW5jb2RlZERpYWdyYW0sIGltYWdlKTtcclxuICAgICAgICBhd2FpdCBsb2NhbGZvcmFnZS5zZXRJdGVtKCd0cy0nICsgZW5jb2RlZERpYWdyYW0sIERhdGUubm93KCkpO1xyXG4gICAgICAgIGluc2VydFN2Z0ltYWdlKGVsLCBpbWFnZSk7XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgZ2VuZXJhdGVMb2NhbE1hcChzb3VyY2U6IHN0cmluZywgcGF0aDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICAgICAgICBjb25zdCB7ZXhlY30gPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJyk7XHJcbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMucmVzb2x2ZUxvY2FsSmFyQ21kKCkuY29uY2F0KFsnLXBpcGVtYXAnXSk7XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSBleGVjKGFyZ3Muam9pbihcIiBcIiksIHtlbmNvZGluZzogJ2JpbmFyeScsIGN3ZDogcGF0aH0pO1xyXG5cclxuICAgICAgICBsZXQgc3Rkb3V0ID0gXCJcIjtcclxuXHJcbiAgICAgICAgaWYgKGNoaWxkLnN0ZG91dCkge1xyXG4gICAgICAgICAgICBjaGlsZC5zdGRvdXQub24oXCJkYXRhXCIsIChkYXRhOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgICAgIHN0ZG91dCArPSBkYXRhO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGNoaWxkLm9uKFwiZXJyb3JcIiwgcmVqZWN0KTtcclxuXHJcbiAgICAgICAgICAgIGNoaWxkLm9uKFwiY2xvc2VcIiwgKGNvZGU6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHN0ZG91dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coc3Rkb3V0KTtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBhbiBlcnJvciBvY2N1cnJlZGApKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgY2hpbGQgZXhpdGVkIHdpdGggY29kZSAke2NvZGV9YCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNoaWxkLnN0ZGluLndyaXRlKHNvdXJjZSk7XHJcbiAgICAgICAgICAgIGNoaWxkLnN0ZGluLmVuZCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGdlbmVyYXRlTG9jYWxJbWFnZShzb3VyY2U6IHN0cmluZywgdHlwZTogT3V0cHV0VHlwZSwgcGF0aDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICAgICAgICBjb25zdCB7Q2hpbGRQcm9jZXNzLCBleGVjfSA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKTtcclxuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5yZXNvbHZlTG9jYWxKYXJDbWQoKS5jb25jYXQoWyctdCcgKyB0eXBlLCAnLXBpcGUnXSk7XHJcblxyXG4gICAgICAgIGxldCBjaGlsZDogdHlwZW9mIENoaWxkUHJvY2VzcztcclxuICAgICAgICBpZiAodHlwZSA9PT0gT3V0cHV0VHlwZS5QTkcpIHtcclxuICAgICAgICAgICAgY2hpbGQgPSBleGVjKGFyZ3Muam9pbihcIiBcIiksIHtlbmNvZGluZzogJ2JpbmFyeScsIGN3ZDogcGF0aH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNoaWxkID0gZXhlYyhhcmdzLmpvaW4oXCIgXCIpLCB7ZW5jb2Rpbmc6ICd1dGYtOCcsIGN3ZDogcGF0aH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHN0ZG91dDogYW55O1xyXG4gICAgICAgIGxldCBzdGRlcnI6IGFueTtcclxuXHJcbiAgICAgICAgaWYgKGNoaWxkLnN0ZG91dCkge1xyXG4gICAgICAgICAgICBjaGlsZC5zdGRvdXQub24oXCJkYXRhXCIsIChkYXRhOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChzdGRvdXQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ZG91dCA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Ugc3Rkb3V0ICs9IGRhdGE7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNoaWxkLnN0ZGVycikge1xyXG4gICAgICAgICAgICBjaGlsZC5zdGRlcnIub24oJ2RhdGEnLCAoZGF0YTogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RkZXJyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGRlcnIgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHN0ZGVyciArPSBkYXRhO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGNoaWxkLm9uKFwiZXJyb3JcIiwgcmVqZWN0KTtcclxuXHJcbiAgICAgICAgICAgIGNoaWxkLm9uKFwiY2xvc2VcIiwgKGNvZGU6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYoc3Rkb3V0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBPdXRwdXRUeXBlLlBORykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBidWYgPSBuZXcgQnVmZmVyKHN0ZG91dCwgJ2JpbmFyeScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGJ1Zi50b1N0cmluZygnYmFzZTY0JykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc3Rkb3V0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHN0ZG91dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihzdGRlcnIpKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IE91dHB1dFR5cGUuUE5HKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IG5ldyBCdWZmZXIoc3Rkb3V0LCAnYmluYXJ5Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYnVmLnRvU3RyaW5nKCdiYXNlNjQnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzdGRvdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNoaWxkLnN0ZGluLndyaXRlKHNvdXJjZSwgXCJ1dGYtOFwiKTtcclxuICAgICAgICAgICAgY2hpbGQuc3RkaW4uZW5kKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUbyBzdXBwb3J0IGxvY2FsIGphciBzZXR0aW5ncyB3aXRoIHVuaXgtbGlrZSBzdHlsZSwgYW5kIHNlYXJjaCBsb2NhbCBqYXIgZmlsZVxyXG4gICAgICogZnJvbSBjdXJyZW50IHZhdWx0IHBhdGguXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgcmVzb2x2ZUxvY2FsSmFyQ21kKCk6IHN0cmluZ1tdIHtcclxuICAgICAgICBjb25zdCBqYXJGcm9tU2V0dGluZ3MgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5sb2NhbEphcjtcclxuICAgICAgICBjb25zdCB7aXNBYnNvbHV0ZSwgcmVzb2x2ZX0gPSByZXF1aXJlKCdwYXRoJyk7XHJcbiAgICAgICAgY29uc3Qge3VzZXJJbmZvfSA9IHJlcXVpcmUoJ29zJyk7XHJcbiAgICAgICAgbGV0IGphckZ1bGxQYXRoOiBzdHJpbmc7XHJcbiAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMucGx1Z2luLnJlcGxhY2VyLmdldEZ1bGxQYXRoKFwiXCIpO1xyXG5cclxuICAgICAgICBpZiAoamFyRnJvbVNldHRpbmdzWzBdID09PSAnficpIHtcclxuICAgICAgICAgICAgLy8gQXMgYSB3b3JrYXJvdW5kLCBJJ20gbm90IHN1cmUgd2hhdCB3b3VsZCBpc0Fic29sdXRlKCkgcmV0dXJuIHdpdGggdW5peC1saWtlIHBhdGhcclxuICAgICAgICAgICAgamFyRnVsbFBhdGggPSB1c2VySW5mbygpLmhvbWVkaXIgKyBqYXJGcm9tU2V0dGluZ3Muc2xpY2UoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoaXNBYnNvbHV0ZShqYXJGcm9tU2V0dGluZ3MpKSB7XHJcbiAgICAgICAgICAgICAgICBqYXJGdWxsUGF0aCA9IGphckZyb21TZXR0aW5ncztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBkZWZhdWx0IHNlYXJjaCBwYXRoIGlzIGN1cnJlbnQgdmF1bHRcclxuICAgICAgICAgICAgICAgIGphckZ1bGxQYXRoID0gcmVzb2x2ZShwYXRoLCBqYXJGcm9tU2V0dGluZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoamFyRnVsbFBhdGgubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgbG9jYWwgamFyIGZpbGUnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKGphckZ1bGxQYXRoLmVuZHNXaXRoKCcuamFyJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmphdmFQYXRoLCAnLWphcicsICdcIicgKyBqYXJGdWxsUGF0aCArICdcIicsICctRGphdmEuYXd0LmhlYWRsZXNzPXRydWUnLCAnLWNoYXJzZXQnLCAndXRmLTgnLCAnLWdyYXBodml6ZG90JywgJ1wiJyArIHRoaXMucGx1Z2luLnNldHRpbmdzLmRvdFBhdGggKyAnXCInXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIGphckZ1bGxQYXRoLCAnLURqYXZhLmF3dC5oZWFkbGVzcz10cnVlJywgJy1jaGFyc2V0JywgJ3V0Zi04JywgJy1ncmFwaHZpemRvdCcsICdcIicgKyB0aGlzLnBsdWdpbi5zZXR0aW5ncy5kb3RQYXRoICsgJ1wiJ1xyXG4gICAgICAgIF07XHJcbiAgICB9XHJcbn1cclxuIiwgIi8qKlxyXG4gKiByZXBsYWNlIGFsbCBub24tYnJlYWtpbmcgc3BhY2VzIHdpdGggYWN0dWFsIHNwYWNlc1xyXG4gKiBAcGFyYW0gdGV4dFxyXG4gKiBAcGFyYW0gcGF0aFxyXG4gKi9cclxuaW1wb3J0IHtNYXJrZG93blBvc3RQcm9jZXNzb3JDb250ZXh0fSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IFBsYW50dW1sUGx1Z2luIGZyb20gXCIuL21haW5cIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBSZXBsYWNlciB7XHJcbiAgICBwbHVnaW46IFBsYW50dW1sUGx1Z2luO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHBsdWdpbjogUGxhbnR1bWxQbHVnaW4pIHtcclxuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVwbGFjZU5vbkJyZWFraW5nU3BhY2VzKHRleHQ6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KC9cXHI/XFxuLyk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0TGluZXM6IHN0cmluZ1tdID0gW107XHJcbiAgICAgICAgaWYgKHRleHQuc3RhcnRzV2l0aChcIkBzdGFydG1pbmRtYXBcIikpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRMaW5lcy5wdXNoKGxpbmUucmVwbGFjZSgvXFxzKy9nLCAnICcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdExpbmVzLnB1c2goLi4ubGluZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXN1bHQgPSByZXN1bHRMaW5lcy5qb2luKCdcXHJcXG4nKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0LnJlcGxhY2UoLyZuYnNwOy9naSwgXCIgXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmVwbGFjZSBhbGwgbGlua3MgaW4gdGhlIHBsdWdpbiBzeW50YXggd2l0aCB2YWxpZCBwbGFudHVtbCBsaW5rcyB0byBub3RlIGluc2lkZSB0aGUgdmF1bHRcclxuICAgICAqIEBwYXJhbSB0ZXh0IHRoZSB0ZXh0LCBpbiB3aGljaCB0byByZXBsYWNlIGFsbCBsaW5rc1xyXG4gICAgICogQHBhcmFtIHBhdGggcGF0aCBvZiB0aGUgY3VycmVudCBmaWxlXHJcbiAgICAgKiBAcGFyYW0gZmlsZXR5cGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlcGxhY2VMaW5rcyh0ZXh0OiBzdHJpbmcsIHBhdGg6IHN0cmluZywgZmlsZXR5cGU6IHN0cmluZykgOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1xcW1xcW1xcWyhbXFxzXFxTXSo/KVxcXVxcXVxcXS9nLCAoKF8sIGFyZ3MpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc3BsaXQgPSBhcmdzLnNwbGl0KFwifFwiKTtcclxuICAgICAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMucGx1Z2luLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpcnN0TGlua3BhdGhEZXN0KHNwbGl0WzBdLCBwYXRoKTtcclxuICAgICAgICAgICAgaWYoIWZpbGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIkZpbGUgd2l0aCBuYW1lOiBcIiArIHNwbGl0WzBdICsgXCIgbm90IGZvdW5kXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGFsaWFzID0gZmlsZS5iYXNlbmFtZTtcclxuICAgICAgICAgICAgaWYoZmlsZXR5cGUgPT09IFwicG5nXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gdGhpcy5wbHVnaW4uYXBwLmdldE9ic2lkaWFuVXJsKGZpbGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNwbGl0WzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxpYXMgPSBzcGxpdFsxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBcIltbXCIgKyB1cmwgKyBcIiBcIiArIGFsaWFzICsgXCJdXVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBcIltbXCIgKyBmaWxlLmJhc2VuYW1lICsgXCJdXVwiO1xyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIGdldCB0aGUgYWJzb2x1dGUgcGF0aCBvbiB0aGUgdXNlcnMgY29tcHV0ZXJcclxuICAgICAqIEBwYXJhbSBwYXRoIHZhdWx0IGxvY2FsIHBhdGhcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEZ1bGxQYXRoKHBhdGg6IHN0cmluZykge1xyXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGx1Z2luLmFwcC52YXVsdC5hZGFwdGVyLmdldEZ1bGxQYXRoKFwiXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5wbHVnaW4uYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwYXRoKTtcclxuXHJcbiAgICAgICAgaWYoIWZpbGUpIHtcclxuICAgICAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBsdWdpbi5hcHAudmF1bHQuYWRhcHRlci5nZXRGdWxsUGF0aChcIlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vQHRzLWlnbm9yZVxyXG4gICAgICAgIGNvbnN0IGZvbGRlciA9IHRoaXMucGx1Z2luLmFwcC52YXVsdC5nZXREaXJlY3RQYXJlbnQoZmlsZSk7XHJcbiAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGx1Z2luLmFwcC52YXVsdC5hZGFwdGVyLmdldEZ1bGxQYXRoKGZvbGRlci5wYXRoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0UGF0aChjdHg6IE1hcmtkb3duUG9zdFByb2Nlc3NvckNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRGdWxsUGF0aChjdHggPyBjdHguc291cmNlUGF0aCA6ICcnKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnRJbWFnZVdpdGhNYXAoZWw6IEhUTUxFbGVtZW50LCBpbWFnZTogc3RyaW5nLCBtYXA6IHN0cmluZywgZW5jb2RlZERpYWdyYW06IHN0cmluZykge1xyXG4gICAgZWwuZW1wdHkoKTtcclxuXHJcbiAgICBjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xyXG4gICAgaWYoaW1hZ2Uuc3RhcnRzV2l0aChcImh0dHBcIikpIHtcclxuICAgICAgICBpbWcuc3JjID0gaW1hZ2U7XHJcbiAgICB9ZWxzZSB7XHJcbiAgICAgICAgaW1nLnNyYyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LFwiICsgaW1hZ2U7XHJcbiAgICB9XHJcbiAgICBpbWcudXNlTWFwID0gXCIjXCIgKyBlbmNvZGVkRGlhZ3JhbTtcclxuXHJcbiAgICBpZiAobWFwLmNvbnRhaW5zKFwibWFwXCIpKSB7XHJcbiAgICAgICAgZWwuaW5uZXJIVE1MID0gbWFwO1xyXG4gICAgICAgIGVsLmNoaWxkcmVuWzBdLnNldEF0dHIoXCJuYW1lXCIsIGVuY29kZWREaWFncmFtKTtcclxuICAgIH1cclxuXHJcbiAgICBlbC5hcHBlbmRDaGlsZChpbWcpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0QXNjaWlJbWFnZShlbDogSFRNTEVsZW1lbnQsIGltYWdlOiBzdHJpbmcpIHtcclxuICAgIGVsLmVtcHR5KCk7XHJcblxyXG4gICAgY29uc3QgcHJlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInByZVwiKTtcclxuICAgIGNvbnN0IGNvZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY29kZVwiKTtcclxuICAgIHByZS5hcHBlbmRDaGlsZChjb2RlKTtcclxuICAgIGNvZGUuc2V0VGV4dChpbWFnZSk7XHJcbiAgICBlbC5hcHBlbmRDaGlsZChwcmUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0U3ZnSW1hZ2UoZWw6IEhUTUxFbGVtZW50LCBpbWFnZTogc3RyaW5nKSB7XHJcbiAgICBlbC5lbXB0eSgpO1xyXG5cclxuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcclxuICAgIGNvbnN0IHN2ZyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoaW1hZ2UsIFwiaW1hZ2Uvc3ZnK3htbFwiKTtcclxuXHJcbiAgICBjb25zdCBsaW5rcyA9IHN2Zy5nZXRFbGVtZW50c0J5VGFnTmFtZShcImFcIik7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmtzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgbGluayA9IGxpbmtzW2ldO1xyXG4gICAgICAgIGxpbmsuYWRkQ2xhc3MoXCJpbnRlcm5hbC1saW5rXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGVsLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgc3ZnLmRvY3VtZW50RWxlbWVudC5vdXRlckhUTUwpO1xyXG5cclxuXHJcbn1cclxuIiwgImV4cG9ydCBjb25zdCBMT0dPX1NWRyA9IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIiByb2xlPVxcXCJpbWdcXFwiIHdpZHRoPVxcXCIxMDBcXFwiIGhlaWdodD1cXFwiMTAwXFxcIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVxcXCJ4TWlkWU1pZCBtZWV0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMzIgMzJcXFwiPjxkZWZzPjxsaW5lYXJHcmFkaWVudCBpZD1cXFwic3ZnSURjXFxcIiB4MT1cXFwiLTMzLjQyM1xcXCIgeDI9XFxcIi0zMy4zNTNcXFwiIHkxPVxcXCItMjUwLjkxMVxcXCIgeTI9XFxcIi0yNTAuODU4XFxcIiBncmFkaWVudFRyYW5zZm9ybT1cXFwibWF0cml4KDM3LjEzNCAyNi4wMDEgMTMuNTc1IC0xOS4zODcgNDY3My40NzMgLTM5ODIuMDE5KVxcXCIgZ3JhZGllbnRVbml0cz1cXFwidXNlclNwYWNlT25Vc2VcXFwiPjxzdG9wIG9mZnNldD1cXFwiMFxcXCIgc3RvcC1jb2xvcj1cXFwiIzc2NzY3NlxcXCIvPjxzdG9wIG9mZnNldD1cXFwiMVxcXCIvPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPVxcXCJzdmdJRGFcXFwiIHgxPVxcXCItMzIuMTA3XFxcIiB4Mj1cXFwiLTMyLjAyOFxcXCIgeTE9XFxcIi0yNDIuNTYzXFxcIiB5Mj1cXFwiLTI0Mi41ODZcXFwiIGdyYWRpZW50VHJhbnNmb3JtPVxcXCJtYXRyaXgoODEuMDgxIDU2Ljc3NCAxNy4zMDYgLTI0LjcxNSA2ODA0LjAyMSAtNDE0OS42NDQpXFxcIiBncmFkaWVudFVuaXRzPVxcXCJ1c2VyU3BhY2VPblVzZVxcXCI+PHN0b3Agb2Zmc2V0PVxcXCIwXFxcIiBzdG9wLWNvbG9yPVxcXCIjMDA3OWI5XFxcIi8+PHN0b3Agb2Zmc2V0PVxcXCIxXFxcIi8+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgaWQ9XFxcInN2Z0lEZFxcXCIgeDE9XFxcIi0zMy4yODJcXFwiIHgyPVxcXCItMzMuMjI0XFxcIiB5MT1cXFwiLTI0My40MjNcXFwiIHkyPVxcXCItMjQzLjQ1NVxcXCIgZ3JhZGllbnRUcmFuc2Zvcm09XFxcIm1hdHJpeCg2MC4wMDMgNDIuMDE1IDM0LjE4NCAtNDguODIgMTAzNDMuMDA1IC0xMDQ2OS4wODQpXFxcIiBocmVmPVxcXCIjc3ZnSURhXFxcIi8+PGxpbmVhckdyYWRpZW50IGlkPVxcXCJzdmdJRGJcXFwiIHgxPVxcXCIxMi4zNTZcXFwiIHgyPVxcXCIxNC4wMTFcXFwiIHkxPVxcXCIyNi4yNjhcXFwiIHkyPVxcXCIyNi4yNjhcXFwiIGdyYWRpZW50VW5pdHM9XFxcInVzZXJTcGFjZU9uVXNlXFxcIj48c3RvcCBvZmZzZXQ9XFxcIjBcXFwiIHN0b3AtY29sb3I9XFxcIiM1OTU5NTlcXFwiLz48c3RvcCBvZmZzZXQ9XFxcIi4wODdcXFwiIHN0b3AtY29sb3I9XFxcIiM2ZTZlNmVcXFwiLz48c3RvcCBvZmZzZXQ9XFxcIi4yNDJcXFwiIHN0b3AtY29sb3I9XFxcIiM4YzhjOGNcXFwiLz48c3RvcCBvZmZzZXQ9XFxcIi40MDVcXFwiIHN0b3AtY29sb3I9XFxcIiNhNGE0YTRcXFwiLz48c3RvcCBvZmZzZXQ9XFxcIi41NzdcXFwiIHN0b3AtY29sb3I9XFxcIiNiNWI1YjVcXFwiLz48c3RvcCBvZmZzZXQ9XFxcIi43NjVcXFwiIHN0b3AtY29sb3I9XFxcIiNiZmJmYmZcXFwiLz48c3RvcCBvZmZzZXQ9XFxcIjFcXFwiIHN0b3AtY29sb3I9XFxcIiNjMmMyYzJcXFwiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD1cXFwic3ZnSURlXFxcIiB4MT1cXFwiMTguMjkxXFxcIiB4Mj1cXFwiMTkuOTQ2XFxcIiB5MT1cXFwiMjYuMTcxXFxcIiB5Mj1cXFwiMjYuMTcxXFxcIiBocmVmPVxcXCIjc3ZnSURiXFxcIi8+PGxpbmVhckdyYWRpZW50IGlkPVxcXCJzdmdJRGZcXFwiIHgxPVxcXCIyNC40NFxcXCIgeDI9XFxcIjI2LjA5NlxcXCIgeTE9XFxcIjI2LjE3MVxcXCIgeTI9XFxcIjI2LjE3MVxcXCIgaHJlZj1cXFwiI3N2Z0lEYlxcXCIvPjwvZGVmcz48cGF0aCBmaWxsPVxcXCIjMWMwYTQyXFxcIiBkPVxcXCJtMjAuMzA1IDE3Ljg3Mmw2Ljg1NSA0LjU0NmwtNS40NCAzLjA3NWwtNi44NTktNC40OTRsNS40NDQtMy4xMjd6XFxcIi8+PHBhdGggZD1cXFwibTIxLjcxNiAyNS42MTlsLS4wNTUtLjAzNmwtNy4wMDUtNC41OWw1LjY1My0zLjI0N2w3LjA1NiA0LjY4Wm0tNi42NS00LjYxM2w2LjY1OCA0LjM2Mmw1LjIzMS0yLjk1N0wyMC4zIDE4WlxcXCIvPjxwYXRoIGZpbGw9XFxcInVybCgjc3ZnSURjKVxcXCIgZD1cXFwibTI2LjQwMSAxMS45MDlsMy4wMTcgMS42ODNsLTIuMzQ4IDEuNDk2bC0yLjg1Ny0xLjg0MWwyLjE4OC0xLjMzOHpcXFwiLz48cGF0aCBkPVxcXCJtMjcuMDY5IDE1LjIxNWwtMy4wNTgtMS45N2wyLjM4Ny0xLjQ2bDMuMjI4IDEuOFptLTIuNjU0LTEuOTY2bDIuNjU1IDEuNzExbDIuMTM4LTEuMzZsLTIuOC0xLjU2NVpcXFwiLz48cGF0aCBmaWxsPVxcXCIjZmZiZDNmXFxcIiBkPVxcXCJtMTQuNDk4IDE3LjgwN2w2Ljg1NiA0LjU0N2wtNS40NCAzLjA3NWwtNi44NTktNC40OTRsNS40NDMtMy4xMjh6XFxcIi8+PHBhdGggZD1cXFwibTE1LjkxIDI1LjU1NGwtLjA1NS0uMDM2bC03LjAwNS00LjU4OWw1LjY1LTMuMjQ4bDcuMDU2IDQuNjhabS02LjY1LTQuNjEzbDYuNjU4IDQuMzU5bDUuMjMxLTIuOTU3bC02LjY1NC00LjQxM1pcXFwiLz48cGF0aCBmaWxsPVxcXCIjYTExZjQwXFxcIiBkPVxcXCJtNy45OSAxNy45NjZsNi45NjQgNC40bC01LjM3NyAzLjEzOGwtNy4zNTktNC42NTVsNS43NzItMi44ODN6XFxcIi8+PHBhdGggZD1cXFwiTTkuNTc1IDI1LjYyOUwyIDIwLjgzOGw2LTNsNy4xNjQgNC41MjdaTTIuNDM2IDIwLjg2bDcuMTQ0IDQuNTE4bDUuMTY4LTMuMDE2bC02Ljc2NC00LjI3M1pcXFwiLz48cGF0aCBmaWxsPVxcXCJ1cmwoI3N2Z0lEYSlcXFwiIGQ9XFxcIm0yLjExMSAyMS4wMjFsNy4zMzIgNC40OTR2My41NDhsLTcuMzMyLTQuNzMxdi0zLjMxMXpcXFwiLz48cGF0aCBkPVxcXCJNOS41NSAyOS4yNkwyIDI0LjM5MXYtMy41NjJsNy41NSA0LjYyNlptLTcuMzMyLTQuOTg2bDcuMTE4IDQuNTkydi0zLjI5MWwtNy4xMTgtNC4zNjJaXFxcIi8+PHBhdGggZmlsbD1cXFwidXJsKCNzdmdJRGQpXFxcIiBkPVxcXCJtMjQuMDcxIDEzLjM0M2wyLjkzOCAxLjg3OXY2LjkwOWwtMi45MzgtMS44ODR2LTYuOTA0elxcXCIvPjxwYXRoIGQ9XFxcIm0yNy4wNjMgMjIuMjI5bC0zLjA0NS0xLjk1M3YtNy4wMzFsMy4wNDUgMS45NDdabS0yLjkzOC0yLjAxMmwyLjgzMSAxLjgxNXYtNi43ODFsLTIuODMxLTEuODFaXFxcIi8+PHBhdGggZmlsbD1cXFwiI2ZmZlxcXCIgZD1cXFwiTTI3LjE0OSAyMi41MjZ2LTcuMzMybDIuMzY1LTEuNDE5djE1LjM3NEg5LjY0NnYtMy41NDhsNS40NC0zLjA3NWwuNjk5IDMuMDc1aC4wMTFsNS42NzYtMy4wNzVsLjQxOSAzLjA3NWguMDU0bDUuMjA0LTMuMDc1elxcXCIvPjxwYXRoIGQ9XFxcIk0yOS42MjEgMjkuMjU2SDkuNTM5di0zLjcxOGw1LjYyLTMuMTc3bC43IDMuMDgzbDUuNy0zLjA4N2wuNDIyIDMuMWw1LjA2MS0yLjk5MXYtNy4zMzNsMi41OC0xLjU0OFptLTE5Ljg2OC0uMjE1aDE5LjY1NFYxMy45NjRsLTIuMTUxIDEuMjl2Ny4zMzJsLS4wNTMuMDMxbC01LjIyOSAzLjA5SDIxLjhsLS40MTEtMy4wMTRsLTUuNTY0IDMuMDE0SDE1LjdsLS42ODYtMy4wMThsLTUuMjYgMi45NzNaXFxcIi8+PHJlY3Qgd2lkdGg9XFxcIjEuNjU2XFxcIiBoZWlnaHQ9XFxcIjEuNjU2XFxcIiB4PVxcXCIxMi4zNTZcXFwiIHk9XFxcIjI1LjQ0XFxcIiBmaWxsPVxcXCJ1cmwoI3N2Z0lEYilcXFwiIHJ4PVxcXCIuMjE1XFxcIiByeT1cXFwiLjIxNVxcXCIvPjxwYXRoIGQ9XFxcIk0xMy44IDI3LjJoLTEuMjNhLjMyMi4zMjIgMCAwIDEtLjMyMi0uMzIydi0xLjIyM2EuMzIyLjMyMiAwIDAgMSAuMzIyLS4zMjJoMS4yM2EuMzIyLjMyMiAwIDAgMSAuMzIyLjMyMnYxLjIyNmEuMzIyLjMyMiAwIDAgMS0uMzIyLjMxOVptLTEuMjMtMS42NTNhLjEwOC4xMDggMCAwIDAtLjEwNy4xMDd2MS4yMjZhLjEwOC4xMDggMCAwIDAgLjEwNy4xMDdoMS4yM2EuMTA4LjEwOCAwIDAgMCAuMTA3LS4xMDd2LTEuMjI1YS4xMDguMTA4IDAgMCAwLS4xMDctLjEwN1pcXFwiLz48cmVjdCB3aWR0aD1cXFwiMS42NTZcXFwiIGhlaWdodD1cXFwiMS42NTZcXFwiIHg9XFxcIjE4LjI5MVxcXCIgeT1cXFwiMjUuMzQzXFxcIiBmaWxsPVxcXCJ1cmwoI3N2Z0lEZSlcXFwiIHJ4PVxcXCIuMjE1XFxcIiByeT1cXFwiLjIxNVxcXCIvPjxwYXRoIGQ9XFxcIk0xOS43MzIgMjcuMTA2aC0xLjIyN2EuMzIyLjMyMiAwIDAgMS0uMzIyLS4zMjJ2LTEuMjI2YS4zMjIuMzIyIDAgMCAxIC4zMjItLjMyMmgxLjIyNmEuMzIyLjMyMiAwIDAgMSAuMzIyLjMyMnYxLjIyNmEuMzIyLjMyMiAwIDAgMS0uMzIxLjMyMlptLTEuMjI2LTEuNjU2YS4xMDguMTA4IDAgMCAwLS4xMDcuMTA3djEuMjI2YS4xMDguMTA4IDAgMCAwIC4xMDcuMTA3aDEuMjI2YS4xMDguMTA4IDAgMCAwIC4xMDctLjEwN3YtMS4yMjVhLjEwOC4xMDggMCAwIDAtLjEwNy0uMTA3WlxcXCIvPjxyZWN0IHdpZHRoPVxcXCIxLjY1NlxcXCIgaGVpZ2h0PVxcXCIxLjY1NlxcXCIgeD1cXFwiMjQuNDRcXFwiIHk9XFxcIjI1LjM0M1xcXCIgZmlsbD1cXFwidXJsKCNzdmdJRGYpXFxcIiByeD1cXFwiLjIxNVxcXCIgcnk9XFxcIi4yMTVcXFwiLz48cGF0aCBkPVxcXCJNMjUuODgxIDI3LjEwNmgtMS4yMjZhLjMyMi4zMjIgMCAwIDEtLjMyMi0uMzIydi0xLjIyNmEuMzIyLjMyMiAwIDAgMSAuMzIyLS4zMjJoMS4yMjZhLjMyMi4zMjIgMCAwIDEgLjMyMi4zMjJ2MS4yMjZhLjMyMi4zMjIgMCAwIDEtLjMyMi4zMjJabS0xLjIyNi0xLjY1NmEuMTA4LjEwOCAwIDAgMC0uMTA3LjEwN3YxLjIyNmEuMTA4LjEwOCAwIDAgMCAuMTA3LjEwN2gxLjIyNmEuMTA4LjEwOCAwIDAgMCAuMTA3LS4xMDd2LTEuMjI1YS4xMDguMTA4IDAgMCAwLS4xMDctLjEwN1pcXFwiLz48cGF0aCBmaWxsPVxcXCIjZWEyZDJlXFxcIiBkPVxcXCJNMjcuMjE1IDExLjIzYy0uMDUyLjA2OS0uNDE3LS4yNjItLjY1My0uNTI2YTQuNDA4IDQuNDA4IDAgMCAxLS41MTYtLjczQTIuNiAyLjYgMCAwIDEgMjUuNyA5LjJhMi4zNTggMi4zNTggMCAwIDEtLjA1Mi0uNjgyYTIuOTU5IDIuOTU5IDAgMCAxIC4xMjktLjc0OWEzLjE0MiAzLjE0MiAwIDAgMSAuNzg3LTEuMjA3YTE1LjUzMiAxNS41MzIgMCAwIDAgMS4yODMtMS40YTMuMDYyIDMuMDYyIDAgMCAwIC40NzktLjkyN2EzLjk3OSAzLjk3OSAwIDAgMCAuMTUxLS44NTVjLjAxOS0uMzY0LS4wMjUtLjU5My4wMjMtLjYxM3MuMjE1LjI3NC4yODcuNTY0YTMuMTY3IDMuMTY3IDAgMCAxLS40NTggMi4xYTYuOSA2LjkgMCAwIDEtMS4wOTQgMS40NDhhMi44IDIuOCAwIDAgMC0uODQ5IDEuMjM0YTIuNDY2IDIuNDY2IDAgMCAwLS4wODYuNjg3YTMuNDY1IDMuNDY1IDAgMCAwIC40NzYgMS41NDJjLjI4OC41NzIuNDguODMzLjQzOS44ODhaXFxcIi8+PHBhdGggZD1cXFwiTTI3LjE5MyAxMS4yNjZjLS4xMjQgMC0uNDkyLS4zNjUtLjY1MS0uNTQ0YTQuNDc4IDQuNDc4IDAgMCAxLS41Mi0uNzM0YTIuNjI4IDIuNjI4IDAgMCAxLS4zNDYtLjc4MWEyLjM3NSAyLjM3NSAwIDAgMS0uMDUzLS42OWEyLjk3OCAyLjk3OCAwIDAgMSAuMTMtLjc1NmEzLjIwOCAzLjIwOCAwIDAgMSAuNzkzLTEuMjE2Yy4yOTQtLjMzMS41LS41MjguNjU5LS42ODZhNC4zOTMgNC4zOTMgMCAwIDAgLjYyMi0uNzExYTMuMDUyIDMuMDUyIDAgMCAwIC40NzYtLjkxOWEzLjk1MSAzLjk1MSAwIDAgMCAuMTUtLjg0OWMuMDA4LS4xNTkgMC0uMjk0IDAtLjM5M2MwLS4xNTktLjAwNi0uMjI1LjAzOC0uMjQzYS4wNS4wNSAwIDAgMSAuMDQzIDBhMS4yMjYgMS4yMjYgMCAwIDEgLjI4LjU3OWEzLjE2NyAzLjE2NyAwIDAgMS0uNDYgMi4xMjFhNi45MjggNi45MjggMCAwIDEtMS4xIDEuNDUzYy0uMDU1LjA2LS4xMDkuMTE2LS4xNjIuMTcxYTIuMyAyLjMgMCAwIDAtLjY4MSAxLjA1MmEyLjQ3IDIuNDcgMCAwIDAtLjA4Mi42NzNhMy40NTggMy40NTggMCAwIDAgLjQ3MyAxLjUzYy4xMTQuMjMxLjIxNS40MTUuMjg5LjU0OWMuMTI5LjIzNS4xNzguMzIzLjE0Mi4zNjlhLjA1MS4wNTEgMCAwIDEtLjA0LjAyWk0yOC41MTIgMi44YS44NjMuODYzIDAgMCAwIDAgLjE5YzAgLjEuMDA3LjIzNiAwIC40YTQuMDIxIDQuMDIxIDAgMCAxLS4xNTIuODYxYTMuMTA2IDMuMTA2IDAgMCAxLS40ODMuOTM0YTQuNDM3IDQuNDM3IDAgMCAxLS42MjkuNzE5Yy0uMTYyLjE1OC0uMzY0LjM1NC0uNjU3LjY4M2EzLjE2OCAzLjE2OCAwIDAgMC0uNzgyIDEuMmEyLjkzMyAyLjkzMyAwIDAgMC0uMTI4Ljc0M2EyLjMyNSAyLjMyNSAwIDAgMCAuMDUyLjY3NWEyLjU5IDIuNTkgMCAwIDAgLjM0MS43NjdhNC40MjIgNC40MjIgMCAwIDAgLjUxMy43MjVhMi4wMzUgMi4wMzUgMCAwIDAgLjYxMS41MjZhMS4xODMgMS4xODMgMCAwIDAtLjE0Ny0uMzFhMTIuOTM1IDEyLjkzNSAwIDAgMS0uMjktLjU1MWEzLjUgMy41IDAgMCAxLS40ODMtMS41NjJhMi41MyAyLjUzIDAgMCAxIC4wODQtLjY4OGEyLjM3NSAyLjM3NSAwIDAgMSAuNjk0LTEuMDc1Yy4wNTItLjA1NS4xMDYtLjExMS4xNjEtLjE3MWE2Ljg3OSA2Ljg3OSAwIDAgMCAxLjA5LTEuNDQyYTMuMTE5IDMuMTE5IDAgMCAwIC40NTYtMi4wODNhMS4yODEgMS4yODEgMCAwIDAtLjI1MS0uNTQxWlxcXCIvPjxwYXRoIGZpbGw9XFxcIiNlYTJkMmVcXFwiIGQ9XFxcIk0yOS45NzIgNi4wODdjLS4wMTktLjA4OC0uNDMyLS4wNC0uNzY2LjA3M2EyLjYgMi42IDAgMCAwLTEuMDU5LjcyMmEyLjggMi44IDAgMCAwLS45MTYgMS44NTVhMi45NzIgMi45NzIgMCAwIDAgLjI1OCAxLjA2Yy4yMjEuNTcyLjQ1NS43NzMuNDQ0IDEuMjI1Yy0uMDA3LjMtLjExNC40ODQtLjA0OC41NDlzLjMxNC0uMS40NjItLjMxM2ExLjggMS44IDAgMCAwIC4yNTktMS4wMjJjLS4wNDYtLjgxNS0uNi0xLjAxNS0uNjA4LTEuOGExLjg1OCAxLjg1OCAwIDAgMSAuMTI5LS42NzZjLjQ0My0xLjI1MSAxLjg4MS0xLjUwOCAxLjg0NS0xLjY3M1pcXFwiLz48cGF0aCBkPVxcXCJNMjcuOTM0IDExLjYxN2EuMDk0LjA5NCAwIDAgMS0uMDY5LS4wMjZjLS4wNDYtLjA0Ni0uMDMtLjEyMi0uMDA1LS4yMzdhMS43MTggMS43MTggMCAwIDAgLjA0NS0uMzMxYTEuMzc0IDEuMzc0IDAgMCAwLS4yMTQtLjcyYTUgNSAwIDAgMS0uMjI4LS40OTVhMi45OCAyLjk4IDAgMCAxLS4yNTktMS4wN2EyLjgxIDIuODEgMCAwIDEgLjkyMy0xLjg3NGEyLjY0IDIuNjQgMCAwIDEgMS4wNy0uNzI5YTEuNDgyIDEuNDgyIDAgMCAxIC43NjYtLjFhLjA2NS4wNjUgMCAwIDEgLjAzNy4wNDZjLjAxNS4wNy0uMDkyLjEyMS0uMzA2LjIyNGEyLjczIDIuNzMgMCAwIDAtMS41NDIgMS40NjNhMS44MjcgMS44MjcgMCAwIDAtLjEyNy42NjdhMS42NDUgMS42NDUgMCAwIDAgLjI5MS44ODVhMS44ODkgMS44ODkgMCAwIDEgLjMxNy45MTRhMS44MTQgMS44MTQgMCAwIDEtLjI2NCAxLjAzOWEuODA5LjgwOSAwIDAgMS0uNDIxLjM0MlptMS44ODktNS41NDlhMi4xMTcgMi4xMTcgMCAwIDAtLjYwOC4xMTdhMi41ODggMi41ODggMCAwIDAtMS4wNDguNzE1YTIuNzY0IDIuNzY0IDAgMCAwLS45MDkgMS44MzdhMi45MzUgMi45MzUgMCAwIDAgLjI1NiAxLjA1YTQuOTU1IDQuOTU1IDAgMCAwIC4yMjUuNDlhMS40MzMgMS40MzMgMCAwIDEgLjIyLjc0NWExLjc2NSAxLjc2NSAwIDAgMS0uMDQ3LjM0MWMtLjAxOS4wOTEtLjAzNS4xNjMtLjAwOS4xODhhLjA0Ni4wNDYgMCAwIDAgLjAzOC4wMWEuNzY5Ljc2OSAwIDAgMCAuMzgyLS4zMmExLjc5MyAxLjc5MyAwIDAgMCAuMjU0LTEuMDA1YTEuODQ0IDEuODQ0IDAgMCAwLS4zMS0uODlhMS43MTEgMS43MTEgMCAwIDEtLjMtLjkxMWExLjg3NyAxLjg3NyAwIDAgMSAuMTMtLjY4NmEyLjc3NiAyLjc3NiAwIDAgMSAxLjU3My0xLjQ5MmMuMTI2LS4wNjEuMjgzLS4xMzYuMjc3LS4xNjRsLS4wMDgtLjAwN2EuMjY0LjI2NCAwIDAgMC0uMTE2LS4wMThaXFxcIi8+PC9zdmc+XCI7XHJcblxyXG5leHBvcnQgZW51bSBPdXRwdXRUeXBlIHtcclxuICAgIFBORyA9IFwicG5nXCIsXHJcbiAgICBTVkcgPSBcInN2Z1wiLFxyXG4gICAgQVNDSUkgPSBcInR4dFwiXHJcbn1cclxuIiwgImltcG9ydCB7IGRlYm91bmNlLCBEZWJvdW5jZXIsIE1hcmtkb3duUG9zdFByb2Nlc3NvckNvbnRleHQsIE1lbnUsIE5vdGljZSwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHsgdjQgYXMgdXVpZHY0IH0gZnJvbSBcInV1aWRcIjtcclxuaW1wb3J0IFBsYW50dW1sUGx1Z2luIGZyb20gXCIuLi9tYWluXCI7XHJcbmltcG9ydCB7IFByb2Nlc3NvciB9IGZyb20gXCIuL3Byb2Nlc3NvclwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIERlYm91bmNlZFByb2Nlc3NvcnMgaW1wbGVtZW50cyBQcm9jZXNzb3Ige1xyXG5cclxuICAgIFNFQ09ORFNfVE9fTVNfRkFDVE9SID0gMTAwMDtcclxuXHJcbiAgICBkZWJvdW5jZU1hcCA9IG5ldyBNYXA8c3RyaW5nLCBEZWJvdW5jZXI8W3N0cmluZywgSFRNTEVsZW1lbnQsIE1hcmtkb3duUG9zdFByb2Nlc3NvckNvbnRleHRdLCB1bmtub3duPj4oKTtcclxuXHJcbiAgICBkZWJvdW5jZVRpbWU6IG51bWJlcjtcclxuICAgIHBsdWdpbjogUGxhbnR1bWxQbHVnaW47XHJcblxyXG4gICAgY29uc3RydWN0b3IocGx1Z2luOiBQbGFudHVtbFBsdWdpbikge1xyXG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xyXG4gICAgICAgIGNvbnN0IGRlYm91bmNlVGltZSA9IHBsdWdpbi5zZXR0aW5ncy5kZWJvdW5jZTtcclxuICAgICAgICB0aGlzLmRlYm91bmNlVGltZSA9IGRlYm91bmNlVGltZSAqIHRoaXMuU0VDT05EU19UT19NU19GQUNUT1I7XHJcbiAgICB9XHJcblxyXG4gICAgZGVmYXVsdCA9IGFzeW5jKHNvdXJjZTogc3RyaW5nLCBlbDogSFRNTEVsZW1lbnQsIGN0eDogTWFya2Rvd25Qb3N0UHJvY2Vzc29yQ29udGV4dCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IHRoaXMucG5nKHNvdXJjZSwgZWwsIGN0eCk7XHJcbiAgICB9XHJcblxyXG4gICAgcG5nID0gYXN5bmMgKHNvdXJjZTogc3RyaW5nLCBlbDogSFRNTEVsZW1lbnQsIGN0eDogTWFya2Rvd25Qb3N0UHJvY2Vzc29yQ29udGV4dCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc29yKHNvdXJjZSwgZWwsIGN0eCwgXCJwbmdcIiwgdGhpcy5wbHVnaW4uZ2V0UHJvY2Vzc29yKCkucG5nKTtcclxuICAgIH1cclxuXHJcbiAgICBhc2NpaSA9IGFzeW5jIChzb3VyY2U6IHN0cmluZywgZWw6IEhUTUxFbGVtZW50LCBjdHg6IE1hcmtkb3duUG9zdFByb2Nlc3NvckNvbnRleHQpID0+IHtcclxuICAgICAgICBhd2FpdCB0aGlzLnByb2Nlc3Nvcihzb3VyY2UsIGVsLCBjdHgsIFwiYXNjaWlcIiwgdGhpcy5wbHVnaW4uZ2V0UHJvY2Vzc29yKCkuYXNjaWkpO1xyXG4gICAgfVxyXG5cclxuICAgIHN2ZyA9IGFzeW5jIChzb3VyY2U6IHN0cmluZywgZWw6IEhUTUxFbGVtZW50LCBjdHg6IE1hcmtkb3duUG9zdFByb2Nlc3NvckNvbnRleHQpID0+IHtcclxuICAgICAgICBhd2FpdCB0aGlzLnByb2Nlc3Nvcihzb3VyY2UsIGVsLCBjdHgsIFwic3ZnXCIsIHRoaXMucGx1Z2luLmdldFByb2Nlc3NvcigpLnN2Zyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvY2Vzc29yID0gYXN5bmMgKHNvdXJjZTogc3RyaW5nLCBlbDogSFRNTEVsZW1lbnQsIGN0eDogTWFya2Rvd25Qb3N0UHJvY2Vzc29yQ29udGV4dCwgZmlsZXR5cGU6IHN0cmluZywgcHJvY2Vzc29yOiAoc291cmNlOiBzdHJpbmcsIGVsOiBIVE1MRWxlbWVudCwgY3R4OiBNYXJrZG93blBvc3RQcm9jZXNzb3JDb250ZXh0KSA9PiBQcm9taXNlPHZvaWQ+KSA9PiB7XHJcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxTb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgZWwuZGF0YXNldC5maWxldHlwZSA9IGZpbGV0eXBlO1xyXG4gICAgICAgIGVsLmNyZWF0ZUVsKFwiaDZcIiwge3RleHQ6IFwiR2VuZXJhdGluZyBQbGFudFVNTCBkaWFncmFtXCIsIGNsczogXCJwdW1sLWxvYWRpbmdcIn0pO1xyXG5cclxuICAgICAgICBpZiAoZWwuZGF0YXNldC5wbGFudHVtbERlYm91bmNlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlYm91bmNlSWQgPSBlbC5kYXRhc2V0LnBsYW50dW1sRGVib3VuY2U7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRlYm91bmNlTWFwLmhhcyhkZWJvdW5jZUlkKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWJvdW5jZU1hcC5nZXQoZGVib3VuY2VJZCkoc291cmNlLCBlbCwgY3R4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZ1bmMgPSBkZWJvdW5jZShwcm9jZXNzb3IsIHRoaXMuZGVib3VuY2VUaW1lLCB0cnVlKTtcclxuICAgICAgICAgICAgY29uc3QgdXVpZCA9IHV1aWR2NCgpO1xyXG4gICAgICAgICAgICBlbC5kYXRhc2V0LnBsYW50dW1sRGVib3VjZSA9IHV1aWQ7XHJcbiAgICAgICAgICAgIHRoaXMuZGVib3VuY2VNYXAuc2V0KHV1aWQsIGZ1bmMpO1xyXG5cclxuICAgICAgICAgICAgc291cmNlID0gdGhpcy5wbHVnaW4ucmVwbGFjZXIucmVwbGFjZU5vbkJyZWFraW5nU3BhY2VzKHNvdXJjZSk7XHJcbiAgICAgICAgICAgIHNvdXJjZSA9IHRoaXMucGx1Z2luLnJlcGxhY2VyLnJlcGxhY2VMaW5rcyhzb3VyY2UsIHRoaXMucGx1Z2luLnJlcGxhY2VyLmdldFBhdGgoY3R4KSwgZmlsZXR5cGUpO1xyXG4gICAgICAgICAgICBzb3VyY2UgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5oZWFkZXIgKyBcIlxcclxcblwiICsgc291cmNlO1xyXG4gICAgICAgICAgICBhd2FpdCBwcm9jZXNzb3Ioc291cmNlLCBlbCwgY3R4KTtcclxuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCAoZXZlbnQpID0+IHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBtZW51ID0gbmV3IE1lbnUoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hZGRJdGVtKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2V0VGl0bGUoJ0NvcHkgZGlhZ3JhbSBzb3VyY2UnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNldEljb24oJ2NsaXBib2FyZC1jb3B5JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dChvcmlnaW5hbFNvdXJjZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmFkZEl0ZW0oaXRlbSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRUaXRsZSgnQ29weSBkaWFncmFtJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRJY29uKCdpbWFnZScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGltZyA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ2ltZycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbWcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJUb0Jsb2IoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgY29weWluZyBpbWFnZSB0byBjbGlwYm9hcmQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmMgKGJsb2IpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IENsaXBib2FyZEl0ZW0oe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpbWFnZS9wbmdcIjogYmxvYlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0RpYWdyYW0gY29waWVkIHRvIGNsaXBib2FyZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdmcgPSBlbC5xdWVyeVNlbGVjdG9yKCdzdmcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ZnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHN2Zy5vdXRlckhUTUwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdEaWFncmFtIGNvcGllZCB0byBjbGlwYm9hcmQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ2NvZGUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dChjb2RlLmlubmVyVGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0RpYWdyYW0gY29waWVkIHRvIGNsaXBib2FyZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmFkZEl0ZW0oaXRlbSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRUaXRsZSgnRXhwb3J0IGRpYWdyYW0nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNldEljb24oJ2ltYWdlLWZpbGUnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGltZyA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ2ltZycpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVG9CbG9iKGltZywgJ0FuIGVycm9yIG9jY3VycmVkIHdoaWxlIGV4cG9ydGluZyB0aGUgZGlhZ3JhbScsIGFzeW5jIChibG9iKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWxlbmFtZSA9IGF3YWl0IHRoaXMuZ2V0RmlsZVBhdGgoc291cmNlLCBjdHgsICdwbmcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGJsb2IuYXJyYXlCdWZmZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmdldEZpbGUoZmlsZW5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5hcHAudmF1bHQubW9kaWZ5QmluYXJ5KGZpbGUsIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLmFwcC52YXVsdC5jcmVhdGVCaW5hcnkoZmlsZW5hbWUsIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShgRGlhZ3JhbSBleHBvcnRlZCB0byAnJHtmaWxlbmFtZX0nYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ZnID0gZWwucXVlcnlTZWxlY3Rvcignc3ZnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN2Zykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNhdmVUZXh0RmlsZShzb3VyY2UsIGN0eCwgJ3N2ZycsIHN2Zy5vdXRlckhUTUwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ2NvZGUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNhdmVUZXh0RmlsZShzb3VyY2UsIGN0eCwgJ3R4dCcsIGNvZGUuaW5uZXJUZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgbWVudS5zaG93QXRNb3VzZUV2ZW50KGV2ZW50KTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyVG9CbG9iID0gKGltZzogSFRNTEltYWdlRWxlbWVudCwgZXJyb3JNZXNzYWdlOiBzdHJpbmcsIGhhbmRsZUJsb2I6IChibG9iOiBCbG9iKSA9PiBQcm9taXNlPHZvaWQ+KSA9PiB7XHJcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICBpbWFnZS5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xyXG4gICAgICAgIGltYWdlLnNyYyA9IGltZy5zcmM7XHJcbiAgICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xyXG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xyXG4gICAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjZmZmJztcclxuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY2FudmFzLnRvQmxvYihhc3luYyAoYmxvYikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZUJsb2IoYmxvYik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShlcnJvck1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoZXJyb3JNZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RmlsZW5hbWUgPSAoc291cmNlOiBzdHJpbmcsIGN0eDogTWFya2Rvd25Qb3N0UHJvY2Vzc29yQ29udGV4dCkgPT4ge1xyXG4gICAgICAgIC8vIHRyeSBleHRyYWN0IHRoZSB0aXRsZSBvZiB0aGUgZGlhZ3JhbVxyXG4gICAgICAgIGNvbnN0IHN0YXJ0dW1sID0gc291cmNlLm1hdGNoKC9Ac3RhcnR1bWwgKC4rKS9pKTtcclxuICAgICAgICBpZiAoc3RhcnR1bWw/Lmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgJHtzdGFydHVtbFsxXS50cmltKCl9YDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IG5vdyA9IChuZXcgRGF0ZSgpKS50b0lTT1N0cmluZygpLnJlcGxhY2UoL1s6VF0rL2csICctJyk7XHJcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSB0aGlzLnBsdWdpbi5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGN0eC5zb3VyY2VQYXRoKS5uYW1lO1xyXG4gICAgICAgIHJldHVybiBgJHtmaWxlbmFtZS5zdWJzdHJpbmcoMCwgZmlsZW5hbWUubGFzdEluZGV4T2YoJy4nKSl9LSR7bm93LnN1YnN0cmluZygwLCBub3cubGFzdEluZGV4T2YoJy4nKSl9YDtcclxuICAgIH1cclxuXHJcbiAgICBnZXRGb2xkZXIgPSBhc3luYyAoY3R4OiBNYXJrZG93blBvc3RQcm9jZXNzb3JDb250ZXh0KSA9PiB7XHJcbiAgICAgICAgbGV0IGV4cG9ydFBhdGggPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5leHBvcnRQYXRoO1xyXG4gICAgICAgIGlmICghZXhwb3J0UGF0aC5zdGFydHNXaXRoKCcvJykpIHtcclxuICAgICAgICAgICAgLy8gcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50XHJcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50UGF0aCA9IHRoaXMucGx1Z2luLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoY3R4LnNvdXJjZVBhdGgpLnBhcmVudDtcclxuICAgICAgICAgICAgZXhwb3J0UGF0aCA9IGAke2RvY3VtZW50UGF0aC5wYXRofS8ke2V4cG9ydFBhdGh9YDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGV4aXN0cyA9IGF3YWl0IHRoaXMucGx1Z2luLmFwcC52YXVsdC5hZGFwdGVyLmV4aXN0cyhleHBvcnRQYXRoKTtcclxuICAgICAgICBpZiAoIWV4aXN0cykge1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5hcHAudmF1bHQuY3JlYXRlRm9sZGVyKGV4cG9ydFBhdGgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGV4cG9ydFBhdGg7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RmlsZVBhdGggPSBhc3luYyAoc291cmNlOiBzdHJpbmcsIGN0eDogTWFya2Rvd25Qb3N0UHJvY2Vzc29yQ29udGV4dCwgdHlwZTogc3RyaW5nKSA9PiB7XHJcblxyXG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gdGhpcy5nZXRGaWxlbmFtZShzb3VyY2UsIGN0eCk7XHJcbiAgICAgICAgY29uc3QgcGF0aCA9IGF3YWl0IHRoaXMuZ2V0Rm9sZGVyKGN0eCk7XHJcblxyXG4gICAgICAgIHJldHVybiBgJHtwYXRofSR7ZmlsZW5hbWV9LiR7dHlwZX1gO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEZpbGUgPSAoZmlsZU5hbWU6IHN0cmluZykgPT4ge1xyXG5cclxuICAgICAgICBsZXQgZk5hbWUgPSBmaWxlTmFtZTtcclxuICAgICAgICBpZiAoZk5hbWUuc3RhcnRzV2l0aCgnLycpKSB7XHJcbiAgICAgICAgICAgIGZOYW1lID0gZk5hbWUuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgZm9sZGVyT3JGaWxlID0gdGhpcy5wbHVnaW4uYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChmTmFtZSk7XHJcblxyXG4gICAgICAgIGlmIChmb2xkZXJPckZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZm9sZGVyT3JGaWxlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBzYXZlVGV4dEZpbGUgPSBhc3luYyAoc291cmNlOiBzdHJpbmcsIGN0eDogTWFya2Rvd25Qb3N0UHJvY2Vzc29yQ29udGV4dCwgdHlwZTogc3RyaW5nLCBkYXRhOiBzdHJpbmcpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBmaWxlbmFtZSA9IGF3YWl0IHRoaXMuZ2V0RmlsZVBhdGgoc291cmNlLCBjdHgsIHR5cGUpO1xyXG4gICAgICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5nZXRGaWxlKGZpbGVuYW1lKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChmaWxlKSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5hcHAudmF1bHQubW9kaWZ5KGZpbGUsIGRhdGEpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uYXBwLnZhdWx0LmNyZWF0ZShmaWxlbmFtZSwgZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYERpYWdyYW0gZXhwb3J0ZWQgdG8gJyR7ZmlsZW5hbWV9J2ApO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ0FuIGVycm9yIG9jY3VycmVkIHdoaWxlIHdoaWxlIGV4cG9ydGluZyB0aGUgZGlhZ3JhbScpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwgIi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuIEluIHRoZSBicm93c2VyIHdlIHRoZXJlZm9yZVxuLy8gcmVxdWlyZSB0aGUgY3J5cHRvIEFQSSBhbmQgZG8gbm90IHN1cHBvcnQgYnVpbHQtaW4gZmFsbGJhY2sgdG8gbG93ZXIgcXVhbGl0eSByYW5kb20gbnVtYmVyXG4vLyBnZW5lcmF0b3JzIChsaWtlIE1hdGgucmFuZG9tKCkpLlxudmFyIGdldFJhbmRvbVZhbHVlcztcbnZhciBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJuZygpIHtcbiAgLy8gbGF6eSBsb2FkIHNvIHRoYXQgZW52aXJvbm1lbnRzIHRoYXQgbmVlZCB0byBwb2x5ZmlsbCBoYXZlIGEgY2hhbmNlIHRvIGRvIHNvXG4gIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gZ2V0UmFuZG9tVmFsdWVzIG5lZWRzIHRvIGJlIGludm9rZWQgaW4gYSBjb250ZXh0IHdoZXJlIFwidGhpc1wiIGlzIGEgQ3J5cHRvIGltcGxlbWVudGF0aW9uLiBBbHNvLFxuICAgIC8vIGZpbmQgdGhlIGNvbXBsZXRlIGltcGxlbWVudGF0aW9uIG9mIGNyeXB0byAobXNDcnlwdG8pIG9uIElFMTEuXG4gICAgZ2V0UmFuZG9tVmFsdWVzID0gdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKSB8fCB0eXBlb2YgbXNDcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicgJiYgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQobXNDcnlwdG8pO1xuXG4gICAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcygpIG5vdCBzdXBwb3J0ZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQjZ2V0cmFuZG9tdmFsdWVzLW5vdC1zdXBwb3J0ZWQnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbn0iLCAiZXhwb3J0IGRlZmF1bHQgL14oPzpbMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMS01XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDApJC9pOyIsICJpbXBvcnQgUkVHRVggZnJvbSAnLi9yZWdleC5qcyc7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlKHV1aWQpIHtcbiAgcmV0dXJuIHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyAmJiBSRUdFWC50ZXN0KHV1aWQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2YWxpZGF0ZTsiLCAiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG5cbnZhciBieXRlVG9IZXggPSBbXTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXgucHVzaCgoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5KGFycikge1xuICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAvLyBOb3RlOiBCZSBjYXJlZnVsIGVkaXRpbmcgdGhpcyBjb2RlISAgSXQncyBiZWVuIHR1bmVkIGZvciBwZXJmb3JtYW5jZVxuICAvLyBhbmQgd29ya3MgaW4gd2F5cyB5b3UgbWF5IG5vdCBleHBlY3QuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQvcHVsbC80MzRcbiAgdmFyIHV1aWQgPSAoYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAzXV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA2XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDddXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA5XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDExXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEzXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE1XV0pLnRvTG93ZXJDYXNlKCk7IC8vIENvbnNpc3RlbmN5IGNoZWNrIGZvciB2YWxpZCBVVUlELiAgSWYgdGhpcyB0aHJvd3MsIGl0J3MgbGlrZWx5IGR1ZSB0byBvbmVcbiAgLy8gb2YgdGhlIGZvbGxvd2luZzpcbiAgLy8gLSBPbmUgb3IgbW9yZSBpbnB1dCBhcnJheSB2YWx1ZXMgZG9uJ3QgbWFwIHRvIGEgaGV4IG9jdGV0IChsZWFkaW5nIHRvXG4gIC8vIFwidW5kZWZpbmVkXCIgaW4gdGhlIHV1aWQpXG4gIC8vIC0gSW52YWxpZCBpbnB1dCB2YWx1ZXMgZm9yIHRoZSBSRkMgYHZlcnNpb25gIG9yIGB2YXJpYW50YCBmaWVsZHNcblxuICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmdpZmllZCBVVUlEIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIHJldHVybiB1dWlkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHJpbmdpZnk7IiwgImltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHN0cmluZ2lmeSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5cbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7IC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcblxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwOyAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcblxuICBpZiAoYnVmKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHJuZHNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdpZnkocm5kcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHY0OyIsICJpbXBvcnQge01hcmtkb3duUG9zdFByb2Nlc3NvckNvbnRleHQsIHJlcXVlc3R9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQge0RFRkFVTFRfU0VUVElOR1N9IGZyb20gXCIuLi9zZXR0aW5nc1wiO1xyXG5pbXBvcnQgKiBhcyBwbGFudHVtbCBmcm9tIFwicGxhbnR1bWwtZW5jb2RlclwiO1xyXG5pbXBvcnQgUGxhbnR1bWxQbHVnaW4gZnJvbSBcIi4uL21haW5cIjtcclxuaW1wb3J0IHtQcm9jZXNzb3J9IGZyb20gXCIuL3Byb2Nlc3NvclwiO1xyXG5pbXBvcnQge2luc2VydEFzY2lpSW1hZ2UsIGluc2VydEltYWdlV2l0aE1hcCwgaW5zZXJ0U3ZnSW1hZ2V9IGZyb20gXCIuLi9mdW5jdGlvbnNcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBTZXJ2ZXJQcm9jZXNzb3IgaW1wbGVtZW50cyBQcm9jZXNzb3Ige1xyXG4gICAgcGx1Z2luOiBQbGFudHVtbFBsdWdpbjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihwbHVnaW46IFBsYW50dW1sUGx1Z2luKSB7XHJcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcbiAgICB9XHJcblxyXG4gICAgc3ZnID0gYXN5bmMoc291cmNlOiBzdHJpbmcsIGVsOiBIVE1MRWxlbWVudCwgXzogTWFya2Rvd25Qb3N0UHJvY2Vzc29yQ29udGV4dCkgPT4ge1xyXG4gICAgICAgIC8vbWFrZSBzdXJlIHVybCBpcyBkZWZpbmVkLiBvbmNlIHRoZSBzZXR0aW5nIGdldHMgcmVzZXQgdG8gZGVmYXVsdCwgYW4gZW1wdHkgc3RyaW5nIHdpbGwgYmUgcmV0dXJuZWQgYnkgc2V0dGluZ3NcclxuICAgICAgICBsZXQgdXJsID0gdGhpcy5wbHVnaW4uc2V0dGluZ3Muc2VydmVyX3VybDtcclxuICAgICAgICBpZiAodXJsLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHVybCA9IERFRkFVTFRfU0VUVElOR1Muc2VydmVyX3VybDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGltYWdlVXJsQmFzZSA9IHVybCArIFwiL3N2Zy9cIjtcclxuICAgICAgICBjb25zdCBlbmNvZGVkRGlhZ3JhbSA9IHBsYW50dW1sLmVuY29kZShzb3VyY2UpO1xyXG5cclxuICAgICAgICByZXF1ZXN0KHt1cmw6IGltYWdlVXJsQmFzZSArIGVuY29kZWREaWFncmFtLCBtZXRob2Q6ICdHRVQnfSkudGhlbigodmFsdWU6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICBpbnNlcnRTdmdJbWFnZShlbCwgdmFsdWUpO1xyXG4gICAgICAgIH0pLmNhdGNoKChlcnJvcjogRXJyb3IpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVycm9yKVxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHBuZyA9IGFzeW5jKHNvdXJjZTogc3RyaW5nLCBlbDogSFRNTEVsZW1lbnQsIF86IE1hcmtkb3duUG9zdFByb2Nlc3NvckNvbnRleHQpID0+IHtcclxuICAgICAgICAvL21ha2Ugc3VyZSB1cmwgaXMgZGVmaW5lZC4gb25jZSB0aGUgc2V0dGluZyBnZXRzIHJlc2V0IHRvIGRlZmF1bHQsIGFuIGVtcHR5IHN0cmluZyB3aWxsIGJlIHJldHVybmVkIGJ5IHNldHRpbmdzXHJcbiAgICAgICAgbGV0IHVybCA9IHRoaXMucGx1Z2luLnNldHRpbmdzLnNlcnZlcl91cmw7XHJcbiAgICAgICAgaWYgKHVybC5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICB1cmwgPSBERUZBVUxUX1NFVFRJTkdTLnNlcnZlcl91cmw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBpbWFnZVVybEJhc2UgPSB1cmwgKyBcIi9wbmcvXCI7XHJcblxyXG4gICAgICAgIGNvbnN0IGVuY29kZWREaWFncmFtID0gcGxhbnR1bWwuZW5jb2RlKHNvdXJjZSk7XHJcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBpbWFnZVVybEJhc2UgKyBlbmNvZGVkRGlhZ3JhbTtcclxuXHJcbiAgICAgICAgLy9nZXQgaW1hZ2UgbWFwIGRhdGEgdG8gc3VwcG9ydCBjbGlja2luZyBsaW5rcyBpbiBkaWFncmFtc1xyXG4gICAgICAgIGNvbnN0IG1hcFVybEJhc2UgPSB1cmwgKyBcIi9tYXAvXCI7XHJcbiAgICAgICAgY29uc3QgbWFwID0gYXdhaXQgcmVxdWVzdCh7dXJsOiBtYXBVcmxCYXNlICsgZW5jb2RlZERpYWdyYW0sIG1ldGhvZDogXCJHRVRcIn0pO1xyXG5cclxuICAgICAgICBpbnNlcnRJbWFnZVdpdGhNYXAoZWwsIGltYWdlLCBtYXAsIGVuY29kZWREaWFncmFtKTtcclxuICAgIH1cclxuICAgIGFzY2lpID0gYXN5bmMoc291cmNlOiBzdHJpbmcsIGVsOiBIVE1MRWxlbWVudCwgXzogTWFya2Rvd25Qb3N0UHJvY2Vzc29yQ29udGV4dCkgPT4ge1xyXG4gICAgICAgIC8vbWFrZSBzdXJlIHVybCBpcyBkZWZpbmVkLCBvbmNlIHRoZSBzZXR0aW5nIGdldHMgcmVzZXQgdG8gZGVmYXVsdCwgYW4gZW1wdHkgc3RyaW5nIHdpbGwgYmUgcmV0dXJuZWQgYnkgc2V0dGluZ3NcclxuICAgICAgICBsZXQgdXJsID0gdGhpcy5wbHVnaW4uc2V0dGluZ3Muc2VydmVyX3VybDtcclxuICAgICAgICBpZiAodXJsLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHVybCA9IERFRkFVTFRfU0VUVElOR1Muc2VydmVyX3VybDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXNjaWlVcmxCYXNlID0gdXJsICsgXCIvdHh0L1wiO1xyXG4gICAgICAgIGNvbnN0IGVuY29kZWREaWFncmFtID0gcGxhbnR1bWwuZW5jb2RlKHNvdXJjZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVlc3Qoe3VybDogYXNjaWlVcmxCYXNlICsgZW5jb2RlZERpYWdyYW19KTtcclxuXHJcbiAgICAgICAgaWYgKHJlc3VsdC5zdGFydHNXaXRoKFwiXHVGRkZEUE5HXCIpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKTtcclxuICAgICAgICAgICAgdGV4dC5zdHlsZS5jb2xvciA9IFwicmVkXCI7XHJcbiAgICAgICAgICAgIHRleHQuaW5uZXJUZXh0ID0gXCJZb3VyIGNvbmZpZ3VyZWQgUGxhbnRVTUwgU2VydmVyIGRvZXMgbm90IHN1cHBvcnQgQVNDSUkgQXJ0XCI7XHJcbiAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKHRleHQpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnNlcnRBc2NpaUltYWdlKGVsLCByZXN1bHQpO1xyXG4gICAgfVxyXG59XHJcbiIsICJpbXBvcnQge2RlYm91bmNlLCBEZWJvdW5jZXIsIEtleW1hcCwgc2V0SWNvbiwgVGV4dEZpbGVWaWV3LCBWaWV3U3RhdGVSZXN1bHQsIFdvcmtzcGFjZUxlYWZ9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgUGxhbnR1bWxQbHVnaW4gZnJvbSBcIi4vbWFpblwiO1xyXG5pbXBvcnQge1xyXG4gICAgZHJhd1NlbGVjdGlvbixcclxuICAgIEVkaXRvclZpZXcsXHJcbiAgICBoaWdobGlnaHRBY3RpdmVMaW5lLFxyXG4gICAgaGlnaGxpZ2h0QWN0aXZlTGluZUd1dHRlcixcclxuICAgIGtleW1hcCxcclxuICAgIGxpbmVOdW1iZXJzXHJcbn0gZnJvbSBcIkBjb2RlbWlycm9yL3ZpZXdcIjtcclxuaW1wb3J0IHtBbm5vdGF0aW9uLCBFZGl0b3JTdGF0ZSwgRXh0ZW5zaW9uLCBUcmFuc2FjdGlvbn0gZnJvbSBcIkBjb2RlbWlycm9yL3N0YXRlXCI7XHJcbmltcG9ydCB7aGlnaGxpZ2h0U2VsZWN0aW9uTWF0Y2hlcywgc2VhcmNofSBmcm9tIFwiQGNvZGVtaXJyb3Ivc2VhcmNoXCI7XHJcbmltcG9ydCB7ZGVmYXVsdEtleW1hcCwgaGlzdG9yeSwgaW5kZW50V2l0aFRhYn0gZnJvbSBcIkBjb2RlbWlycm9yL2NvbW1hbmRzXCI7XHJcblxyXG5leHBvcnQgY29uc3QgVklFV19UWVBFID0gXCJwbGFudHVtbFwiO1xyXG5cclxuY29uc3Qgdmlld3M6IEVkaXRvclZpZXdbXSA9IFtdO1xyXG5cclxuY29uc3Qgc3luY0Fubm90YXRpb24gPSBBbm5vdGF0aW9uLmRlZmluZTxib29sZWFuPigpO1xyXG5cclxuZnVuY3Rpb24gc3luY0Rpc3BhdGNoKGZyb206IG51bWJlcikge1xyXG4gICAgcmV0dXJuICh0cjogVHJhbnNhY3Rpb24pID0+IHtcclxuICAgICAgICB2aWV3c1tmcm9tXS51cGRhdGUoW3RyXSk7XHJcbiAgICAgICAgaWYgKHRyLmNoYW5nZXMgJiYgdHIuYW5ub3RhdGlvbiAmJiAhdHIuY2hhbmdlcy5lbXB0eSAmJiAhdHIuYW5ub3RhdGlvbihzeW5jQW5ub3RhdGlvbikpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2aWV3cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYoaSAhPT0gZnJvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdzW2ldLmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlczogdHIuY2hhbmdlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbnM6IHN5bmNBbm5vdGF0aW9uLm9mKHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgUHVtbFZpZXcgZXh0ZW5kcyBUZXh0RmlsZVZpZXcge1xyXG4gICAgZWRpdG9yOiBFZGl0b3JWaWV3O1xyXG4gICAgcHJldmlld0VsOiBIVE1MRWxlbWVudDtcclxuICAgIHNvdXJjZUVsOiBIVE1MRWxlbWVudDtcclxuICAgIGNoYW5nZU1vZGVCdXR0b246IEhUTUxFbGVtZW50O1xyXG4gICAgY3VycmVudFZpZXc6ICdzb3VyY2UnIHwgJ3ByZXZpZXcnO1xyXG4gICAgcGx1Z2luOiBQbGFudHVtbFBsdWdpbjtcclxuICAgIGRpc3BhdGNoSWQgPSAtMTtcclxuICAgIGRlYm91bmNlZDogRGVib3VuY2VyPGFueT47XHJcblxyXG4gICAgZXh0ZW5zaW9uczogRXh0ZW5zaW9uW10gPSBbXHJcbiAgICAgICAgaGlnaGxpZ2h0QWN0aXZlTGluZSgpLFxyXG4gICAgICAgIGhpZ2hsaWdodEFjdGl2ZUxpbmVHdXR0ZXIoKSxcclxuICAgICAgICBoaWdobGlnaHRTZWxlY3Rpb25NYXRjaGVzKCksXHJcbiAgICAgICAgZHJhd1NlbGVjdGlvbigpLFxyXG4gICAgICAgIGtleW1hcC5vZihbLi4uZGVmYXVsdEtleW1hcCwgaW5kZW50V2l0aFRhYl0pLFxyXG4gICAgICAgIGhpc3RvcnkoKSxcclxuICAgICAgICBzZWFyY2goKSxcclxuICAgICAgICBFZGl0b3JWaWV3LnVwZGF0ZUxpc3RlbmVyLm9mKGFzeW5jIHYgPT4ge1xyXG4gICAgICAgICAgICBpZih2LmRvY0NoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdFNhdmUoKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVuZGVyUHJldmlldygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIF1cclxuXHJcbiAgICBjb25zdHJ1Y3RvcihsZWFmOiBXb3Jrc3BhY2VMZWFmLCBwbHVnaW46IFBsYW50dW1sUGx1Z2luKSB7XHJcbiAgICAgICAgc3VwZXIobGVhZik7XHJcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XHJcblxyXG4gICAgICAgIHRoaXMuZGVib3VuY2VkID0gZGVib3VuY2UodGhpcy5wbHVnaW4uZ2V0UHJvY2Vzc29yKCkucG5nLCB0aGlzLnBsdWdpbi5zZXR0aW5ncy5kZWJvdW5jZSAqIDEwMDAsIHRydWUpO1xyXG5cclxuICAgICAgICB0aGlzLnNvdXJjZUVsID0gdGhpcy5jb250ZW50RWwuY3JlYXRlRGl2KHtjbHM6ICdwbGFudHVtbC1zb3VyY2UtdmlldycsIGF0dHI6IHsnc3R5bGUnOiAnZGlzcGxheTogYmxvY2snfX0pO1xyXG4gICAgICAgIHRoaXMucHJldmlld0VsID0gdGhpcy5jb250ZW50RWwuY3JlYXRlRGl2KHtjbHM6ICdwbGFudHVtbC1wcmV2aWV3LXZpZXcnLCBhdHRyOiB7J3N0eWxlJzogJ2Rpc3BsYXk6IG5vbmUnfX0pO1xyXG5cclxuICAgICAgICBjb25zdCB2YXVsdCA9ICh0aGlzLmFwcC52YXVsdCBhcyBhbnkpO1xyXG5cclxuICAgICAgICBpZiAodmF1bHQuZ2V0Q29uZmlnKFwic2hvd0xpbmVOdW1iZXJcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5leHRlbnNpb25zLnB1c2gobGluZU51bWJlcnMoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHZhdWx0LmdldENvbmZpZyhcImxpbmVXcmFwXCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5zaW9ucy5wdXNoKEVkaXRvclZpZXcubGluZVdyYXBwaW5nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZWRpdG9yID0gbmV3IEVkaXRvclZpZXcoe1xyXG4gICAgICAgICAgICBzdGF0ZTogRWRpdG9yU3RhdGUuY3JlYXRlKHtcclxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbnM6IHRoaXMuZXh0ZW5zaW9ucyxcclxuICAgICAgICAgICAgICAgIGRvYzogdGhpcy5kYXRhLFxyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgcGFyZW50OiB0aGlzLnNvdXJjZUVsLFxyXG4gICAgICAgICAgICBkaXNwYXRjaDogc3luY0Rpc3BhdGNoKHZpZXdzLmxlbmd0aCksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaElkID0gdmlld3MucHVzaCh0aGlzLmVkaXRvcikgLSAxO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBnZXRWaWV3VHlwZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBWSUVXX1RZUEU7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0U3RhdGUoKTogYW55IHtcclxuICAgICAgICByZXR1cm4gc3VwZXIuZ2V0U3RhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRTdGF0ZShzdGF0ZTogYW55LCByZXN1bHQ6IFZpZXdTdGF0ZVJlc3VsdCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIC8vIHN3aXRjaCB0byBwcmV2aWV3IG1vZGVcclxuICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gJ3ByZXZpZXcnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZpZXcgPSAncHJldmlldyc7XHJcbiAgICAgICAgICAgIHNldEljb24odGhpcy5jaGFuZ2VNb2RlQnV0dG9uLCAncGVuY2lsJyk7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlTW9kZUJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCAnRWRpdCAoQ3RybCtDbGljayB0byBlZGl0IGluIG5ldyBwYW5lKScpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5wcmV2aWV3RWwuc3R5bGUuc2V0UHJvcGVydHkoJ2Rpc3BsYXknLCAnYmxvY2snKTtcclxuICAgICAgICAgICAgdGhpcy5zb3VyY2VFbC5zdHlsZS5zZXRQcm9wZXJ0eSgnZGlzcGxheScsICdub25lJyk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyUHJldmlldygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzd2l0Y2ggdG8gc291cmNlIG1vZGVcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VmlldyA9ICdzb3VyY2UnO1xyXG4gICAgICAgICAgICBzZXRJY29uKHRoaXMuY2hhbmdlTW9kZUJ1dHRvbiwgJ2xpbmVzLW9mLXRleHQnKTtcclxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VNb2RlQnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsICdQcmV2aWV3IChDdHJsK0NsaWNrIHRvIG9wZW4gaW4gbmV3IHBhbmUpJyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnByZXZpZXdFbC5zdHlsZS5zZXRQcm9wZXJ0eSgnZGlzcGxheScsICdub25lJyk7XHJcbiAgICAgICAgICAgIHRoaXMuc291cmNlRWwuc3R5bGUuc2V0UHJvcGVydHkoJ2Rpc3BsYXknLCAnYmxvY2snKTtcclxuICAgICAgICAgICAgLy90aGlzLmVkaXRvci5yZWZyZXNoKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc3VwZXIuc2V0U3RhdGUoc3RhdGUsIHJlc3VsdCk7XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgb25sb2FkKCkge1xyXG4gICAgICAgIC8vIGFkZCB0aGUgYWN0aW9uIHRvIHN3aXRjaCBiZXR3ZWVuIHNvdXJjZSBhbmQgcHJldmlldyBtb2RlXHJcbiAgICAgICAgdGhpcy5jaGFuZ2VNb2RlQnV0dG9uID0gdGhpcy5hZGRBY3Rpb24oJ2xpbmVzLW9mLXRleHQnLCAnUHJldmlldyAoQ3RybCtDbGljayB0byBvcGVuIGluIG5ldyBwYW5lKScsIChldnQpID0+IHRoaXMuc3dpdGNoTW9kZShldnQpLCAxNyk7XHJcblxyXG4gICAgICAgIC8vIHVuZG9jdW1lbnRlZDogR2V0IHRoZSBjdXJyZW50IGRlZmF1bHQgdmlldyBtb2RlIHRvIHN3aXRjaCB0b1xyXG4gICAgICAgIGNvbnN0IGRlZmF1bHRWaWV3TW9kZSA9ICh0aGlzLmFwcC52YXVsdCBhcyBhbnkpLmdldENvbmZpZygnZGVmYXVsdFZpZXdNb2RlJyk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50VmlldyA9IGRlZmF1bHRWaWV3TW9kZTtcclxuICAgICAgICBhd2FpdCB0aGlzLnNldFN0YXRlKHsuLi50aGlzLmdldFN0YXRlKCksIG1vZGU6IGRlZmF1bHRWaWV3TW9kZX0sIHt9KTtcclxuICAgIH1cclxuXHJcbiAgICBvbnVubG9hZCgpIHtcclxuICAgICAgICB2aWV3cy5yZW1vdmUodmlld3NbdGhpcy5kaXNwYXRjaElkXSk7XHJcbiAgICAgICAgdGhpcy5lZGl0b3IuZGVzdHJveSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGZ1bmN0aW9uIHRvIHN3aXRjaCBiZXR3ZWVuIHNvdXJjZSBhbmQgcHJldmlldyBtb2RlXHJcbiAgICBhc3luYyBzd2l0Y2hNb2RlKGFyZzogJ3NvdXJjZScgfCAncHJldmlldycgfCBNb3VzZUV2ZW50KSB7XHJcbiAgICAgICAgbGV0IG1vZGUgPSBhcmc7XHJcbiAgICAgICAgLy8gaWYgZm9yY2UgbW9kZSBub3QgcHJvdmlkZWQsIHN3aXRjaCB0byBvcHBvc2l0ZSBvZiBjdXJyZW50IG1vZGVcclxuICAgICAgICBpZiAoIW1vZGUgfHwgbW9kZSBpbnN0YW5jZW9mIE1vdXNlRXZlbnQpIG1vZGUgPSB0aGlzLmN1cnJlbnRWaWV3ID09PSAnc291cmNlJyA/ICdwcmV2aWV3JyA6ICdzb3VyY2UnO1xyXG5cclxuICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgTW91c2VFdmVudCkge1xyXG4gICAgICAgICAgICBpZiAoS2V5bWFwLmlzTW9kRXZlbnQoYXJnKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHAud29ya3NwYWNlLmR1cGxpY2F0ZUxlYWYodGhpcy5sZWFmKS50aGVuKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2aWV3U3RhdGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuYWN0aXZlTGVhZj8uZ2V0Vmlld1N0YXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpZXdTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3U3RhdGUuc3RhdGUgPSB7Li4udmlld1N0YXRlLnN0YXRlLCBtb2RlOiBtb2RlfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hcHAud29ya3NwYWNlLmFjdGl2ZUxlYWY/LnNldFZpZXdTdGF0ZSh2aWV3U3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXRTdGF0ZSh7Li4udGhpcy5nZXRTdGF0ZSgpLCBtb2RlOiBtb2RlfSwge30pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGdldCB0aGUgZGF0YSBmb3Igc2F2ZVxyXG4gICAgZ2V0Vmlld0RhdGEoKSA6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yLnN0YXRlLnNsaWNlRG9jKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbG9hZCB0aGUgZGF0YSBpbnRvIHRoZSB2aWV3XHJcbiAgICBhc3luYyBzZXRWaWV3RGF0YShkYXRhOiBzdHJpbmcsIGNsZWFyOiBib29sZWFuKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICAgaWYgKGNsZWFyKSB7XHJcbiAgICAgICAgICAgICB0aGlzLmVkaXRvci5zZXRTdGF0ZShFZGl0b3JTdGF0ZS5jcmVhdGUoe1xyXG4gICAgICAgICAgICAgICAgIGRvYzogZGF0YSxcclxuICAgICAgICAgICAgICAgICBleHRlbnNpb25zOiB0aGlzLmV4dGVuc2lvbnNcclxuICAgICAgICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgIHRoaXMuZWRpdG9yLmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgICBjaGFuZ2VzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgIGZyb206IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgIHRvOiB0aGlzLmVkaXRvci5zdGF0ZS5kb2MubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgICBpbnNlcnQ6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgfSlcclxuICAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIHdlJ3JlIGluIHByZXZpZXcgdmlldywgYWxzbyByZW5kZXIgdGhhdFxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRWaWV3ID09PSAncHJldmlldycpIHRoaXMucmVuZGVyUHJldmlldygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNsZWFyIHRoZSBlZGl0b3IsIGV0Y1xyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgdGhpcy5wcmV2aWV3RWwuZW1wdHkoKTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGdldERpc3BsYXlUZXh0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZpbGUpIHJldHVybiB0aGlzLmZpbGUuYmFzZW5hbWU7XHJcbiAgICAgICAgZWxzZSByZXR1cm4gXCJQbGFudFVNTCAobm8gZmlsZSlcIjtcclxuICAgIH1cclxuXHJcbiAgICBjYW5BY2NlcHRFeHRlbnNpb24oZXh0ZW5zaW9uOiBzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uID09ICdwdW1sJztcclxuICAgIH1cclxuXHJcbiAgICBnZXRJY29uKCkge1xyXG4gICAgICAgIHJldHVybiBcImRvY3VtZW50LXBsYW50dW1sXCI7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGFzeW5jIHJlbmRlclByZXZpZXcoKSB7XHJcbiAgICAgICAgaWYodGhpcy5jdXJyZW50VmlldyAhPT0gXCJwcmV2aWV3XCIpIHJldHVybjtcclxuICAgICAgICB0aGlzLnByZXZpZXdFbC5lbXB0eSgpO1xyXG4gICAgICAgIGNvbnN0IGxvYWRpbmdIZWFkZXIgPSB0aGlzLnByZXZpZXdFbC5jcmVhdGVFbChcImgxXCIsIHt0ZXh0OiBcIkxvYWRpbmdcIn0pO1xyXG4gICAgICAgIGNvbnN0IHByZXZpZXdEaXYgPSB0aGlzLnByZXZpZXdFbC5jcmVhdGVEaXYoKTtcclxuXHJcblxyXG4gICAgICAgIHRoaXMuZGVib3VuY2VkKHRoaXMuZ2V0Vmlld0RhdGEoKSwgcHJldmlld0RpdiwgbnVsbCk7XHJcbiAgICAgICAgbG9hZGluZ0hlYWRlci5yZW1vdmUoKTtcclxuICAgIH1cclxufVxyXG4iLCAiaW1wb3J0IHtDb21wb25lbnQsIEVtYmVkQ2hpbGQsIEVtYmVkQ29udGV4dCwgVEZpbGV9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgUGxhbnR1bWxQbHVnaW4gZnJvbSBcIi4vbWFpblwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFB1bWxFbWJlZCBleHRlbmRzIENvbXBvbmVudCBpbXBsZW1lbnRzIEVtYmVkQ2hpbGQge1xyXG4gICAgcGx1Z2luOiBQbGFudHVtbFBsdWdpbjtcclxuICAgIGN0eDogRW1iZWRDb250ZXh0O1xyXG4gICAgZmlsZTogVEZpbGU7XHJcblxyXG4gICAgY29uc3RydWN0b3IocGx1Z2luOiBQbGFudHVtbFBsdWdpbiwgZmlsZTogVEZpbGUsIGN0eDogRW1iZWRDb250ZXh0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuICAgICAgICB0aGlzLmZpbGUgPSBmaWxlO1xyXG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGxvYWRGaWxlKCkge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLnBsdWdpbi5hcHAudmF1bHQuY2FjaGVkUmVhZCh0aGlzLmZpbGUpO1xyXG4gICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLmdldFByb2Nlc3NvcigpLnBuZyhkYXRhLCB0aGlzLmN0eC5jb250YWluZXJFbCwgbnVsbCk7XHJcbiAgICB9XHJcblxyXG59XHJcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBLElBQUMsVUFBUyxHQUFFO0FBQUMsVUFBRyxPQUFPLFlBQVUsWUFBVSxPQUFPLFlBQVMsYUFBWTtBQUFDLGdCQUFPLFVBQVE7QUFBQSxpQkFBWSxPQUFPLFdBQVMsY0FBWSxPQUFPLEtBQUk7QUFBQyxlQUFPLElBQUc7QUFBQSxhQUFPO0FBQUMsWUFBSTtBQUFFLFlBQUcsT0FBTyxXQUFTLGFBQVk7QUFBQyxjQUFFO0FBQUEsbUJBQWUsT0FBTyxXQUFTLGFBQVk7QUFBQyxjQUFFO0FBQUEsbUJBQWUsT0FBTyxTQUFPLGFBQVk7QUFBQyxjQUFFO0FBQUEsZUFBUztBQUFDLGNBQUU7QUFBQTtBQUFLLFVBQUUsa0JBQWtCO0FBQUE7QUFBQSxPQUFPLFdBQVU7QUFBQyxVQUFJLFNBQU8sU0FBTztBQUFRLGFBQVEsV0FBVTtBQUFDLG1CQUFXLEdBQUUsR0FBRSxHQUFFO0FBQUMscUJBQVcsSUFBRSxHQUFFO0FBQUMsZ0JBQUcsQ0FBQyxFQUFFLEtBQUc7QUFBQyxrQkFBRyxDQUFDLEVBQUUsS0FBRztBQUFDLG9CQUFJLElBQUUsQUFBWSxPQUFPLFdBQW5CLGNBQTRCO0FBQVEsb0JBQUcsQ0FBQyxLQUFHO0FBQUUseUJBQU8sRUFBRSxJQUFFO0FBQUksb0JBQUc7QUFBRSx5QkFBTyxFQUFFLElBQUU7QUFBSSxvQkFBSSxJQUFFLElBQUksTUFBTSx5QkFBdUIsS0FBRTtBQUFLLHNCQUFNLEVBQUUsT0FBSyxvQkFBbUI7QUFBQTtBQUFFLGtCQUFJLElBQUUsRUFBRSxNQUFHLEVBQUMsU0FBUTtBQUFJLGdCQUFFLElBQUcsR0FBRyxLQUFLLEVBQUUsU0FBUSxTQUFTLElBQUU7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STtBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUM1RDtBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUE7QUFHMUQsWUFBSSxRQUFRO0FBQUEsVUFDVjtBQUFBLFVBQUc7QUFBQSxVQUFHO0FBQUEsVUFBRztBQUFBLFVBQUc7QUFBQSxVQUFHO0FBQUEsVUFBRztBQUFBLFVBQUc7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBSztBQUFBLFVBQ3REO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFBTTtBQUFBLFVBQU07QUFBQSxVQUFNO0FBQUEsVUFDbEQ7QUFBQSxVQUFNO0FBQUEsVUFBTztBQUFBLFVBQU87QUFBQSxVQUFPO0FBQUEsVUFBRztBQUFBO0FBR2hDLFlBQUksT0FBTztBQUFBLFVBQ1Q7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUM1RDtBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQUk7QUFBQSxVQUFJO0FBQUEsVUFBSTtBQUFBLFVBQ3BDO0FBQUEsVUFBSTtB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
