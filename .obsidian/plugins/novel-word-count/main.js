/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NovelWordCountPlugin
});
module.exports = __toCommonJS(main_exports);

// logic/debug.ts
var DebugHelper = class {
  constructor() {
    this.debugMode = false;
    this.idCounter = 0;
  }
  setDebugMode(debug) {
    this.debugMode = debug;
  }
  debug(...args) {
    if (!this.debugMode) {
      return;
    }
    console.log("novel-word-count:", ...args);
  }
  error(message) {
    if (!this.debugMode) {
      return;
    }
    console.error(message);
  }
  debugStart(name) {
    if (!this.debugMode) {
      return () => {
      };
    }
    var qualifiedName = `novel-word-count|${name} (${++this.idCounter})`;
    console.time(qualifiedName);
    return () => console.timeEnd(qualifiedName);
  }
};

// logic/event.ts
var import_obsidian = require("obsidian");

// logic/cancellation.ts
var CANCEL = Symbol("Cancel");
var CancellationToken = class {
  constructor() {
    this._isCancelled = false;
  }
  get isCancelled() {
    return this._isCancelled;
  }
  [CANCEL]() {
    this._isCancelled = true;
  }
};
var CancellationTokenSource = class {
  constructor() {
    this.token = new CancellationToken();
  }
  cancel() {
    this.token[CANCEL]();
  }
};

// logic/event.ts
var EventHelper = class {
  constructor(plugin, app, debugHelper, fileHelper) {
    this.plugin = plugin;
    this.app = app;
    this.debugHelper = debugHelper;
    this.fileHelper = fileHelper;
    this.cancellationSources = [];
  }
  async handleEvents() {
    const debouncedFileModified = (0, import_obsidian.debounce)(async (file) => {
      const countToken = this.registerNewCountToken();
      await this.fileHelper.updateFileCounts(
        file,
        this.plugin.savedData.cachedCounts,
        countToken.token
      );
      this.cancelToken(countToken);
      await this.plugin.updateDisplayedCounts(file);
      await this.plugin.saveSettings();
    }, 500);
    this.plugin.registerEvent(
      this.app.metadataCache.on("changed", async (file) => {
        this.debugHelper.debug(
          "[changed] metadataCache hook fired, scheduling file for analysis",
          file.path
        );
        debouncedFileModified(file);
      })
    );
    this.app.workspace.onLayoutReady(() => {
      this.plugin.registerEvent(
        this.app.vault.on("create", async (file) => {
          this.debugHelper.debug(
            "[create] vault hook fired, analyzing file",
            file.path
          );
          const countToken = this.registerNewCountToken();
          await this.fileHelper.updateFileCounts(
            file,
            this.plugin.savedData.cachedCounts,
            countToken.token
          );
          this.cancelToken(countToken);
          await this.plugin.updateDisplayedCounts(file);
          await this.plugin.saveSettings();
        })
      );
      this.plugin.registerEvent(
        this.app.vault.on("modify", async (file) => {
          this.debugHelper.debug(
            "[modify] vault hook fired, scheduling file for analysis",
            file.path
          );
          debouncedFileModified(file);
        })
      );
    });
    this.plugin.registerEvent(
      this.app.vault.on("delete", async (file) => {
        this.debugHelper.debug(
          "[delete] vault hook fired, forgetting file",
          file.path
        );
        this.fileHelper.removeFileCounts(
          file.path,
          this.plugin.savedData.cachedCounts
        );
        await this.plugin.updateDisplayedCounts(file);
        await this.plugin.saveSettings();
      })
    );
    this.plugin.registerEvent(
      this.app.vault.on("rename", async (file, oldPath) => {
        if (file instanceof import_obsidian.TFolder) {
          return;
        }
        this.debugHelper.debug(
          "[rename] vault hook fired, recounting file",
          file.path
        );
        this.fileHelper.removeFileCounts(
          oldPath,
          this.plugin.savedData.cachedCounts
        );
        const countToken = this.registerNewCountToken();
        await this.fileHelper.updateFileCounts(
          file,
          this.plugin.savedData.cachedCounts,
          countToken.token
        );
        this.cancelToken(countToken);
        await this.plugin.updateDisplayedCounts(file);
        await this.plugin.saveSettings();
      })
    );
    const reshowCountsIfNeeded = async (hookName) => {
      this.debugHelper.debug(`[${hookName}] hook fired`);
      const fileExplorerLeaf = await this.plugin.getFileExplorerLeaf();
      if (this.isContainerTouched(fileExplorerLeaf)) {
        this.debugHelper.debug(
          "container already touched, skipping display update"
        );
        return;
      }
      this.debugHelper.debug("container is clean, updating display");
      await this.plugin.updateDisplayedCounts();
    };
    this.plugin.registerEvent(
      this.app.workspace.on(
        "layout-change",
        (0, import_obsidian.debounce)(reshowCountsIfNeeded.bind(this, "layout-change"), 1e3)
      )
    );
  }
  isContainerTouched(leaf) {
    const container = leaf.view.containerEl;
    return container.className.includes("novel-word-count--");
  }
  async refreshAllCounts() {
    this.cancelAllCountTokens();
    const countToken = this.registerNewCountToken();
    this.debugHelper.debug("refreshAllCounts");
    this.plugin.savedData.cachedCounts = await this.fileHelper.getAllFileCounts(
      countToken.token
    );
    this.cancelToken(countToken);
    await this.plugin.saveSettings();
  }
  /*
     CANCELLATION HANDLING
   */
  registerNewCountToken() {
    const cancellationSource = new CancellationTokenSource();
    this.cancellationSources.push(cancellationSource);
    return cancellationSource;
  }
  cancelToken(source) {
    source.cancel();
    if (this.cancellationSources.includes(source)) {
      this.cancellationSources.splice(
        this.cancellationSources.indexOf(source),
        1
      );
    }
  }
  cancelAllCountTokens() {
    for (const source of this.cancellationSources) {
      source.cancel();
    }
    this.cancellationSources = [];
  }
};

// logic/file.ts
var import_obsidian3 = require("obsidian");

// logic/settings.ts
var import_obsidian2 = require("obsidian");
var COUNT_TYPE_DISPLAY_STRINGS = {
  ["none" /* None */]: "None",
  ["word" /* Word */]: "Word Count",
  ["page" /* Page */]: "Page Count",
  ["pagedecimal" /* PageDecimal */]: "Page Count (decimal)",
  ["readtime" /* ReadTime */]: "Reading Time",
  ["percentgoal" /* PercentGoal */]: "% of Word Goal",
  ["note" /* Note */]: "Note Count",
  ["character" /* Character */]: "Character Count",
  ["link" /* Link */]: "Link Count",
  ["embed" /* Embed */]: "Embed Count",
  ["alias" /* Alias */]: "First Alias",
  ["created" /* Created */]: "Created Date",
  ["modified" /* Modified */]: "Last Updated Date",
  ["filesize" /* FileSize */]: "File Size"
};
var COUNT_TYPE_DESCRIPTIONS = {
  ["none" /* None */]: "Hidden.",
  ["word" /* Word */]: "Total words.",
  ["page" /* Page */]: "Total pages, rounded up.",
  ["pagedecimal" /* PageDecimal */]: "Total pages, precise to 2 digits after the decimal.",
  ["readtime" /* ReadTime */]: "Estimated time to read the note.",
  ["percentgoal" /* PercentGoal */]: "Set a word goal by adding the 'word-goal' property to a note.",
  ["note" /* Note */]: "Total notes.",
  ["character" /* Character */]: "Total characters (letters, symbols, numbers, and spaces).",
  ["link" /* Link */]: "Total links to other notes.",
  ["embed" /* Embed */]: "Total embedded images, files, and notes.",
  ["alias" /* Alias */]: "The first alias property of each note.",
  ["created" /* Created */]: "Creation date. (On folders: earliest creation date of any note.)",
  ["modified" /* Modified */]: "Date of last edit. (On folders: latest edit date of any note.)",
  ["filesize" /* FileSize */]: "Total size on hard drive."
};
var UNFORMATTABLE_COUNT_TYPES = [
  "none" /* None */,
  "alias" /* Alias */,
  "filesize" /* FileSize */,
  "readtime" /* ReadTime */
];
var COUNT_TYPE_DEFAULT_SHORT_SUFFIXES = {
  ["word" /* Word */]: "w",
  ["page" /* Page */]: "p",
  ["pagedecimal" /* PageDecimal */]: "p",
  ["percentgoal" /* PercentGoal */]: "%",
  ["note" /* Note */]: "n",
  ["character" /* Character */]: "ch",
  ["link" /* Link */]: "x",
  ["embed" /* Embed */]: "em",
  ["created" /* Created */]: "/c",
  ["modified" /* Modified */]: "/u"
};
function getDescription(countType) {
  return `[${COUNT_TYPE_DISPLAY_STRINGS[countType]}] ${COUNT_TYPE_DESCRIPTIONS[countType]}`;
}
var COUNT_TYPES = [
  "none" /* None */,
  "word" /* Word */,
  "page" /* Page */,
  "pagedecimal" /* PageDecimal */,
  "readtime" /* ReadTime */,
  "percentgoal" /* PercentGoal */,
  "note" /* Note */,
  "character" /* Character */,
  "link" /* Link */,
  "embed" /* Embed */,
  "alias" /* Alias */,
  "created" /* Created */,
  "modified" /* Modified */,
  "filesize" /* FileSize */
];
var ALIGNMENT_TYPES = [
  "inline" /* Inline */,
  "right" /* Right */,
  "below" /* Below */
];
var DEFAULT_SETTINGS = {
  // FORMATTING
  useAdvancedFormatting: false,
  // NOTES
  countType: "word" /* Word */,
  countTypeSuffix: "w",
  countType2: "none" /* None */,
  countType2Suffix: "",
  countType3: "none" /* None */,
  countType3Suffix: "",
  pipeSeparator: "|",
  abbreviateDescriptions: false,
  alignment: "inline" /* Inline */,
  // FOLDERS
  showSameCountsOnFolders: true,
  folderCountType: "word" /* Word */,
  folderCountTypeSuffix: "w",
  folderCountType2: "none" /* None */,
  folderCountType2Suffix: "",
  folderCountType3: "none" /* None */,
  folderCountType3Suffix: "",
  folderPipeSeparator: "|",
  folderAbbreviateDescriptions: false,
  folderAlignment: "inline" /* Inline */,
  // ADVANCED
  showAdvanced: false,
  wordsPerMinute: 265,
  charsPerMinute: 500,
  wordsPerPage: 300,
  charsPerPage: 1500,
  charsPerPageIncludesWhitespace: false,
  characterCountType: "AllCharacters" /* StringLength */,
  pageCountType: "ByWords" /* ByWords */,
  includeDirectories: "",
  excludeComments: false,
  excludeCodeBlocks: false,
  excludeNonVisibleLinkPortions: false,
  excludeFootnotes: false,
  debugMode: false
};
var NovelWordCountSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.renderNoteSettings(containerEl);
    this.renderFolderSettings(containerEl);
    this.renderAdvancedSettings(containerEl);
    this.renderReanalyzeButton(containerEl);
    this.renderDonationButton(containerEl);
  }
  //
  // NOTES
  //
  renderNoteSettings(containerEl) {
    const mainHeader = containerEl.createEl("div", {
      cls: [
        "setting-item",
        "setting-item-heading",
        "novel-word-count-settings-header"
      ]
    });
    mainHeader.createEl("div", { text: "Notes" });
    mainHeader.createEl("div", {
      text: "You can display up to three data types side by side.",
      cls: "setting-item-description"
    });
    new import_obsidian2.Setting(containerEl).setDesc("Use advanced formatting").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.useAdvancedFormatting).onChange(async (value) => {
        this.plugin.settings.useAdvancedFormatting = value;
        await this.plugin.saveSettings();
        await this.plugin.updateDisplayedCounts();
        this.display();
      })
    );
    this.renderCountTypeSetting(containerEl, {
      name: "1st data type to show",
      oldCountType: this.plugin.settings.countType,
      setNewCountType: (value) => {
        this.plugin.settings.countType = value;
        this.plugin.settings.countTypeSuffix = COUNT_TYPE_DEFAULT_SHORT_SUFFIXES[this.plugin.settings.countType];
      }
    });
    this.renderCustomFormatSetting(containerEl, {
      countType: this.plugin.settings.countType,
      oldSuffix: this.plugin.settings.countTypeSuffix,
      setNewSuffix: (value) => this.plugin.settings.countTypeSuffix = value
    });
    this.renderCountTypeSetting(containerEl, {
      name: "2nd data type to show",
      oldCountType: this.plugin.settings.countType2,
      setNewCountType: (value) => {
        this.plugin.settings.countType2 = value;
        this.plugin.settings.countType2Suffix = COUNT_TYPE_DEFAULT_SHORT_SUFFIXES[this.plugin.settings.countType2];
      }
    });
    this.renderCustomFormatSetting(containerEl, {
      countType: this.plugin.settings.countType2,
      oldSuffix: this.plugin.settings.countType2Suffix,
      setNewSuffix: (value) => this.plugin.settings.countType2Suffix = value
    });
    this.renderCountTypeSetting(containerEl, {
      name: "3rd data type to show",
      oldCountType: this.plugin.settings.countType3,
      setNewCountType: (value) => {
        this.plugin.settings.countType3 = value;
        this.plugin.settings.countType3Suffix = COUNT_TYPE_DEFAULT_SHORT_SUFFIXES[this.plugin.settings.countType3];
      }
    });
    this.renderCustomFormatSetting(containerEl, {
      countType: this.plugin.settings.countType3,
      oldSuffix: this.plugin.settings.countType3Suffix,
      setNewSuffix: (value) => this.plugin.settings.countType3Suffix = value
    });
    if (this.plugin.settings.useAdvancedFormatting) {
      new import_obsidian2.Setting(containerEl).setName("Data type separator").addText(
        (text) => text.setValue(this.plugin.settings.pipeSeparator).onChange(async (value) => {
          this.plugin.settings.pipeSeparator = value;
          await this.plugin.saveSettings();
          await this.plugin.updateDisplayedCounts();
        })
      );
    }
    if (!this.plugin.settings.useAdvancedFormatting) {
      new import_obsidian2.Setting(containerEl).setName("Abbreviate descriptions").setDesc("E.g. show '120w' instead of '120 words'").addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.abbreviateDescriptions).onChange(async (value) => {
          this.plugin.settings.abbreviateDescriptions = value;
          await this.plugin.saveSettings();
          await this.plugin.updateDisplayedCounts();
        })
      );
    }
    new import_obsidian2.Setting(containerEl).setName("Alignment").setDesc(
      "Show data inline with file/folder names, right-aligned, or underneath"
    ).addDropdown((drop) => {
      drop.addOption("inline" /* Inline */, "Inline").addOption("right" /* Right */, "Right-aligned").addOption("below" /* Below */, "Below").setValue(this.plugin.settings.alignment).onChange(async (value) => {
        this.plugin.settings.alignment = value;
        await this.plugin.saveSettings();
        await this.plugin.updateDisplayedCounts();
      });
    });
  }
  renderFolderSettings(containerEl) {
    this.renderSeparator(containerEl);
    new import_obsidian2.Setting(containerEl).setHeading().setName("Folders: Same data as Notes").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showSameCountsOnFolders).onChange(async (value) => {
        this.plugin.settings.showSameCountsOnFolders = value;
        await this.plugin.saveSettings();
        this.display();
        await this.plugin.updateDisplayedCounts();
      })
    );
    if (!this.plugin.settings.showSameCountsOnFolders) {
      this.renderCountTypeSetting(containerEl, {
        name: "1st data type to show",
        oldCountType: this.plugin.settings.folderCountType,
        setNewCountType: (value) => {
          this.plugin.settings.folderCountType = value;
          this.plugin.settings.folderCountTypeSuffix = COUNT_TYPE_DEFAULT_SHORT_SUFFIXES[this.plugin.settings.folderCountType];
        }
      });
      this.renderCustomFormatSetting(containerEl, {
        countType: this.plugin.settings.folderCountType,
        oldSuffix: this.plugin.settings.folderCountTypeSuffix,
        setNewSuffix: (value) => this.plugin.settings.folderCountTypeSuffix = value
      });
      this.renderCountTypeSetting(containerEl, {
        name: "2nd data type to show",
        oldCountType: this.plugin.settings.folderCountType2,
        setNewCountType: (value) => {
          this.plugin.settings.folderCountType2 = value;
          this.plugin.settings.folderCountType2Suffix = COUNT_TYPE_DEFAULT_SHORT_SUFFIXES[this.plugin.settings.folderCountType2];
        }
      });
      this.renderCustomFormatSetting(containerEl, {
        countType: this.plugin.settings.folderCountType2,
        oldSuffix: this.plugin.settings.folderCountType2Suffix,
        setNewSuffix: (value) => this.plugin.settings.folderCountType2Suffix = value
      });
      this.renderCountTypeSetting(containerEl, {
        name: "3rd data type to show",
        oldCountType: this.plugin.settings.folderCountType3,
        setNewCountType: (value) => {
          this.plugin.settings.folderCountType3 = value;
          this.plugin.settings.folderCountType3Suffix = COUNT_TYPE_DEFAULT_SHORT_SUFFIXES[this.plugin.settings.folderCountType3];
        }
      });
      this.renderCustomFormatSetting(containerEl, {
        countType: this.plugin.settings.folderCountType3,
        oldSuffix: this.plugin.settings.folderCountType3Suffix,
        setNewSuffix: (value) => this.plugin.settings.folderCountType3Suffix = value
      });
      if (this.plugin.settings.useAdvancedFormatting) {
        new import_obsidian2.Setting(containerEl).setName("Data type separator").addText(
          (text) => text.setValue(this.plugin.settings.folderPipeSeparator).onChange(async (value) => {
            this.plugin.settings.folderPipeSeparator = value;
            await this.plugin.saveSettings();
            await this.plugin.updateDisplayedCounts();
          })
        );
      }
      if (!this.plugin.settings.useAdvancedFormatting) {
        new import_obsidian2.Setting(containerEl).setName("Abbreviate descriptions").addToggle(
          (toggle) => toggle.setValue(this.plugin.settings.folderAbbreviateDescriptions).onChange(async (value) => {
            this.plugin.settings.folderAbbreviateDescriptions = value;
            await this.plugin.saveSettings();
            await this.plugin.updateDisplayedCounts();
          })
        );
      }
      new import_obsidian2.Setting(containerEl).setName("Alignment").addDropdown((drop) => {
        drop.addOption("inline" /* Inline */, "Inline").addOption("right" /* Right */, "Right-aligned").addOption("below" /* Below */, "Below").setValue(this.plugin.settings.folderAlignment).onChange(async (value) => {
          this.plugin.settings.folderAlignment = value;
          await this.plugin.saveSettings();
          await this.plugin.updateDisplayedCounts();
        });
      });
    }
  }
  renderAdvancedSettings(containerEl) {
    this.renderSeparator(containerEl);
    new import_obsidian2.Setting(containerEl).setHeading().setName("Show advanced options").setDesc("Language compatibility and fine-tuning").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showAdvanced).onChange(async (value) => {
        this.plugin.settings.showAdvanced = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.showAdvanced) {
      const includePathsChanged = async (txt, value) => {
        this.plugin.settings.includeDirectories = value;
        await this.plugin.saveSettings();
        await this.plugin.initialize();
      };
      new import_obsidian2.Setting(containerEl).setName("Include file/folder names").setDesc(
        "Only count paths matching the indicated term(s). Case-sensitive, comma-separated. Defaults to all files. Any term starting with ! will be excluded instead of included."
      ).addText((txt) => {
        txt.setPlaceholder("").setValue(this.plugin.settings.includeDirectories).onChange((0, import_obsidian2.debounce)(includePathsChanged.bind(this, txt), 1e3));
      });
      new import_obsidian2.Setting(containerEl).setName("Exclude comments").setDesc(
        "Exclude %%Obsidian%% and <!--HTML--> comments from counts. May affect performance on large vaults."
      ).addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.excludeComments).onChange(async (value) => {
          this.plugin.settings.excludeComments = value;
          await this.plugin.saveSettings();
          await this.plugin.initialize();
        })
      );
      new import_obsidian2.Setting(containerEl).setName("Exclude code blocks").setDesc(
        "Exclude ```code blocks``` (e.g. DataView snippets) from all counts. May affect performance on large vaults."
      ).addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.excludeCodeBlocks).onChange(async (value) => {
          this.plugin.settings.excludeCodeBlocks = value;
          await this.plugin.saveSettings();
          await this.plugin.initialize();
        })
      );
      new import_obsidian2.Setting(containerEl).setName("Exclude non-visible portions of links").setDesc(
        "For external links, exclude the URI from all counts. For internal links with aliases, only count the alias. May affect performance on large vaults."
      ).addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.excludeNonVisibleLinkPortions).onChange(async (value) => {
          this.plugin.settings.excludeNonVisibleLinkPortions = value;
          await this.plugin.saveSettings();
          await this.plugin.initialize();
        })
      );
      new import_obsidian2.Setting(containerEl).setName("Exclude footnotes").setDesc(
        "Exclude footnotes[^1] from counts. May affect performance on large vaults."
      ).addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.excludeFootnotes).onChange(async (value) => {
          this.plugin.settings.excludeFootnotes = value;
          await this.plugin.saveSettings();
          await this.plugin.initialize();
        })
      );
      new import_obsidian2.Setting(containerEl).setName("Character count method").setDesc("For language compatibility").addDropdown((drop) => {
        drop.addOption("AllCharacters" /* StringLength */, "All characters").addOption(
          "ExcludeWhitespace" /* ExcludeWhitespace */,
          "Exclude whitespace"
        ).setValue(this.plugin.settings.characterCountType).onChange(async (value) => {
          this.plugin.settings.characterCountType = value;
          await this.plugin.saveSettings();
          await this.plugin.initialize();
        });
      });
      new import_obsidian2.Setting(containerEl).setName("Page count method").setDesc("For language compatibility").addDropdown((drop) => {
        drop.addOption("ByWords" /* ByWords */, "Words per page").addOption("ByChars" /* ByChars */, "Characters per page").setValue(this.plugin.settings.pageCountType).onChange(async (value) => {
          this.plugin.settings.pageCountType = value;
          await this.plugin.saveSettings();
          this.display();
          await this.plugin.updateDisplayedCounts();
        });
      });
      const wordsPerMinuteChanged = async (txt, value) => {
        const asNumber = Number(value);
        const isValid = !isNaN(asNumber) && asNumber > 0;
        txt.inputEl.style.borderColor = isValid ? null : "red";
        this.plugin.settings.wordsPerMinute = isValid ? Number(value) : 265;
        await this.plugin.saveSettings();
        await this.plugin.initialize();
      };
      new import_obsidian2.Setting(containerEl).setName("Words per minute").setDesc(
        "Used to calculate Reading Time. 265 is the average speed of an English-speaking adult."
      ).addText((txt) => {
        txt.setPlaceholder("265").setValue(this.plugin.settings.wordsPerMinute.toString()).onChange((0, import_obsidian2.debounce)(wordsPerMinuteChanged.bind(this, txt), 1e3));
      });
      const charsPerMinuteChanged = async (txt, value) => {
        const asNumber = Number(value);
        const isValid = !isNaN(asNumber) && asNumber > 0;
        txt.inputEl.style.borderColor = isValid ? null : "red";
        this.plugin.settings.charsPerMinute = isValid ? Number(value) : 500;
        await this.plugin.saveSettings();
        await this.plugin.initialize();
      };
      new import_obsidian2.Setting(containerEl).setName("CJK characters per minute").setDesc(
        "Used to calculate Reading Time. 500 is the average speed for CJK texts."
      ).addText((txt) => {
        txt.setPlaceholder("500").setValue(this.plugin.settings.charsPerMinute.toString()).onChange((0, import_obsidian2.debounce)(charsPerMinuteChanged.bind(this, txt), 1e3));
      });
      if (this.plugin.settings.pageCountType === "ByWords" /* ByWords */) {
        const wordsPerPageChanged = async (txt, value) => {
          const asNumber = Number(value);
          const isValid = !isNaN(asNumber) && asNumber > 0;
          txt.inputEl.style.borderColor = isValid ? null : "red";
          this.plugin.settings.wordsPerPage = isValid ? Number(value) : 300;
          await this.plugin.saveSettings();
          await this.plugin.initialize();
        };
        new import_obsidian2.Setting(containerEl).setName("Words per page").setDesc(
          "Used for page count. 300 is standard in English language publishing."
        ).addText((txt) => {
          txt.setPlaceholder("300").setValue(this.plugin.settings.wordsPerPage.toString()).onChange((0, import_obsidian2.debounce)(wordsPerPageChanged.bind(this, txt), 1e3));
        });
      }
      if (this.plugin.settings.pageCountType === "ByChars" /* ByChars */) {
        new import_obsidian2.Setting(containerEl).setName("Include whitespace characters in page count").addToggle(
          (toggle) => toggle.setValue(this.plugin.settings.charsPerPageIncludesWhitespace).onChange(async (value) => {
            this.plugin.settings.charsPerPageIncludesWhitespace = value;
            await this.plugin.saveSettings();
            this.display();
            await this.plugin.initialize();
          })
        );
        const charsPerPageChanged = async (txt, value) => {
          const asNumber = Number(value);
          const isValid = !isNaN(asNumber) && asNumber > 0;
          txt.inputEl.style.borderColor = isValid ? null : "red";
          const defaultCharsPerPage = 1500;
          this.plugin.settings.charsPerPage = isValid ? Number(value) : defaultCharsPerPage;
          await this.plugin.saveSettings();
          await this.plugin.initialize();
        };
        new import_obsidian2.Setting(containerEl).setName("Characters per page").setDesc(
          `Used for page count. ${this.plugin.settings.charsPerPageIncludesWhitespace ? "2400 is common in Danish." : "1500 is common in German (Normseite)."}`
        ).addText((txt) => {
          txt.setPlaceholder("1500").setValue(this.plugin.settings.charsPerPage.toString()).onChange((0, import_obsidian2.debounce)(charsPerPageChanged.bind(this, txt), 1e3));
        });
      }
      new import_obsidian2.Setting(containerEl).setName("Debug mode").setDesc("Log debugging information to the developer console").addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.debugMode).onChange(async (value) => {
          this.plugin.settings.debugMode = value;
          this.plugin.debugHelper.setDebugMode(value);
          this.plugin.fileHelper.setDebugMode(value);
          await this.plugin.saveSettings();
        })
      );
    }
  }
  renderReanalyzeButton(containerEl) {
    this.renderSeparator(containerEl);
    new import_obsidian2.Setting(containerEl).setHeading().setName("Reanalyze all documents").setDesc(
      "If changes have occurred outside of Obsidian, you may need to trigger a manual analysis"
    ).addButton(
      (button) => button.setButtonText("Reanalyze").setCta().onClick(async () => {
        button.disabled = true;
        await this.plugin.initialize();
        button.setButtonText("Done");
        button.removeCta();
        setTimeout(() => {
          button.setButtonText("Reanalyze");
          button.setCta();
          button.disabled = false;
        }, 1e3);
      })
    );
  }
  renderDonationButton(containerEl) {
    this.renderSeparator(containerEl);
    const label = containerEl.createEl("div", {
      cls: [
        "setting-item",
        "setting-item-heading",
        "novel-word-count-settings-header",
        "novel-word-count-donation-line"
      ]
    });
    label.createEl("div", {
      text: "Enjoying this plugin? Want more features?"
    });
    const button = label.createEl("div");
    button.innerHTML = `<a href='https://ko-fi.com/J3J6OWA5C' target='_blank'><img height='36' style='border:0px;height:36px;' src='https://storage.ko-fi.com/cdn/kofi2.png?v=3' border='0' alt='Buy Me a Coffee at ko-fi.com' /></a>`;
  }
  renderCountTypeSetting(containerEl, config) {
    new import_obsidian2.Setting(containerEl).setName(config.name).setDesc(getDescription(config.oldCountType)).addDropdown((drop) => {
      for (const countType of COUNT_TYPES) {
        drop.addOption(countType, COUNT_TYPE_DISPLAY_STRINGS[countType]);
      }
      drop.setValue(config.oldCountType).onChange(async (value) => {
        config.setNewCountType(value);
        await this.plugin.saveSettings();
        this.display();
        await this.plugin.updateDisplayedCounts();
      });
    });
  }
  renderCustomFormatSetting(containerEl, config) {
    if (!this.plugin.settings.useAdvancedFormatting || config.countType === "none" /* None */) {
      return;
    }
    if (UNFORMATTABLE_COUNT_TYPES.includes(config.countType)) {
      new import_obsidian2.Setting(containerEl).setDesc(
        `[${COUNT_TYPE_DISPLAY_STRINGS[config.countType]}] can't be formatted.`
      );
    } else {
      new import_obsidian2.Setting(containerEl).setDesc(
        `[${COUNT_TYPE_DISPLAY_STRINGS[config.countType]}] Custom suffix`
      ).addText(
        (text) => text.setValue(config.oldSuffix).onChange(async (value) => {
          config.setNewSuffix(value);
          await this.plugin.saveSettings();
          await this.plugin.updateDisplayedCounts();
        })
      );
    }
  }
  renderSeparator(containerEl) {
    containerEl.createEl("hr", {
      cls: "novel-word-count-hr"
    });
  }
};

// logic/parser.ts
var cjkRegex = /[\p{Script=Han}\p{Script=Hiragana}\p{Script=Katakana}\p{Script=Hangul}]/gu;
var allSymbolsRegex = /[\p{S}\p{P}]/gu;
function countMarkdown(content, config) {
  content = removeNonCountedContent(content, config);
  let wordSequences = content.replace(cjkRegex, " ").replace(allSymbolsRegex, "").trim().split(/\s+/);
  if (wordSequences.length === 1 && wordSequences[0] === "") {
    wordSequences = [];
  }
  const result = {
    charCount: content.length,
    nonWhitespaceCharCount: countNonWhitespaceCharacters(content),
    spaceDelimitedWordCount: wordSequences.length,
    cjkWordCount: (content.match(cjkRegex) || []).length
  };
  return result;
}
var whitespaceRegex = /\s/g;
function countNonWhitespaceCharacters(content) {
  return content.replace(whitespaceRegex, "").length;
}
function removeNonCountedContent(content, config) {
  if (config.excludeCodeBlocks) {
    content = content.replace(/(```.+?```)/gims, "");
  }
  if (config.excludeComments) {
    content = content.replace(/(%%.+?%%|<!--.+?-->)/gims, "");
  }
  if (config.excludeNonVisibleLinkPortions) {
    content = content.replace(/\[([^\]]*?)\]\([^\)]*?\)/gim, "$1");
    content = content.replace(/\[\[(.*?)\]\]/gim, (_, $1) => {
      return !$1 ? "" : $1.includes("|") ? $1.slice($1.indexOf("|") + 1) : $1;
    });
  }
  if (config.excludeFootnotes) {
    content = content.replace(/\[\^.+?\]: .*/gim, "");
    content = content.replace(/\[\^.+?\]/gim, "");
  }
  return content;
}

// logic/canvas.ts
var CanvasHelper = class {
  constructor(debug) {
    this.debug = debug;
  }
  getCanvasText(file, content) {
    try {
      const canvas = JSON.parse(content);
      const texts = canvas.nodes.map((node) => node.text).filter((text) => !!text);
      return texts.join("\n");
    } catch (ex) {
      this.debug.error(`Unable to parse canvas file [${file.name}]: ${ex}`);
      return "";
    }
  }
};

// logic/file.ts
var FileHelper = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
    this.debugHelper = new DebugHelper();
    this.canvasHelper = new CanvasHelper(this.debugHelper);
    this.pathIncludeMatchers = [];
    this.pathExcludeMatchers = [];
    this.FileTypeAllowlist = /* @__PURE__ */ new Set([
      "",
      // Markdown extensions
      "markdown",
      "md",
      "mdml",
      "mdown",
      "mdtext",
      "mdtxt",
      "mdwn",
      "mkd",
      "mkdn",
      // Obsidian canvas
      "canvas",
      // Text files
      "txt",
      "text",
      "rtf",
      // MD with embedded code
      "qmd",
      "rmd",
      // MD for screenwriters
      "fountain"
    ]);
  }
  get settings() {
    return this.plugin.settings;
  }
  get vault() {
    return this.app.vault;
  }
  async getAllFileCounts(cancellationToken) {
    const debugEnd = this.debugHelper.debugStart("getAllFileCounts");
    let files = this.vault.getFiles();
    if (typeof this.plugin.settings.includeDirectories === "string" && this.plugin.settings.includeDirectories.trim() !== "*" && this.plugin.settings.includeDirectories.trim() !== "") {
      const allMatchers = this.plugin.settings.includeDirectories.trim().split(",").map((matcher) => matcher.trim());
      const includeMatchers = allMatchers.filter(
        (matcher) => !matcher.startsWith("!")
      );
      const excludeMatchers = allMatchers.filter((matcher) => matcher.startsWith("!")).map((matcher) => matcher.slice(1));
      const matchedFiles = files.filter(
        (file) => (includeMatchers.length === 0 ? true : includeMatchers.some((matcher) => file.path.includes(matcher))) && !excludeMatchers.some((matcher) => file.path.includes(matcher))
      );
      if (matchedFiles.length > 0) {
        this.pathIncludeMatchers = includeMatchers;
        this.pathExcludeMatchers = excludeMatchers;
      } else {
        this.pathIncludeMatchers = [];
        this.pathExcludeMatchers = [];
        this.debugHelper.debug(
          "No files matched by includeDirectories setting. Defaulting to all files."
        );
      }
    }
    const counts = {};
    for (const file of files) {
      if (cancellationToken.isCancelled) {
        break;
      }
      this.setCounts(counts, file);
    }
    debugEnd();
    return counts;
  }
  getCachedDataForPath(counts, path) {
    if (counts.hasOwnProperty(path)) {
      return counts[path];
    }
    const childPaths = this.getChildPaths(counts, path);
    const directoryDefault = {
      isCountable: false,
      isDirectory: true,
      noteCount: 0,
      wordCount: 0,
      wordCountTowardGoal: 0,
      wordGoal: 0,
      pageCount: 0,
      characterCount: 0,
      nonWhitespaceCharacterCount: 0,
      readingTimeInMinutes: 0,
      linkCount: 0,
      embedCount: 0,
      aliases: null,
      createdDate: 0,
      modifiedDate: 0,
      sizeInBytes: 0
    };
    return childPaths.reduce((total, childPath) => {
      const childCount = this.getCachedDataForPath(counts, childPath);
      return {
        isCountable: total.isCountable || childCount.isCountable,
        isDirectory: true,
        noteCount: total.noteCount + childCount.noteCount,
        linkCount: total.linkCount + childCount.linkCount,
        embedCount: total.embedCount + childCount.embedCount,
        aliases: [],
        wordCount: total.wordCount + childCount.wordCount,
        wordCountTowardGoal: total.wordCountTowardGoal + childCount.wordCountTowardGoal,
        wordGoal: total.wordGoal + childCount.wordGoal,
        pageCount: total.pageCount + childCount.pageCount,
        characterCount: total.characterCount + childCount.characterCount,
        nonWhitespaceCharacterCount: total.nonWhitespaceCharacterCount + childCount.nonWhitespaceCharacterCount,
        readingTimeInMinutes: total.readingTimeInMinutes + childCount.readingTimeInMinutes,
        createdDate: total.createdDate === 0 ? childCount.createdDate : Math.min(total.createdDate, childCount.createdDate),
        modifiedDate: Math.max(total.modifiedDate, childCount.modifiedDate),
        sizeInBytes: total.sizeInBytes + childCount.sizeInBytes
      };
    }, directoryDefault);
  }
  setDebugMode(debug) {
    this.debugHelper.setDebugMode(debug);
  }
  removeFileCounts(path, counts) {
    this.removeCounts(counts, path);
    for (const childPath of this.getChildPaths(counts, path)) {
      this.removeCounts(counts, childPath);
    }
  }
  async updateFileCounts(abstractFile, counts, cancellationToken) {
    if (abstractFile instanceof import_obsidian3.TFolder) {
      for (const child of abstractFile.children) {
        await this.updateFileCounts(child, counts, cancellationToken);
      }
      return;
    }
    if (abstractFile instanceof import_obsidian3.TFile) {
      await this.setCounts(counts, abstractFile);
    }
  }
  countEmbeds(metadata) {
    var _a, _b;
    return (_b = (_a = metadata == null ? void 0 : metadata.embeds) == null ? void 0 : _a.length) != null ? _b : 0;
  }
  countLinks(metadata) {
    var _a, _b;
    return (_b = (_a = metadata == null ? void 0 : metadata.links) == null ? void 0 : _a.length) != null ? _b : 0;
  }
  getChildPaths(counts, path) {
    const childPaths = Object.keys(counts).filter(
      (countPath) => path === "/" || countPath.startsWith(path + "/")
    );
    return childPaths;
  }
  removeCounts(counts, path) {
    delete counts[path];
  }
  async setCounts(counts, file) {
    const metadata = this.app.metadataCache.getFileCache(
      file
    );
    const shouldCountFile = this.shouldCountFile(file, metadata);
    counts[file.path] = {
      isCountable: shouldCountFile,
      isDirectory: false,
      noteCount: 0,
      wordCount: 0,
      wordCountTowardGoal: 0,
      wordGoal: 0,
      pageCount: 0,
      characterCount: 0,
      nonWhitespaceCharacterCount: 0,
      readingTimeInMinutes: 0,
      linkCount: 0,
      embedCount: 0,
      aliases: [],
      createdDate: file.stat.ctime,
      modifiedDate: file.stat.mtime,
      sizeInBytes: file.stat.size
    };
    if (!shouldCountFile) {
      return;
    }
    let content = await this.vault.cachedRead(file);
    if (file.extension.toLowerCase() === "canvas") {
      content = this.canvasHelper.getCanvasText(file, content);
    } else {
      content = this.trimFrontmatter(content, metadata);
    }
    const countResult = countMarkdown(content, {
      excludeCodeBlocks: this.settings.excludeCodeBlocks,
      excludeComments: this.settings.excludeComments,
      excludeNonVisibleLinkPortions: this.settings.excludeNonVisibleLinkPortions,
      excludeFootnotes: this.settings.excludeFootnotes
    });
    const combinedWordCount = countResult.cjkWordCount + countResult.spaceDelimitedWordCount;
    const wordGoal = this.getWordGoal(metadata);
    const cjkReadingTime = countResult.cjkWordCount / (this.settings.charsPerMinute || 500);
    const spaceDelimitedReadingTime = countResult.spaceDelimitedWordCount / (this.settings.wordsPerMinute || 265);
    const readingTimeInMinutes = cjkReadingTime + spaceDelimitedReadingTime;
    let pageCount = 0;
    if (this.settings.pageCountType === "ByWords" /* ByWords */) {
      const wordsPerPage = Number(this.settings.wordsPerPage);
      const wordsPerPageValid = !isNaN(wordsPerPage) && wordsPerPage > 0;
      pageCount = combinedWordCount / (wordsPerPageValid ? wordsPerPage : 300);
    } else if (this.settings.pageCountType === "ByChars" /* ByChars */ && !this.settings.charsPerPageIncludesWhitespace) {
      const charsPerPage = Number(this.settings.charsPerPage);
      const charsPerPageValid = !isNaN(charsPerPage) && charsPerPage > 0;
      pageCount = countResult.nonWhitespaceCharCount / (charsPerPageValid ? charsPerPage : 1500);
    } else if (this.settings.pageCountType === "ByChars" /* ByChars */ && this.settings.charsPerPageIncludesWhitespace) {
      const charsPerPage = Number(this.settings.charsPerPage);
      const charsPerPageValid = !isNaN(charsPerPage) && charsPerPage > 0;
      pageCount = countResult.charCount / (charsPerPageValid ? charsPerPage : 1500);
    }
    Object.assign(counts[file.path], {
      noteCount: 1,
      wordCount: combinedWordCount,
      wordCountTowardGoal: wordGoal !== null ? combinedWordCount : 0,
      wordGoal,
      pageCount,
      characterCount: countResult.charCount,
      nonWhitespaceCharacterCount: countResult.nonWhitespaceCharCount,
      readingTimeInMinutes,
      linkCount: this.countLinks(metadata),
      embedCount: this.countEmbeds(metadata),
      aliases: (0, import_obsidian3.parseFrontMatterAliases)(metadata == null ? void 0 : metadata.frontmatter)
    });
  }
  getWordGoal(metadata) {
    const goal = metadata && metadata.frontmatter && metadata.frontmatter["word-goal"];
    if (!goal || isNaN(Number(goal))) {
      return null;
    }
    return Number(goal);
  }
  trimFrontmatter(content, metadata) {
    let meaningfulContent = content;
    const hasFrontmatter = !!metadata && !!metadata.frontmatter;
    if (hasFrontmatter) {
      const frontmatterPos = metadata.frontmatterPosition || metadata.frontmatter.position;
      meaningfulContent = frontmatterPos && frontmatterPos.start && frontmatterPos.end ? meaningfulContent.slice(0, frontmatterPos.start.offset) + meaningfulContent.slice(frontmatterPos.end.offset) : meaningfulContent;
    }
    return meaningfulContent;
  }
  shouldCountFile(file, metadata) {
    if (this.pathIncludeMatchers.length > 0 && !this.pathIncludeMatchers.some((matcher) => file.path.includes(matcher))) {
      return false;
    }
    if (this.pathExcludeMatchers.length > 0 && this.pathExcludeMatchers.some((matcher) => file.path.includes(matcher))) {
      return false;
    }
    if (!this.FileTypeAllowlist.has(file.extension.toLowerCase())) {
      return false;
    }
    if (!metadata) {
      return true;
    }
    if (metadata.frontmatter && metadata.frontmatter.hasOwnProperty("wordcount") && (metadata.frontmatter.wordcount === null || metadata.frontmatter.wordcount === false || metadata.frontmatter.wordcount === "false")) {
      return false;
    }
    const tags = (0, import_obsidian3.getAllTags)(metadata).map((tag) => tag.toLowerCase());
    if (tags.length && (tags.includes("#excalidraw") || tags.filter((tag) => tag.startsWith("#exclude")).map((tag) => tag.replace(/[-_]/g, "")).includes("#excludefromwordcount"))) {
      return false;
    }
    return true;
  }
};

// logic/locale_format.ts
var locales = [...navigator.languages, "en-US"];
var NumberFormatDefault = new Intl.NumberFormat(locales);
var NumberFormatDecimal = new Intl.NumberFormat(locales, {
  minimumFractionDigits: 1,
  maximumFractionDigits: 2
});
var NumberFormatFileSize = new Intl.NumberFormat(locales, {
  minimumFractionDigits: 0,
  maximumFractionDigits: 2
});

// logic/filesize.ts
var formatThresholds = [{
  suffix: "B",
  suffixLong: " B",
  divisor: 1
}, {
  suffix: "kB",
  suffixLong: " kB",
  divisor: 1e3
}, {
  suffix: "MB",
  suffixLong: " MB",
  divisor: 1e6
}, {
  suffix: "GB",
  suffixLong: " GB",
  divisor: 1e9
}, {
  suffix: "TB",
  suffixLong: " TB",
  divisor: 1e12
}];
var FileSizeHelper = class {
  formatFileSize(bytes, shouldAbbreviate) {
    const largestThreshold = formatThresholds.last();
    for (const formatThreshold of formatThresholds) {
      if (bytes < formatThreshold.divisor * 1e3 || formatThreshold === largestThreshold) {
        const units = bytes / formatThreshold.divisor;
        const suffix = shouldAbbreviate ? formatThreshold.suffix : formatThreshold.suffixLong;
        return `${NumberFormatFileSize.format(units)}${suffix}`;
      }
    }
    return `?B`;
  }
};

// logic/readtime.ts
var ReadTimeHelper = class {
  formatReadTime(minutes, shouldAbbreviate) {
    const final = shouldAbbreviate ? "" : " read";
    if (minutes * 60 < 1) {
      return `0m${final}`;
    }
    if (minutes < 1) {
      const seconds = Math.round(minutes * 60);
      return `${seconds}s${final}`;
    }
    if (minutes < 60) {
      return `${Math.round(minutes)}m${final}`;
    }
    const hours = NumberFormatDefault.format(Math.floor(minutes / 60));
    const remainder = Math.floor(minutes) % 60;
    return remainder === 0 ? `${hours}h${final}` : `${hours}h${remainder}m${final}`;
  }
};

// logic/node_label.ts
var import_obsidian4 = require("obsidian");
var NodeLabelHelper = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.fileSizeHelper = new FileSizeHelper();
    this.readTimeHelper = new ReadTimeHelper();
    this.unconditionalCountTypes = [
      "created" /* Created */,
      "filesize" /* FileSize */,
      "modified" /* Modified */
    ];
  }
  get settings() {
    return this.plugin.settings;
  }
  getNodeLabel(counts) {
    const countTypes = counts.isDirectory && !this.settings.showSameCountsOnFolders ? [
      this.getCountTypeWithSuffix(
        this.settings.folderCountType,
        this.settings.folderCountTypeSuffix
      ),
      this.getCountTypeWithSuffix(
        this.settings.folderCountType2,
        this.settings.folderCountType2Suffix
      ),
      this.getCountTypeWithSuffix(
        this.settings.folderCountType3,
        this.settings.folderCountType3Suffix
      )
    ] : [
      this.getCountTypeWithSuffix(
        this.settings.countType,
        this.settings.countTypeSuffix
      ),
      this.getCountTypeWithSuffix(
        this.settings.countType2,
        this.settings.countType2Suffix
      ),
      this.getCountTypeWithSuffix(
        this.settings.countType3,
        this.settings.countType3Suffix
      )
    ];
    const abbreviateDescriptions = counts.isDirectory && !this.settings.showSameCountsOnFolders ? this.settings.folderAbbreviateDescriptions : this.settings.abbreviateDescriptions;
    const separator = !this.settings.useAdvancedFormatting ? "|" : counts.isDirectory && !this.settings.showSameCountsOnFolders ? this.settings.folderPipeSeparator : this.settings.pipeSeparator;
    return countTypes.filter((ct) => ct.countType !== "none" /* None */).map(
      (ct) => this.getDataTypeLabel(
        counts,
        ct.countType,
        abbreviateDescriptions,
        ct.overrideSuffix
      )
    ).filter((display) => display !== null).join(` ${separator} `);
  }
  getCountTypeWithSuffix(countType, customSuffix) {
    return {
      countType,
      overrideSuffix: this.settings.useAdvancedFormatting ? customSuffix : null
    };
  }
  getBasicCountString(config) {
    var _a;
    const defaultSuffix = config.abbreviateDescriptions ? config.abbreviatedNoun : ` ${config.noun}${config.count == "1" ? "" : "s"}`;
    const suffix = (_a = config.overrideSuffix) != null ? _a : defaultSuffix;
    return `${config.count}${suffix}`;
  }
  getDataTypeLabel(counts, countType, abbreviateDescriptions, overrideSuffix) {
    if (!counts || typeof counts.wordCount !== "number") {
      return null;
    }
    if (!counts.isCountable && !this.unconditionalCountTypes.includes(countType)) {
      return null;
    }
    switch (countType) {
      case "none" /* None */:
        return null;
      case "word" /* Word */:
        return this.getBasicCountString({
          count: NumberFormatDefault.format(Math.ceil(counts.wordCount)),
          noun: "word",
          abbreviatedNoun: "w",
          abbreviateDescriptions,
          overrideSuffix
        });
      case "page" /* Page */:
        return this.getBasicCountString({
          count: NumberFormatDefault.format(Math.ceil(counts.pageCount)),
          noun: "page",
          abbreviatedNoun: "p",
          abbreviateDescriptions,
          overrideSuffix
        });
      case "pagedecimal" /* PageDecimal */:
        return this.getBasicCountString({
          count: NumberFormatDecimal.format(counts.pageCount),
          noun: "page",
          abbreviatedNoun: "p",
          abbreviateDescriptions,
          overrideSuffix
        });
      case "percentgoal" /* PercentGoal */:
        if (counts.wordGoal <= 0) {
          return null;
        }
        const fraction = counts.wordCountTowardGoal / counts.wordGoal;
        const percent = NumberFormatDefault.format(Math.round(fraction * 100));
        const defaultSuffix = abbreviateDescriptions ? "%" : `% of ${NumberFormatDefault.format(counts.wordGoal)}`;
        const suffix = overrideSuffix != null ? overrideSuffix : defaultSuffix;
        return `${percent}${suffix}`;
      case "note" /* Note */:
        return this.getBasicCountString({
          count: NumberFormatDefault.format(counts.noteCount),
          noun: "note",
          abbreviatedNoun: "n",
          abbreviateDescriptions,
          overrideSuffix
        });
      case "character" /* Character */:
        const characterCount = this.settings.characterCountType === "ExcludeWhitespace" /* ExcludeWhitespace */ ? counts.nonWhitespaceCharacterCount : counts.characterCount;
        return this.getBasicCountString({
          count: NumberFormatDefault.format(characterCount),
          noun: "character",
          abbreviatedNoun: "ch",
          abbreviateDescriptions,
          overrideSuffix
        });
      case "readtime" /* ReadTime */:
        return this.readTimeHelper.formatReadTime(
          counts.readingTimeInMinutes,
          abbreviateDescriptions
        );
      case "link" /* Link */:
        if (counts.linkCount === 0) {
          return null;
        }
        return this.getBasicCountString({
          count: NumberFormatDefault.format(counts.linkCount),
          noun: "link",
          abbreviatedNoun: "x",
          abbreviateDescriptions,
          overrideSuffix
        });
      case "embed" /* Embed */:
        if (counts.embedCount === 0) {
          return null;
        }
        return this.getBasicCountString({
          count: NumberFormatDefault.format(counts.embedCount),
          noun: "embed",
          abbreviatedNoun: "em",
          abbreviateDescriptions,
          overrideSuffix
        });
      case "alias" /* Alias */:
        if (!counts.aliases || !Array.isArray(counts.aliases) || !counts.aliases.length) {
          return null;
        }
        return abbreviateDescriptions ? `${counts.aliases[0]}` : `alias: ${counts.aliases[0]}${counts.aliases.length > 1 ? ` +${counts.aliases.length - 1}` : ""}`;
      case "created" /* Created */:
        if (counts.createdDate === 0) {
          return null;
        }
        const cDate = (0, import_obsidian4.moment)(counts.createdDate).format("YYYY/MM/DD");
        if (overrideSuffix !== null) {
          return `${cDate}${overrideSuffix}`;
        }
        return abbreviateDescriptions ? `${cDate}/c` : `Created ${cDate}`;
      case "modified" /* Modified */:
        if (counts.modifiedDate === 0) {
          return null;
        }
        const uDate = (0, import_obsidian4.moment)(counts.modifiedDate).format("YYYY/MM/DD");
        if (overrideSuffix !== null) {
          return `${uDate}${overrideSuffix}`;
        }
        return abbreviateDescriptions ? `${uDate}/u` : `Updated ${uDate}`;
      case "filesize" /* FileSize */:
        return this.fileSizeHelper.formatFileSize(
          counts.sizeInBytes,
          abbreviateDescriptions
        );
    }
    return null;
  }
};

// main.ts
var import_obsidian5 = require("obsidian");
var NovelWordCountPlugin = class extends import_obsidian5.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    this.debugHelper = new DebugHelper();
    this.fileHelper = new FileHelper(this.app, this);
    this.eventHelper = new EventHelper(
      this,
      app,
      this.debugHelper,
      this.fileHelper
    );
    this.nodeLabelHelper = new NodeLabelHelper(this);
  }
  get settings() {
    return this.savedData.settings;
  }
  // LIFECYCLE
  async onload() {
    await this.loadSettings();
    this.fileHelper.setDebugMode(this.savedData.settings.debugMode);
    this.debugHelper.setDebugMode(this.savedData.settings.debugMode);
    this.debugHelper.debug(`Detected locales: [${navigator.languages}]`);
    this.debugHelper.debug("onload lifecycle hook");
    this.addSettingTab(new NovelWordCountSettingTab(this.app, this));
    this.addCommand({
      id: "recount-vault",
      name: "Reanalyze (recount) all documents in vault",
      callback: async () => {
        this.debugHelper.debug("[Reanalyze] command triggered");
        await this.initialize();
      }
    });
    this.addCommand({
      id: "cycle-count-type",
      name: "Show next data type (1st position)",
      callback: async () => {
        this.debugHelper.debug("[Cycle next data type] command triggered");
        this.settings.countType = COUNT_TYPES[(COUNT_TYPES.indexOf(this.settings.countType) + 1) % COUNT_TYPES.length];
        await this.saveSettings();
        this.updateDisplayedCounts();
      }
    });
    this.addCommand({
      id: "toggle-abbreviate",
      name: "Toggle abbreviation on Notes",
      callback: async () => {
        this.debugHelper.debug(
          "[Toggle abbrevation - Notes] command triggered"
        );
        this.settings.abbreviateDescriptions = !this.settings.abbreviateDescriptions;
        await this.saveSettings();
        this.updateDisplayedCounts();
      }
    });
    for (const countType of COUNT_TYPES) {
      this.addCommand({
        id: `set-count-type-${countType}`,
        name: `Show ${COUNT_TYPE_DISPLAY_STRINGS[countType]} (1st position)`,
        callback: async () => {
          this.debugHelper.debug(
            `[Set count type to ${countType}] command triggered`
          );
          this.settings.countType = countType;
          await this.saveSettings();
          this.updateDisplayedCounts();
        }
      });
    }
    this.eventHelper.handleEvents();
    this.initialize();
  }
  async onunload() {
    await this.saveSettings();
  }
  // SETTINGS
  async loadSettings() {
    const loaded = await this.loadData();
    if (loaded && loaded.settings && loaded.settings.countType && !COUNT_TYPES.includes(loaded.settings.countType)) {
      loaded.settings.countType = "word" /* Word */;
    }
    this.savedData = Object.assign({}, loaded);
    this.savedData.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      this.savedData.settings
    );
  }
  async saveSettings() {
    await this.saveData(this.savedData);
  }
  // PUBLIC
  async initialize(refreshAllCounts = true) {
    this.debugHelper.debug("initialize");
    this.app.workspace.onLayoutReady(async () => {
      if (refreshAllCounts) {
        await this.eventHelper.refreshAllCounts();
      }
      try {
        await this.getFileExplorerLeaf();
        await this.updateDisplayedCounts();
      } catch (err) {
        this.debugHelper.debug("Error while updating displayed counts");
        this.debugHelper.error(err);
        setTimeout(() => {
          this.initialize(false);
        }, 1e3);
      }
    });
  }
  async updateDisplayedCounts(file = null) {
    var _a, _b;
    const debugEnd = this.debugHelper.debugStart(
      `updateDisplayedCounts [${file == null ? "ALL" : file.path}]`
    );
    if (!Object.keys(this.savedData.cachedCounts).length) {
      this.debugHelper.debug("No cached data found; skipping update.");
      return;
    }
    let fileExplorerLeaf;
    try {
      fileExplorerLeaf = await this.getFileExplorerLeaf();
    } catch (err) {
      this.debugHelper.debug("File explorer leaf not found; skipping update.");
      return;
    }
    this.setContainerClass(fileExplorerLeaf);
    const fileExplorerView = fileExplorerLeaf.view;
    const fileItems = fileExplorerView.fileItems;
    if ((_a = fileExplorerView == null ? void 0 : fileExplorerView.headerDom) == null ? void 0 : _a.navButtonsEl) {
      const counts = this.fileHelper.getCachedDataForPath(
        this.savedData.cachedCounts,
        "/"
      );
      fileExplorerView.headerDom.navButtonsEl.setAttribute(
        "data-novel-word-count-plugin",
        this.nodeLabelHelper.getNodeLabel(counts)
      );
    }
    if (file) {
      const relevantItems = Object.keys(fileItems).filter(
        (path) => file.path.includes(path)
      );
      this.debugHelper.debug(
        "Setting display counts for",
        relevantItems.length,
        "fileItems matching path",
        file.path
      );
    } else {
      this.debugHelper.debug(
        `Setting display counts for ${Object.keys(fileItems).length} fileItems`
      );
    }
    for (const path in fileItems) {
      if (file && (!file.path.includes(path) || file.path === "/")) {
        continue;
      }
      const counts = this.fileHelper.getCachedDataForPath(
        this.savedData.cachedCounts,
        path
      );
      const item = fileItems[path];
      ((_b = item.titleEl) != null ? _b : item.selfEl).setAttribute(
        "data-novel-word-count-plugin",
        this.nodeLabelHelper.getNodeLabel(counts)
      );
    }
    debugEnd();
  }
  // FUNCTIONALITY
  async getFileExplorerLeaf() {
    return new Promise((resolve, reject) => {
      let foundLeaf = null;
      this.app.workspace.iterateAllLeaves((leaf) => {
        if (foundLeaf) {
          return;
        }
        const view = leaf.view;
        if (!view || !view.fileItems) {
          return;
        }
        foundLeaf = leaf;
        resolve(foundLeaf);
      });
      if (!foundLeaf) {
        reject(Error("Could not find file explorer leaf."));
      }
    });
  }
  setContainerClass(leaf) {
    const container = leaf.view.containerEl;
    container.toggleClass(`novel-word-count--active`, true);
    const notePrefix = `novel-word-count--note-`;
    const folderPrefix = `novel-word-count--folder-`;
    const alignmentClasses = ALIGNMENT_TYPES.map((at) => notePrefix + at).concat(ALIGNMENT_TYPES.map((at) => folderPrefix + at));
    for (const ac of alignmentClasses) {
      container.toggleClass(ac, false);
    }
    container.toggleClass(notePrefix + this.settings.alignment, true);
    const folderAlignment = this.settings.showSameCountsOnFolders ? this.settings.alignment : this.settings.folderAlignment;
    container.toggleClass(folderPrefix + folderAlignment, true);
  }
};
